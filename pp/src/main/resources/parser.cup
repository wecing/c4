package c4.ast;

import java.math.BigInteger;

import scala.collection.immutable.Seq;
import scala.Tuple2;
import scala.util.Either;
import scala.Option;

import java_cup.runtime.*;

import c4.io.*;
import c4.util.*;

parser code {:
  public C4Scanner getC4Scanner() {
    return (C4Scanner) getScanner();
  }

  @Override public void syntax_error(Symbol cur_token) {
    String tokenRepr = "<unknown>";
    if (0 <= cur_token.sym) {
      tokenRepr = C4Symbols.terminalNames[cur_token.sym];
    }
    tokenRepr += ", " + cur_token.value;

    System.err.println("Syntax error at " + tokenRepr);
    report_expected_token_ids();
  }

  private static <T> Option<T> some(T t) {
    return JavaUtils.some(t);
  }

  private static <T> Option<T> none() {
    return JavaUtils.none();
  }

  private static <T, P> Tuple2<T, P> pair(T t, P p) {
    return JavaUtils.pair(t, p);
  }

  private static <A, B> Either<A, B> left(A a) {
    return JavaUtils.left(a);
  }

  private static <A, B> Either<A, B> right(B b) {
    return JavaUtils.right(b);
  }

  private static <A, B> A fst(Tuple2<A, B> x) {
    return JavaUtils.fst(x);
  }

  private static <A, B> B snd(Tuple2<A, B> x) {
    return JavaUtils.snd(x);
  }

  private static <T> Seq<T> seq() {
    return JavaUtils.seq();
  }

  private static <T> T head(Seq<T> xs) {
    return JavaUtils.head(xs);
  }

  private static <T> T last(Seq<T> xs) {
    return JavaUtils.last(xs);
  }
:}

init with {: /* no need to initialize */ :};
scan with {: return getScanner().next_token(); :};

// literals
terminal Located<TokId>         ID              ;
terminal Located<TokInteger>    INTEGER_LIT     ;
terminal Located<TokFloat>      FLOAT_LIT       ;
terminal Located<TokDouble>     DOUBLE_LIT      ;
terminal Located<TokLongDouble> LONG_DOUBLE_LIT ;
terminal Located<TokChar>       CHAR_LIT        ;
terminal Located<TokWideChar>   WIDE_CHAR_LIT   ;
terminal Located<TokStr>        STR_LIT         ;
terminal Located<TokWideStr>    WIDE_STR_LIT    ;

// context-sensitive typedef name
terminal Located<TokId>         TYPEDEF_NAME    ;

// keywords
terminal Loc    AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE,
                ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER,
                RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF,
                UNION, UNSIGNED, VOID, VOLATILE, WHILE;

// extra keywords for builtins
terminal Loc    BUILTIN_OFFSETOF;

// op/sym       [       ]       (       )       {       }
terminal Loc    LSBRKT, RSBRKT, LPAREN, RPAREN, LBRACE, RBRACE,
//              .    ,      ;          ...       ->   ++   --   &      *
                DOT, COMMA, SEMICOLON, ELLIPSIS, PTR, INC, DEC, B_AND, STAR,
//              +    -    ~      !      /    %    <<      >>      <   >
                ADD, SUB, TILDE, L_NOT, DIV, MOD, LSHIFT, RSHIFT, LE, GT,
//              <=   >=   ==  !=   ^    |     &&     ||    ?      :
                LEQ, GEQ, EQ, NEQ, XOR, B_OR, L_AND, L_OR, QMARK, COLON,
//              =       *=          /=          %=          +=
                ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN,
//              -=          <<=            >>=            &=
                SUB_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN, B_AND_ASSIGN,
//              ^=          |=
                XOR_ASSIGN, B_OR_ASSIGN;

non terminal Located<TypeName> type_name;

non terminal Seq<Located<Stmt>> statement_list;
non terminal     Located<Stmt>  statement;
non terminal     Located<Stmt>  labeled_statement;
non terminal     Located<Stmt>  selection_statement;
non terminal     Located<Stmt>  iteration_statement;
non terminal     Located<Stmt>  jump_statement;

non terminal Located<ExprStmt>     expression_statement;
non terminal Located<CompoundStmt> compound_statement;

non terminal Seq<Located<Either<Located<FunctionDef>, Located<Declaration>>>>
    translation_unit;
non terminal     Located<Either<Located<FunctionDef>, Located<Declaration>>>
    external_declaration;

non terminal Located<FunctionDef> function_definition;

non terminal Seq<Located<Declaration>> declaration_list;
non terminal     Located<Declaration>  declaration;

non terminal Seq<Tuple2<Located<Declarator>, Option<Located<Initializer>>>>
    init_declarator_list;
non terminal     Tuple2<Located<Declarator>, Option<Located<Initializer>>>
    init_declarator;

non terminal Seq<Located<Initializer>> initializer_list;
non terminal     Located<Initializer>  initializer;

non terminal Located<Pointer> pointer;

non terminal Seq<Located<TokId>> identifier_list;

non terminal Seq<Located<DeclarationSpecifier>> declaration_specifiers;
non terminal Located<StorageClassSpecifier>
    storage_class_specifier;

non terminal Located<Declarator> declarator;

non terminal Located<DirectDeclarator> direct_declarator;

non terminal Located<AbstractDeclarator> abstract_declarator;

non terminal Located<DirectAbstractDeclarator> direct_abstract_declarator;

non terminal Tuple2<Seq<Located<ParamDeclaration>>, Option<Loc>>
    parameter_type_list;
non terminal        Seq<Located<ParamDeclaration>>
    parameter_list;
non terminal            Located<ParamDeclaration>
    parameter_declaration;

non terminal Seq<Tuple2<Located<TokId>, Option<Located<Expr>>>> enumerator_list;
non terminal     Tuple2<Located<TokId>, Option<Located<Expr>>>  enumerator;

non terminal Seq<Located<StructDeclaration>> struct_declaration_list;
non terminal     Located<StructDeclaration>  struct_declaration;

non terminal Seq<Tuple2<Option<Located<Declarator>>, Option<Located<Expr>>>>
    struct_declarator_list;
non terminal     Tuple2<Option<Located<Declarator>>, Option<Located<Expr>>>
    struct_declarator;

non terminal Seq<Located<TypeQualifier>>
    type_qualifier_list;
non terminal Seq<Located<Either<TypeSpecifier, TypeQualifier>>>
    specifier_qualifier_list;
non terminal Located<TypeSpecifier> type_specifier,
    enum_specifier, struct_or_union_specifier;
non terminal Located<TypeQualifier> type_qualifier;

non terminal Located<Expr> expression,
    constant_expression, assignment_expression, conditional_expression,
    logical_or_expression, logical_and_expression, inclusive_or_expression,
    exclusive_or_expression, and_expression, equality_expression,
    relational_expression, shift_expression, additive_expression,
    multiplicative_expression, unary_expression,
    postfix_expression, cast_expression,
    primary_expression;

non terminal Seq<Located<Expr>> argument_expression_list;
non terminal Located<BinaryOp> assignment_operator;

precedence nonassoc ELSE;

start with translation_unit;

translation_unit // Seq[L[Either[L[FunctionDef], L[Declaration]]]]
    ::= translation_unit:xs external_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                     external_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

external_declaration // L[Either[L[FunctionDef], L[Declaration]]]
    ::= function_definition:x
        {: RESULT = Located.of(x.loc(), left(x)); :}
      | declaration:y
        {: RESULT = Located.of(y.loc(), right(y)); :}
      ;

function_definition // Located<FunctionDef>
    ::= declaration_specifiers:dss declarator:d declaration_list:dl
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(head(dss).loc(), body.loc(),
            new FunctionDef(dss, d, some(dl), body)); :}
      | declaration_specifiers:dss declarator:d
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(head(dss).loc(), body.loc(),
            new FunctionDef(dss, d, none(), body)); :}
      |                            declarator:d declaration_list:dl
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(d.loc(), body.loc(),
            new FunctionDef(JavaUtils.seq(), d, some(dl), body)); :}
      |                            declarator:d
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(d.loc(), body.loc(),
            new FunctionDef(JavaUtils.seq(), d, none(), body)); :}
      ;

// when declaration_specifiers contains "typedef", all IDs
// appeared in init_declarator_list are added to the typedef names set.
declaration // Located<Declaration>
    ::= declaration_specifiers:dss init_declarator_list:ids SEMICOLON:l
        {: JavaUtils.checkTypedef(dss, ids, getC4Scanner());
           RESULT = Located.of(head(dss).loc(), l,
            new Declaration(dss, some(ids))); :}
      | declaration_specifiers:dss                          SEMICOLON:l
        {: RESULT = Located.of(head(dss).loc(), l, new Declaration(dss, none())); :}
      ;

declaration_specifiers // Seq[L[DeclarationSpecifier]]
    ::= storage_class_specifier:x declaration_specifiers:xs
        {: RESULT = JavaUtils.prepend(
            Located.of(x.loc(), last(xs).loc(),
                new DeclarationSpecifierStorageClass(x)),
            xs); :}
      | storage_class_specifier:x
        {: RESULT = JavaUtils.seq(
            Located.of(x.loc(),
                new DeclarationSpecifierStorageClass(x))); :}
      | type_specifier:x declaration_specifiers:xs
        {: RESULT = JavaUtils.prepend(
            Located.of(x.loc(), last(xs).loc(),
                new DeclarationSpecifierTypeSpecifier(x)),
            xs); :}
      | type_specifier:x
        {: RESULT = JavaUtils.seq(
            Located.of(x.loc(),
                new DeclarationSpecifierTypeSpecifier(x))); :}
      | type_qualifier:x declaration_specifiers:xs
        {: RESULT = JavaUtils.prepend(
            Located.of(x.loc(), last(xs).loc(),
                new DeclarationSpecifierTypeQualifier(x)),
            xs); :}
      | type_qualifier:x
        {: RESULT = JavaUtils.seq(
            Located.of(x.loc(),
                new DeclarationSpecifierTypeQualifier(x))); :}
      ;

init_declarator_list // Seq[(L[Declarator], Option[L[Initializer]])]
    ::=                               init_declarator:x
        {: RESULT = JavaUtils.seq(x); :}
      | init_declarator_list:xs COMMA init_declarator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

init_declarator // Tuple2<Located<Declarator>, Option<Located<Initializer>>>
    ::= declarator:d
        {: RESULT = pair(d, none()); :}
      | declarator:d ASSIGN initializer:i
        {: RESULT = pair(d, some(i)); :}
      ;

declarator // Located<Declarator>
    ::= pointer:ptr direct_declarator:dd
        {: RESULT = Located.of(ptr.loc(), dd.loc(),
            new Declarator(some(ptr), dd)); :}
      |             direct_declarator:dd
        {: RESULT = Located.of(dd.loc(), new Declarator(none(), dd)); :}
      ;

direct_declarator // Located<DirectDeclarator>
    ::= ID:id
        {: RESULT = new Located(id.loc(), new DirectDeclaratorId(id)); :}
      | LPAREN:l1 declarator:d RPAREN:l2
        {: RESULT = Located.of(l1, l2, new DirectDeclaratorDeclarator(d)); :}
      | direct_declarator:dd LSBRKT constant_expression:e RSBRKT:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorArray(dd, some(e))); :}
      | direct_declarator:dd LSBRKT                       RSBRKT:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorArray(dd, none())); :}
      | direct_declarator:dd LPAREN parameter_type_list:tl RPAREN:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorFuncTypes(dd, fst(tl), snd(tl))); :}
      | direct_declarator:dd LPAREN identifier_list:il RPAREN:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorIdsList(dd, il)); :}
      | direct_declarator:dd LPAREN                 RPAREN:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorIdsList(dd, JavaUtils.seq())); :}
      ;

pointer // Located<Pointer>
    ::= STAR:loc type_qualifier_list:qs pointer:ptr
        {: RESULT = Located.of(loc,      ptr.loc(), new Pointer(qs, some(ptr))); :}
      | STAR:loc type_qualifier_list:qs
        {: RESULT = Located.of(loc, head(qs).loc(), new Pointer(qs, none())); :}
      | STAR:loc                        pointer:ptr
        {: RESULT = Located.of(loc, ptr.loc(),
            new Pointer(JavaUtils.seq(), some(ptr))); :}
      | STAR:loc
        {: RESULT = Located.of(loc, new Pointer(JavaUtils.seq(), none())); :}
      ;

type_qualifier_list // Seq<Located<TypeQualifier>>
    ::= type_qualifier_list:xs type_qualifier:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                        type_qualifier:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

parameter_type_list // (Seq[Located[ParamDeclaration]], Option[Loc])
    ::= parameter_list:xs
        {: RESULT = pair(xs, none()); :}
      | parameter_list:xs COMMA ELLIPSIS:loc
        {: RESULT = pair(xs, some(loc)); :}
      ;

parameter_list // Seq[Located[ParamDeclaration]]
    ::=                         parameter_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | parameter_list:xs COMMA parameter_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

parameter_declaration // Located[ParamDeclaration]
    ::= declaration_specifiers:dss declarator:d
        {: RESULT = Located.of(head(dss).loc(), d.loc(),
            new ParamDeclarationNamed(dss, d)); :}
      | declaration_specifiers:dss abstract_declarator:ad
        {: RESULT = Located.of(head(dss).loc(), ad.loc(),
            new ParamDeclarationTypeOnly(dss, ad)); :}
      | declaration_specifiers:dss
        {: RESULT = Located.of(head(dss).loc(),
            new ParamDeclarationTypeOnlySimple(dss)); :}
      ;

identifier_list // Seq<Located<TokId>>
    ::= identifier_list:xs COMMA ID:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                          ID:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

compound_statement // Located<CompoundStmt>
    ::= LBRACE:l1 declaration_list:x statement_list:y RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(    x,     y)); :}
      | LBRACE:l1 declaration_list:x                  RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(    x, seq())); :}
      | LBRACE:l1                    statement_list:y RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(seq(),     y)); :}
      | LBRACE:l1                                     RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(seq(), seq())); :}
      ;

declaration_list // Seq<Located<Declaration>>
    ::=                     declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | declaration_list:xs declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

statement_list // Seq<Located<Stmt>>
    ::=                   statement:x
        {: RESULT = JavaUtils.seq(x); :}
      | statement_list:xs statement:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

storage_class_specifier // Located<StorageClassSpecifier>
    ::= TYPEDEF:loc  {: RESULT = Located.of(loc,  c4.ast.Typedef$.MODULE$); :}
      | EXTERN:loc   {: RESULT = Located.of(loc,   c4.ast.Extern$.MODULE$); :}
      | STATIC:loc   {: RESULT = Located.of(loc,   c4.ast.Static$.MODULE$); :}
      | AUTO:loc     {: RESULT = Located.of(loc,     c4.ast.Auto$.MODULE$); :}
      | REGISTER:loc {: RESULT = Located.of(loc, c4.ast.Register$.MODULE$); :}
      ;

type_specifier // Located<TypeSpecifier>
    ::= VOID:loc     {: RESULT = new Located(loc,     c4.ast.Void$.MODULE$); :}
      | CHAR:loc     {: RESULT = new Located(loc,     c4.ast.Char$.MODULE$); :}
      | SHORT:loc    {: RESULT = new Located(loc,    c4.ast.Short$.MODULE$); :}
      | INT:loc      {: RESULT = new Located(loc,      c4.ast.Int$.MODULE$); :}
      | LONG:loc     {: RESULT = new Located(loc,     c4.ast.Long$.MODULE$); :}
      | FLOAT:loc    {: RESULT = new Located(loc,    c4.ast.Float$.MODULE$); :}
      | DOUBLE:loc   {: RESULT = new Located(loc,   c4.ast.Double$.MODULE$); :}
      | SIGNED:loc   {: RESULT = new Located(loc,   c4.ast.Signed$.MODULE$); :}
      | UNSIGNED:loc {: RESULT = new Located(loc, c4.ast.Unsigned$.MODULE$); :}
      | struct_or_union_specifier:x     {: RESULT = x; :}
      | enum_specifier:x                {: RESULT = x; :}
      | TYPEDEF_NAME:x
        {: RESULT = new Located(x.loc(), new TypedefName(x.value())); :}
      ;

struct_or_union_specifier // Located<TypeSpecifier>
    ::= STRUCT:loc1 ID:id LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new StructSpecifier(some(id), some(body))); :}
      | STRUCT:loc1       LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new StructSpecifier(  none(), some(body))); :}
      | STRUCT:loc1 ID:id
        {: RESULT = Located$.MODULE$.of(loc1, id.loc(),
            new StructSpecifier(some(id),     none())); :}
      | UNION:loc1  ID:id LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new UnionSpecifier(some(id), some(body))); :}
      | UNION:loc1        LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new UnionSpecifier(  none(), some(body))); :}
      | UNION:loc1  ID:id
        {: RESULT = Located$.MODULE$.of(loc1, id.loc(),
            new UnionSpecifier(some(id),     none())); :}
      ;

struct_declaration_list // Seq[L[StructDeclaration]]
    ::=                            struct_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | struct_declaration_list:xs struct_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

struct_declaration // L[StructDeclaration]
    ::= specifier_qualifier_list:a struct_declarator_list:b SEMICOLON:c
        {: RESULT = StructDeclaration$.MODULE$.ofLoc(a, b, c); :}
      // unnamed fields is a C11 feature used by glibc headers.
      | specifier_qualifier_list:a                          SEMICOLON:c
        {:
          RESULT = StructDeclaration$.MODULE$.ofLoc(
            a, JavaUtils.seq(pair(none(), none())), c);
        :}
      ;

specifier_qualifier_list // Seq<Located<Either<TypeSpecifier, TypeQualifier>>>
    ::= type_specifier:x specifier_qualifier_list:xs
        {:
          RESULT = JavaUtils.prepend(
            new Located(x.loc(), left(x.value())),
            xs);
        :}
      | type_specifier:x
        {: RESULT = JavaUtils.seq(new Located(x.loc(), left(x.value()))); :}
      | type_qualifier:x specifier_qualifier_list:xs
        {:
          RESULT = JavaUtils.prepend(
            new Located(x.loc(), right(x.value())),
            xs);
        :}
      | type_qualifier:x
        {: RESULT = JavaUtils.seq(new Located(x.loc(), right(x.value()))); :}
      ;

struct_declarator_list // Seq[(Option[L[Declarator]], Option[L[Expr]])]
    ::= struct_declarator_list:xs COMMA struct_declarator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                                 struct_declarator:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

struct_declarator // (Option[Located[Declarator]], Option[Located[Expr]])
    ::= declarator:x
        {: RESULT = pair(some(x), none()); :}
      | declarator:x COLON constant_expression:e
        {: RESULT = pair(some(x), some(e)); :}
      |              COLON constant_expression:e
        {: RESULT = pair(none(), some(e)); :}
      ;

enum_specifier // Located[TypeSpecifier]
    ::= ENUM:loc1 ID:id LBRACE enumerator_list:body RBRACE:loc2
        {:
          RESULT = new Located(
            LocRange.of(loc1, loc2),
            new EnumSpecifier(some(id), some(body)));
        :}
      | ENUM:loc1       LBRACE enumerator_list:body RBRACE:loc2
        {:
          RESULT = new Located(
            LocRange.of(loc1, loc2),
            new EnumSpecifier(none(), some(body)));
        :}
      | ENUM:loc  ID:id
        {:
          RESULT = new Located(
            LocRange.of(loc, id.loc()),
            new EnumSpecifier(some(id), none()));
        :}
      ;

enumerator_list // Seq[(Located[TokId], Option[Located[Expr]])]
    ::=                          enumerator:x
        {: RESULT = JavaUtils.seq(x); :}
      | enumerator_list:xs COMMA enumerator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

enumerator // (Located[TokId], Option[Located[Expr]])
    ::= ID:id
        {: RESULT = pair(id, none()); :}
      | ID:id ASSIGN constant_expression:e
        {: RESULT = pair(id, some(e)); :}
      ;

type_qualifier // Located<TypeQualifier>
    ::= CONST:loc    {: RESULT = new Located(loc,    c4.ast.Const$.MODULE$); :}
      | VOLATILE:loc {: RESULT = new Located(loc, c4.ast.Volatile$.MODULE$); :}
      ;

initializer // Located<Initializer>
    ::= assignment_expression:e
        {: RESULT = Located.of(e.loc(), new InitializerExpr(e)); :}
      | LBRACE:l1 initializer_list:il       RBRACE:l2
        {: RESULT = Located.of(l1, l2, new InitializerStruct(il)); :}
      | LBRACE:l1 initializer_list:il COMMA RBRACE:l2
        {: RESULT = Located.of(l1, l2, new InitializerStruct(il)); :}
      ;

initializer_list // Seq<Located<Initializer>>
    ::=                           initializer:x
        {: RESULT = JavaUtils.seq(x); :}
      | initializer_list:xs COMMA initializer:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

type_name // Located<TypeName>
    ::= specifier_qualifier_list:sqs abstract_declarator:ad
        {: RESULT = Located.of(head(sqs).loc(), ad.loc(),
            new TypeName(sqs, some(ad))); :}
      | specifier_qualifier_list:sqs
        {: RESULT = Located.of(head(sqs).loc(),
            new TypeName(sqs, none())); :}
      ;

abstract_declarator // Located<AbstractDeclarator>
    ::= pointer:ptr
        {: RESULT = Located.of(ptr.loc(),
            new AbstractDeclarator(some(ptr), none())); :}
      | pointer:ptr direct_abstract_declarator:dad
        {: RESULT = Located.of(ptr.loc(), dad.loc(),
            new AbstractDeclarator(some(ptr), some(dad))); :}
      |             direct_abstract_declarator:dad
        {: RESULT = Located.of(dad.loc(),
            new AbstractDeclarator(none(), some(dad))); :}
      ;

direct_abstract_declarator // Located<DirectAbstractDeclarator>
    ::= LPAREN:b abstract_declarator:ad RPAREN:e
        {: RESULT = Located.of(b, e, new DirectAbstractDeclaratorSimple(ad)); :}
      | direct_abstract_declarator:dad LSBRKT   constant_expression:e RSBRKT:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorArray(some(dad), some(e))); :}
      | direct_abstract_declarator:dad LSBRKT                         RSBRKT:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorArray(some(dad), none())); :}
      |                                LSBRKT:b constant_expression:e RSBRKT:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorArray(none(), some(e))); :}
      |                                LSBRKT:b                       RSBRKT:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorArray(none(), none())); :}
      | direct_abstract_declarator:dad LPAREN   parameter_type_list:p RPAREN:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorFunc(some(dad), some(p))); :}
      | direct_abstract_declarator:dad LPAREN                         RPAREN:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorFunc(some(dad), none())); :}
      |                                LPAREN:b parameter_type_list:p RPAREN:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorFunc(none(), some(p))); :}
      |                                LPAREN:b                       RPAREN:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorFunc(none(), none())); :}
      ;

statement // Located<Stmt>
    ::= labeled_statement:x {: RESULT = x; :}
      | {: getC4Scanner().enterScope(); :}
        compound_statement:x
        {: getC4Scanner().exitScope();
           RESULT = Located.of(x.loc(), x.value()); :}
      | expression_statement:x
        {: RESULT = Located.of(x.loc(), x.value()); :}
      | selection_statement:x {: RESULT = x; :}
      | iteration_statement:x {: RESULT = x; :}
      | jump_statement:x {: RESULT = x; :}
      ;

labeled_statement // Located<Stmt>
    ::= ID:id COLON statement:s
        {: RESULT = Located.of(id.loc(), s.loc(), new LabeledStmtId(id, s)); :}
      | CASE:b constant_expression:e COLON statement:s
        {: RESULT = Located.of(b, s.loc(), new LabeledStmtCase(e, s)); :}
      | DEFAULT:b COLON statement:s
        {: RESULT = Located.of(b, s.loc(), new LabeledStmtDefault(s)); :}
      ;

expression_statement // Located<Stmt>
    ::= expression:e SEMICOLON:end
        {: RESULT = Located.of(e.loc(), end, new ExprStmt(some(e))); :}
      |              SEMICOLON:end
        {: RESULT = Located.of(end, new ExprStmt(none())); :}
      ;

selection_statement // Located<Stmt>
    ::= IF:b LPAREN expression:e RPAREN statement:s1
        {: RESULT = Located.of(b, s1.loc(), new IfStmt(e, s1, none())); :}
      | IF:b LPAREN expression:e RPAREN statement:s1 ELSE statement:s2
        {: RESULT = Located.of(b, s2.loc(), new IfStmt(e, s1, some(s2))); :}
      | SWITCH:b LPAREN expression:e RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(), new SwitchStmt(e, s)); :}
      ;

iteration_statement // Located<Stmt>
    ::= WHILE:b LPAREN expression:e RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(), new WhileStmt(e, s)); :}
      | DO:b statement:s WHILE LPAREN expression:expr RPAREN SEMICOLON:end
        {: RESULT = Located.of(b, end, new DoWhileStmt(s, expr)); :}
      | FOR:b LPAREN expression_statement:e1
                     expression_statement:e2
                     expression:e3 RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(),
            new ForStmt(e1.value().e(), e2.value().e(), some(e3), s)); :}
      | FOR:b LPAREN expression_statement:e1
                     expression_statement:e2 RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(),
            new ForStmt(e1.value().e(), e2.value().e(), none(), s)); :}
      ;

jump_statement // Located<Stmt>
    ::= GOTO:b ID:id SEMICOLON:e
        {: RESULT = Located.of(b, e, new GotoStmt(id)); :}
      | CONTINUE:b SEMICOLON:e
        {: RESULT = Located.of(b, e, c4.ast.Continue$.MODULE$); :}
      | BREAK:b SEMICOLON:e
        {: RESULT = Located.of(b, e, c4.ast.Break$.MODULE$); :}
      | RETURN:b expression:expr SEMICOLON:e
        {: RESULT = Located.of(b, e, new Return(some(expr))); :}
      | RETURN:b SEMICOLON:e
        {: RESULT = Located.of(b, e, new Return(none())); :}
      ;

expression // Located<Expr>
    ::=                       assignment_expression:e2 {: RESULT = e2; :}
      | expression:e1 COMMA:c assignment_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2, Located.of(c, c4.ast.Comma$.MODULE$))); :}
      ;

constant_expression // Located<Expr>
    ::= conditional_expression:e {: RESULT = e; :}
      ;

assignment_expression // Located<Expr>
    ::= conditional_expression:e {: RESULT = e; :}
      | unary_expression:e1 assignment_operator:op assignment_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2, op)); :}
      ;

conditional_expression // Located<Expr>
    ::= logical_or_expression:e {: RESULT = e; :}
      | logical_or_expression:e1 QMARK expression:e2
                                 COLON conditional_expression:e3
        {: RESULT = Located.of(e1.loc(), e3.loc(),
            new TernaryExpr(e1, e2, e3)); :}
      ;

logical_or_expression // Located<Expr>
    ::=                                  logical_and_expression:e
        {: RESULT = e; :}
      | logical_or_expression:e1 L_OR:op logical_and_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.LogicOr$.MODULE$))); :}
      ;

logical_and_expression // Located<Expr>
    ::=                                    inclusive_or_expression:e
        {: RESULT = e; :}
      | logical_and_expression:e1 L_AND:op inclusive_or_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.LogicAnd$.MODULE$))); :}
      ;

inclusive_or_expression // Located<Expr>
    ::=                                    exclusive_or_expression:e
        {: RESULT = e; :}
      | inclusive_or_expression:e1 B_OR:op exclusive_or_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.BitOr$.MODULE$))); :}
      ;

exclusive_or_expression // Located<Expr>
    ::=                                   and_expression:e
        {: RESULT = e; :}
      | exclusive_or_expression:e1 XOR:op and_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Xor$.MODULE$))); :}
      ;

and_expression // Located<Expr>
    ::=                            equality_expression:e
        {: RESULT = e; :}
      | and_expression:e1 B_AND:op equality_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.BitAnd$.MODULE$))); :}
      ;

equality_expression // Located<Expr>
    ::=                               relational_expression:e
        {: RESULT = e; :}
      | equality_expression:e1 EQ:op  relational_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Eq$.MODULE$))); :}
      | equality_expression:e1 NEQ:op relational_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Neq$.MODULE$))); :}
      ;

relational_expression // Located<Expr>
    ::=                                 shift_expression:e
        {: RESULT = e; :}
      | relational_expression:e1 LE:op  shift_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Less$.MODULE$))); :}
      | relational_expression:e1 GT:op  shift_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Gt$.MODULE$))); :}
      | relational_expression:e1 LEQ:op shift_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Leq$.MODULE$))); :}
      | relational_expression:e1 GEQ:op shift_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Geq$.MODULE$))); :}
      ;

shift_expression // Located<Expr>
    ::=                               additive_expression:e
        {: RESULT = e; :}
      | shift_expression:e1 LSHIFT:op additive_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.LShift$.MODULE$))); :}
      | shift_expression:e1 RSHIFT:op additive_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.RShift$.MODULE$))); :}
      ;

additive_expression // Located<Expr>
    ::=                               multiplicative_expression:e
        {: RESULT = e; :}
      | additive_expression:e1 ADD:op multiplicative_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Add$.MODULE$))); :}
      | additive_expression:e1 SUB:op multiplicative_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Sub$.MODULE$))); :}
      ;

multiplicative_expression // Located<Expr>
    ::=                                      cast_expression:e
        {: RESULT = e; :}
      | multiplicative_expression:e1 STAR:op cast_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Mul$.MODULE$))); :}
      | multiplicative_expression:e1 DIV:op  cast_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Div$.MODULE$))); :}
      | multiplicative_expression:e1 MOD:op  cast_expression:e2
        {: RESULT = Located.of(e1.loc(), e2.loc(),
            new BinaryExpr(e1, e2,
                Located.of(op, c4.ast.Mod$.MODULE$))); :}
      ;

assignment_operator // Located<BinaryOp>
    ::= ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.Assign$.MODULE$); :}
      | MUL_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.MulAssign$.MODULE$); :}
      | DIV_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.DivAssign$.MODULE$); :}
      | MOD_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.ModAssign$.MODULE$); :}
      | ADD_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.AddAssign$.MODULE$); :}
      | SUB_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.SubAssign$.MODULE$); :}
      | LSHIFT_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.LShiftAssign$.MODULE$); :}
      | RSHIFT_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.RShiftAssign$.MODULE$); :}
      | B_AND_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.BinaryAndAssign$.MODULE$); :}
      | XOR_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.XorAssign$.MODULE$); :}
      | B_OR_ASSIGN:x
        {: RESULT = Located.of(x, c4.ast.BinaryOrAssign$.MODULE$); :}
      ;

unary_expression // Located<Expr>
    ::= postfix_expression:e {: RESULT = e; :}
      | INC:op unary_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.PrefixInc$.MODULE$))); :}
      | DEC:op unary_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.PrefixDec$.MODULE$))); :}
      | B_AND:op cast_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.Ref$.MODULE$))); :}
      | STAR:op  cast_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.Deref$.MODULE$))); :}
      | ADD:op   cast_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.Pos$.MODULE$))); :}
      | SUB:op   cast_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.Neg$.MODULE$))); :}
      | TILDE:op cast_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.BitNot$.MODULE$))); :}
      | L_NOT:op cast_expression:e
        {: RESULT = Located.of(op, e.loc(),
            new UnaryExpr(e, Located.of(op, c4.ast.LogicNot$.MODULE$))); :}
      | SIZEOF:op unary_expression:e
        {: RESULT = Located.of(op, e.loc(), new SizeofValExpr(e)); :}
      | SIZEOF:b LPAREN type_name:tp RPAREN:e
        {: RESULT = Located.of(b, e, new SizeofTypeExpr(tp)); :}
      | BUILTIN_OFFSETOF:b LPAREN type_name:tp COMMA ID:id RPAREN:e
        {: RESULT = Located.of(b, e, new BuiltinOffsetofExpr(tp, id)); :}
      ;

postfix_expression // Located<Expr>
    ::= primary_expression:e {: RESULT = e; :}
      | postfix_expression:e LSBRKT expression:sub RSBRKT:end
        {: RESULT = Located.of(e.loc(), end, new ArrSubExpr(e, sub)); :}
      | postfix_expression:e LPAREN argument_expression_list:args RPAREN:end
        {: RESULT = Located.of(e.loc(), end, new FunCallExpr(e, args)); :}
      | postfix_expression:e LPAREN                               RPAREN:end
        {: RESULT = Located.of(e.loc(), end, new FunCallExpr(e, seq())); :}
      | postfix_expression:e DOT ID:id
        {: RESULT = Located.of(e.loc(), id.loc(), new DotExpr(e, id)); :}
      | postfix_expression:e PTR ID:id
        {: RESULT = Located.of(e.loc(), id.loc(), new PtrExpr(e, id)); :}
      | postfix_expression:e INC:op
        {: RESULT = Located.of(e.loc(), op,
            new UnaryExpr(e, Located.of(op, c4.ast.PostfixInc$.MODULE$))); :}
      | postfix_expression:e DEC:op
        {: RESULT = Located.of(e.loc(), op,
            new UnaryExpr(e, Located.of(op, c4.ast.PostfixDec$.MODULE$))); :}
      ;

argument_expression_list // Seq[L[Expr]]
    ::=                                   assignment_expression:x
        {: RESULT = JavaUtils.seq(x); :}
      | argument_expression_list:xs COMMA assignment_expression:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

cast_expression // Located<Expr>
    ::= unary_expression:e {: RESULT = e; :}
      | LPAREN:b type_name:tn RPAREN cast_expression:e
        {: RESULT = Located.of(b, e.loc(), new CastExpr(tn, e)); :}
      ;

primary_expression // Located<Expr>
    ::= ID:id
        {: RESULT = new Located(id.loc(), new Id(id.value().id())); :}
      | INTEGER_LIT:x
        {: RESULT = new Located(x.loc(), new IntegerLit(x.value())); :}
      | FLOAT_LIT:x
        {: RESULT = new Located(x.loc(), new FloatLit(x.value())); :}
      | DOUBLE_LIT:x
        {: RESULT = new Located(x.loc(), new DoubleLit(x.value())); :}
      | LONG_DOUBLE_LIT:x
        {: RESULT = new Located(x.loc(), new LongDoubleLit(x.value())); :}
      | CHAR_LIT:x
        {: RESULT = new Located(x.loc(), new CharLit(x.value())); :}
      | WIDE_CHAR_LIT:x
        {: RESULT = new Located(x.loc(), new WideCharLit(x.value())); :}
      | STR_LIT:x
        {: RESULT = new Located(x.loc(), new StrLit(x.value())); :}
      | WIDE_STR_LIT:x
        {: RESULT = new Located(x.loc(), new WideStrLit(x.value())); :}
      | LPAREN expression:e RPAREN {: RESULT = e; :}
      ;
