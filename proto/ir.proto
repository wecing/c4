syntax = "proto3";

package c4.ir.proto;

message IrModule {
    map<uint32, StructDef> struct_defs = 1;
    map<string, GlobalDef> global_defs = 2;
    map<string, FunctionDef> function_defs = 3;
}

message StructDef {
    // when empty: unfinished opaque type
    repeated Type type = 1;
    repeated bool padding_only = 2;
}

message GlobalDef {
    Linkage linkage = 1;
    Type type = 2;
    Value value = 3; // optional
}

message FunctionDef {
    Linkage linkage = 1;
    Type return_type = 2;
    repeated Type arg_types = 3;
    repeated uint32 args = 4;
    uint32 entry_bb = 5; // ids and bbs use different namespace
    map<uint32, BasicBlock> bbs = 6;
}

enum Linkage {
    NONE = 0;
    EXTERNAL = 1;
    INTERNAL = 2;
}

message Type {
    enum Kind {
        VOID = 0;

        INT8 = 1;
        INT16 = 2;
        INT32 = 3;
        INT64 = 4;

        FLOAT = 5;
        DOUBLE = 6;

        STRUCT = 7;
        POINTER = 8;
        ARRAY = 9;

        FUNCTION = 10; // usually used with POINTER

        BOOLEAN = 11;
    }

    Kind kind = 1;

    // STRUCT
    uint32 struct_id = 2;

    // POINTER
    Type pointee_type = 3;

    // ARRAY
    Type array_elem_type = 4;
    uint32 array_size = 5;

    // FUNCTION
    Type fn_return_type = 6;
    repeated Type fn_arg_types = 7;
    bool fn_is_vararg = 8;
}

message Value {
    message Aggregate {
        repeated Value values = 1;
        uint32 zero_padding_bytes = 2;
    }
    message Address {
        string symbol = 1;
        int64 offset = 2;
    }

    oneof v {
        int32 i8 = 1;
        int32 i16 = 2;
        int32 i32 = 3;
        int64 i64 = 4;

        float f32 = 5;
        double f64 = 6;

        Aggregate aggregate = 7;
        Address address = 8;
        Value cast_from = 9;

        uint32 ir_id = 10; // instruction or arg
    }

    Type type = 11;
}

message BasicBlock {
    message Instruction {
        uint32 id = 1;
        Type type = 2;

        enum Kind {
            ALLOCA = 0;
            STORE = 1;
            LOAD = 2;
            MEMCPY = 3;
            CAST = 4;
            NEG = 5;
            NOT = 6;

            // binary ops
            BIT_OR = 7;
            XOR = 8;
            BIT_AND = 9;
            SHL = 10;
            ASHR = 11; // arithmetic shift right (preserves sign)
            LSHR = 12; // logical shift right (zero fill)
            ADD = 13;
            SUB = 14;
            MUL = 15;
            DIV = 16;
            UDIV = 17; // unsigned div
            MOD = 18;
            UMOD = 19; // unsigned mod
            EQ = 20;
            NEQ = 21;
            LT = 22;
            GT = 23;
            LEQ = 24;
            GEQ = 25;
            ULT = 26; // unsigned LT
            UGT = 27; // unsigned GT
            ULEQ = 28; // unsigned LEQ
            UGEQ = 29; // unsigned GEQ

            FN_CALL = 30;

            VA_START = 31;
            VA_ARG = 32;
            VA_END = 33;
            VA_COPY = 34;
        }

        Kind kind = 3;

        // STORE
        Value store_dst = 4;
        Value store_src = 5;

        // LOAD
        Value load_src = 6;

        // MEMCPY
        Value memcpy_dst = 7;
        Value memcpy_src = 8;
        uint32 memcpy_size = 9;

        // CAST -- just a value with ID
        Value cast_result = 10;

        // NEG
        Value neg_src = 11;

        // NOT
        Value not_src = 12;

        // binary ops
        Value bin_op_left = 13;
        Value bin_op_right = 14;

        // FUN CALL
        Value fn_call_fn = 15;
        repeated Value fn_call_args = 16;

        // VA_START
        Value va_start_vl = 17;

        // VA_ARG
        Value va_arg_vl = 18; // type is instr return type

        // VA_END
        Value va_end_vl = 19;

        // VA_COPY
        Value va_copy_dst = 20;
        Value va_copy_src = 21;

    }
    message Terminator {
        enum Kind {
            BR = 0;
            COND_BR = 1;
            RETURN_VOID = 2;
            RETURN = 3;
            SWITCH = 4;
        }

        Kind kind = 1;

        // BR
        uint32 br_target = 2;

        // COND_BR
        Value cond_br_cond = 3;
        uint32 cond_br_true = 4;
        uint32 cond_br_false = 5;

        // RETURN
        Value return_value = 6;
    }
    repeated Instruction instructions = 1;
    Terminator terminator = 2;
}