// This file is generated by rust-protobuf 2.10.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ast.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_1;

#[derive(PartialEq,Clone,Default)]
pub struct TranslationUnit {
    // message fields
    pub eds: ::protobuf::RepeatedField<ExternalDecl>,
    pub ed_locs: ::protobuf::RepeatedField<Loc>,
    pub exprs: ::protobuf::RepeatedField<Expr>,
    pub direct_declarators: ::protobuf::RepeatedField<DirectDeclarator>,
    pub direct_abstract_declarators: ::protobuf::RepeatedField<DirectAbstractDeclarator>,
    pub pointers: ::protobuf::RepeatedField<Pointer>,
    pub initializers: ::protobuf::RepeatedField<Initializer>,
    pub statements: ::protobuf::RepeatedField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TranslationUnit {
    fn default() -> &'a TranslationUnit {
        <TranslationUnit as ::protobuf::Message>::default_instance()
    }
}

impl TranslationUnit {
    pub fn new() -> TranslationUnit {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.ExternalDecl eds = 1;


    pub fn get_eds(&self) -> &[ExternalDecl] {
        &self.eds
    }
    pub fn clear_eds(&mut self) {
        self.eds.clear();
    }

    // Param is passed by value, moved
    pub fn set_eds(&mut self, v: ::protobuf::RepeatedField<ExternalDecl>) {
        self.eds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_eds(&mut self) -> &mut ::protobuf::RepeatedField<ExternalDecl> {
        &mut self.eds
    }

    // Take field
    pub fn take_eds(&mut self) -> ::protobuf::RepeatedField<ExternalDecl> {
        ::std::mem::replace(&mut self.eds, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc ed_locs = 2;


    pub fn get_ed_locs(&self) -> &[Loc] {
        &self.ed_locs
    }
    pub fn clear_ed_locs(&mut self) {
        self.ed_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ed_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.ed_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ed_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.ed_locs
    }

    // Take field
    pub fn take_ed_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.ed_locs, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Expr exprs = 3;


    pub fn get_exprs(&self) -> &[Expr] {
        &self.exprs
    }
    pub fn clear_exprs(&mut self) {
        self.exprs.clear();
    }

    // Param is passed by value, moved
    pub fn set_exprs(&mut self, v: ::protobuf::RepeatedField<Expr>) {
        self.exprs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exprs(&mut self) -> &mut ::protobuf::RepeatedField<Expr> {
        &mut self.exprs
    }

    // Take field
    pub fn take_exprs(&mut self) -> ::protobuf::RepeatedField<Expr> {
        ::std::mem::replace(&mut self.exprs, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.DirectDeclarator direct_declarators = 4;


    pub fn get_direct_declarators(&self) -> &[DirectDeclarator] {
        &self.direct_declarators
    }
    pub fn clear_direct_declarators(&mut self) {
        self.direct_declarators.clear();
    }

    // Param is passed by value, moved
    pub fn set_direct_declarators(&mut self, v: ::protobuf::RepeatedField<DirectDeclarator>) {
        self.direct_declarators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_direct_declarators(&mut self) -> &mut ::protobuf::RepeatedField<DirectDeclarator> {
        &mut self.direct_declarators
    }

    // Take field
    pub fn take_direct_declarators(&mut self) -> ::protobuf::RepeatedField<DirectDeclarator> {
        ::std::mem::replace(&mut self.direct_declarators, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.DirectAbstractDeclarator direct_abstract_declarators = 5;


    pub fn get_direct_abstract_declarators(&self) -> &[DirectAbstractDeclarator] {
        &self.direct_abstract_declarators
    }
    pub fn clear_direct_abstract_declarators(&mut self) {
        self.direct_abstract_declarators.clear();
    }

    // Param is passed by value, moved
    pub fn set_direct_abstract_declarators(&mut self, v: ::protobuf::RepeatedField<DirectAbstractDeclarator>) {
        self.direct_abstract_declarators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_direct_abstract_declarators(&mut self) -> &mut ::protobuf::RepeatedField<DirectAbstractDeclarator> {
        &mut self.direct_abstract_declarators
    }

    // Take field
    pub fn take_direct_abstract_declarators(&mut self) -> ::protobuf::RepeatedField<DirectAbstractDeclarator> {
        ::std::mem::replace(&mut self.direct_abstract_declarators, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Pointer pointers = 6;


    pub fn get_pointers(&self) -> &[Pointer] {
        &self.pointers
    }
    pub fn clear_pointers(&mut self) {
        self.pointers.clear();
    }

    // Param is passed by value, moved
    pub fn set_pointers(&mut self, v: ::protobuf::RepeatedField<Pointer>) {
        self.pointers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pointers(&mut self) -> &mut ::protobuf::RepeatedField<Pointer> {
        &mut self.pointers
    }

    // Take field
    pub fn take_pointers(&mut self) -> ::protobuf::RepeatedField<Pointer> {
        ::std::mem::replace(&mut self.pointers, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Initializer initializers = 7;


    pub fn get_initializers(&self) -> &[Initializer] {
        &self.initializers
    }
    pub fn clear_initializers(&mut self) {
        self.initializers.clear();
    }

    // Param is passed by value, moved
    pub fn set_initializers(&mut self, v: ::protobuf::RepeatedField<Initializer>) {
        self.initializers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initializers(&mut self) -> &mut ::protobuf::RepeatedField<Initializer> {
        &mut self.initializers
    }

    // Take field
    pub fn take_initializers(&mut self) -> ::protobuf::RepeatedField<Initializer> {
        ::std::mem::replace(&mut self.initializers, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Statement statements = 8;


    pub fn get_statements(&self) -> &[Statement] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<Statement>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<Statement> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<Statement> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TranslationUnit {
    fn is_initialized(&self) -> bool {
        for v in &self.eds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ed_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exprs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.direct_declarators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.direct_abstract_declarators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pointers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initializers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.eds)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ed_locs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exprs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.direct_declarators)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.direct_abstract_declarators)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pointers)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initializers)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.eds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ed_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.exprs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.direct_declarators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.direct_abstract_declarators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pointers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.initializers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.statements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.eds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ed_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.exprs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.direct_declarators {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.direct_abstract_declarators {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pointers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.initializers {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.statements {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TranslationUnit {
        TranslationUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalDecl>>(
                    "eds",
                    |m: &TranslationUnit| { &m.eds },
                    |m: &mut TranslationUnit| { &mut m.eds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ed_locs",
                    |m: &TranslationUnit| { &m.ed_locs },
                    |m: &mut TranslationUnit| { &mut m.ed_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "exprs",
                    |m: &TranslationUnit| { &m.exprs },
                    |m: &mut TranslationUnit| { &mut m.exprs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirectDeclarator>>(
                    "direct_declarators",
                    |m: &TranslationUnit| { &m.direct_declarators },
                    |m: &mut TranslationUnit| { &mut m.direct_declarators },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirectAbstractDeclarator>>(
                    "direct_abstract_declarators",
                    |m: &TranslationUnit| { &m.direct_abstract_declarators },
                    |m: &mut TranslationUnit| { &mut m.direct_abstract_declarators },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pointer>>(
                    "pointers",
                    |m: &TranslationUnit| { &m.pointers },
                    |m: &mut TranslationUnit| { &mut m.pointers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Initializer>>(
                    "initializers",
                    |m: &TranslationUnit| { &m.initializers },
                    |m: &mut TranslationUnit| { &mut m.initializers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statements",
                    |m: &TranslationUnit| { &m.statements },
                    |m: &mut TranslationUnit| { &mut m.statements },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TranslationUnit>(
                    "TranslationUnit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TranslationUnit {
        static mut instance: ::protobuf::lazy::Lazy<TranslationUnit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TranslationUnit,
        };
        unsafe {
            instance.get(TranslationUnit::new)
        }
    }
}

impl ::protobuf::Clear for TranslationUnit {
    fn clear(&mut self) {
        self.eds.clear();
        self.ed_locs.clear();
        self.exprs.clear();
        self.direct_declarators.clear();
        self.direct_abstract_declarators.clear();
        self.pointers.clear();
        self.initializers.clear();
        self.statements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TranslationUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslationUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExternalDecl {
    // message fields
    pub loc: ::protobuf::SingularPtrField<Loc>,
    // message oneof groups
    pub ed: ::std::option::Option<ExternalDecl_oneof_ed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalDecl {
    fn default() -> &'a ExternalDecl {
        <ExternalDecl as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExternalDecl_oneof_ed {
    fd(FunctionDef),
    dl(Declaration),
}

impl ExternalDecl {
    pub fn new() -> ExternalDecl {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.FunctionDef fd = 1;


    pub fn get_fd(&self) -> &FunctionDef {
        match self.ed {
            ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(ref v)) => v,
            _ => FunctionDef::default_instance(),
        }
    }
    pub fn clear_fd(&mut self) {
        self.ed = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        match self.ed {
            ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: FunctionDef) {
        self.ed = ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fd(&mut self) -> &mut FunctionDef {
        if let ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(_)) = self.ed {
        } else {
            self.ed = ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(FunctionDef::new()));
        }
        match self.ed {
            ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fd(&mut self) -> FunctionDef {
        if self.has_fd() {
            match self.ed.take() {
                ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(v)) => v,
                _ => panic!(),
            }
        } else {
            FunctionDef::new()
        }
    }

    // .c4.ast.proto.Declaration dl = 2;


    pub fn get_dl(&self) -> &Declaration {
        match self.ed {
            ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(ref v)) => v,
            _ => Declaration::default_instance(),
        }
    }
    pub fn clear_dl(&mut self) {
        self.ed = ::std::option::Option::None;
    }

    pub fn has_dl(&self) -> bool {
        match self.ed {
            ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dl(&mut self, v: Declaration) {
        self.ed = ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dl(&mut self) -> &mut Declaration {
        if let ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(_)) = self.ed {
        } else {
            self.ed = ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(Declaration::new()));
        }
        match self.ed {
            ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dl(&mut self) -> Declaration {
        if self.has_dl() {
            match self.ed.take() {
                ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(v)) => v,
                _ => panic!(),
            }
        } else {
            Declaration::new()
        }
    }

    // .c4.ast.proto.Loc loc = 3;


    pub fn get_loc(&self) -> &Loc {
        self.loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_loc(&mut self) {
        self.loc.clear();
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: Loc) {
        self.loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut Loc {
        if self.loc.is_none() {
            self.loc.set_default();
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> Loc {
        self.loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for ExternalDecl {
    fn is_initialized(&self) -> bool {
        if let Some(ExternalDecl_oneof_ed::fd(ref v)) = self.ed {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExternalDecl_oneof_ed::dl(ref v)) = self.ed {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ed = ::std::option::Option::Some(ExternalDecl_oneof_ed::fd(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ed = ::std::option::Option::Some(ExternalDecl_oneof_ed::dl(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.ed {
            match v {
                &ExternalDecl_oneof_ed::fd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExternalDecl_oneof_ed::dl(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.ed {
            match v {
                &ExternalDecl_oneof_ed::fd(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExternalDecl_oneof_ed::dl(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalDecl {
        ExternalDecl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FunctionDef>(
                    "fd",
                    ExternalDecl::has_fd,
                    ExternalDecl::get_fd,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Declaration>(
                    "dl",
                    ExternalDecl::has_dl,
                    ExternalDecl::get_dl,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "loc",
                    |m: &ExternalDecl| { &m.loc },
                    |m: &mut ExternalDecl| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExternalDecl>(
                    "ExternalDecl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExternalDecl {
        static mut instance: ::protobuf::lazy::Lazy<ExternalDecl> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExternalDecl,
        };
        unsafe {
            instance.get(ExternalDecl::new)
        }
    }
}

impl ::protobuf::Clear for ExternalDecl {
    fn clear(&mut self) {
        self.ed = ::std::option::Option::None;
        self.ed = ::std::option::Option::None;
        self.loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalDecl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalDecl {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr {
    // message oneof groups
    pub e: ::std::option::Option<Expr_oneof_e>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr {
    fn default() -> &'a Expr {
        <Expr as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Expr_oneof_e {
    id(::std::string::String),
    integer(Expr_Integer),
    float(f32),
    double(f64),
    char(u32),
    wide_char(u32),
    string(::std::string::String),
    wide_string(::std::string::String),
    cast(Expr_Cast),
    arr_sub(Expr_ArrSub),
    func_call(Expr_FuncCall),
    dot(Expr_Dot),
    ptr(Expr_Ptr),
    sizeof_val(Expr_SizeofVal),
    sizeof_tp(Expr_SizeofType),
    unary(Expr_Unary),
    binary(Expr_Binary),
    ternary(Expr_Ternary),
}

impl Expr {
    pub fn new() -> Expr {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expr_oneof_e::id(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::id(::std::string::String::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        if self.has_id() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .c4.ast.proto.Expr.Integer integer = 2;


    pub fn get_integer(&self) -> &Expr_Integer {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::integer(ref v)) => v,
            _ => Expr_Integer::default_instance(),
        }
    }
    pub fn clear_integer(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_integer(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::integer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_integer(&mut self, v: Expr_Integer) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::integer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_integer(&mut self) -> &mut Expr_Integer {
        if let ::std::option::Option::Some(Expr_oneof_e::integer(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::integer(Expr_Integer::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::integer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_integer(&mut self) -> Expr_Integer {
        if self.has_integer() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::integer(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Integer::new()
        }
    }

    // float float = 3;


    pub fn get_float(&self) -> f32 {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::float(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::float(v))
    }

    // double double = 4;


    pub fn get_double(&self) -> f64 {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::double(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::double(v))
    }

    // uint32 char = 6;


    pub fn get_char(&self) -> u32 {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::char(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_char(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_char(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::char(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_char(&mut self, v: u32) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::char(v))
    }

    // uint32 wide_char = 7;


    pub fn get_wide_char(&self) -> u32 {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::wide_char(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_wide_char(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_wide_char(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::wide_char(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wide_char(&mut self, v: u32) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::wide_char(v))
    }

    // string string = 8;


    pub fn get_string(&self) -> &str {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expr_oneof_e::string(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::string(::std::string::String::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string wide_string = 9;


    pub fn get_wide_string(&self) -> &str {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::wide_string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_wide_string(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_wide_string(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::wide_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wide_string(&mut self, v: ::std::string::String) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::wide_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_wide_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expr_oneof_e::wide_string(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::wide_string(::std::string::String::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::wide_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_wide_string(&mut self) -> ::std::string::String {
        if self.has_wide_string() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::wide_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .c4.ast.proto.Expr.Cast cast = 10;


    pub fn get_cast(&self) -> &Expr_Cast {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::cast(ref v)) => v,
            _ => Expr_Cast::default_instance(),
        }
    }
    pub fn clear_cast(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_cast(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::cast(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cast(&mut self, v: Expr_Cast) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::cast(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cast(&mut self) -> &mut Expr_Cast {
        if let ::std::option::Option::Some(Expr_oneof_e::cast(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::cast(Expr_Cast::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::cast(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cast(&mut self) -> Expr_Cast {
        if self.has_cast() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::cast(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Cast::new()
        }
    }

    // .c4.ast.proto.Expr.ArrSub arr_sub = 11;


    pub fn get_arr_sub(&self) -> &Expr_ArrSub {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::arr_sub(ref v)) => v,
            _ => Expr_ArrSub::default_instance(),
        }
    }
    pub fn clear_arr_sub(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_arr_sub(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::arr_sub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arr_sub(&mut self, v: Expr_ArrSub) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::arr_sub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arr_sub(&mut self) -> &mut Expr_ArrSub {
        if let ::std::option::Option::Some(Expr_oneof_e::arr_sub(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::arr_sub(Expr_ArrSub::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::arr_sub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arr_sub(&mut self) -> Expr_ArrSub {
        if self.has_arr_sub() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::arr_sub(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_ArrSub::new()
        }
    }

    // .c4.ast.proto.Expr.FuncCall func_call = 12;


    pub fn get_func_call(&self) -> &Expr_FuncCall {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::func_call(ref v)) => v,
            _ => Expr_FuncCall::default_instance(),
        }
    }
    pub fn clear_func_call(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_func_call(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::func_call(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func_call(&mut self, v: Expr_FuncCall) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::func_call(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func_call(&mut self) -> &mut Expr_FuncCall {
        if let ::std::option::Option::Some(Expr_oneof_e::func_call(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::func_call(Expr_FuncCall::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::func_call(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func_call(&mut self) -> Expr_FuncCall {
        if self.has_func_call() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::func_call(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_FuncCall::new()
        }
    }

    // .c4.ast.proto.Expr.Dot dot = 13;


    pub fn get_dot(&self) -> &Expr_Dot {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::dot(ref v)) => v,
            _ => Expr_Dot::default_instance(),
        }
    }
    pub fn clear_dot(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_dot(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::dot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dot(&mut self, v: Expr_Dot) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::dot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dot(&mut self) -> &mut Expr_Dot {
        if let ::std::option::Option::Some(Expr_oneof_e::dot(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::dot(Expr_Dot::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::dot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dot(&mut self) -> Expr_Dot {
        if self.has_dot() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::dot(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Dot::new()
        }
    }

    // .c4.ast.proto.Expr.Ptr ptr = 14;


    pub fn get_ptr(&self) -> &Expr_Ptr {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::ptr(ref v)) => v,
            _ => Expr_Ptr::default_instance(),
        }
    }
    pub fn clear_ptr(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_ptr(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::ptr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ptr(&mut self, v: Expr_Ptr) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::ptr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ptr(&mut self) -> &mut Expr_Ptr {
        if let ::std::option::Option::Some(Expr_oneof_e::ptr(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::ptr(Expr_Ptr::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::ptr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ptr(&mut self) -> Expr_Ptr {
        if self.has_ptr() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::ptr(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Ptr::new()
        }
    }

    // .c4.ast.proto.Expr.SizeofVal sizeof_val = 15;


    pub fn get_sizeof_val(&self) -> &Expr_SizeofVal {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::sizeof_val(ref v)) => v,
            _ => Expr_SizeofVal::default_instance(),
        }
    }
    pub fn clear_sizeof_val(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_sizeof_val(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::sizeof_val(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sizeof_val(&mut self, v: Expr_SizeofVal) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::sizeof_val(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sizeof_val(&mut self) -> &mut Expr_SizeofVal {
        if let ::std::option::Option::Some(Expr_oneof_e::sizeof_val(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::sizeof_val(Expr_SizeofVal::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::sizeof_val(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sizeof_val(&mut self) -> Expr_SizeofVal {
        if self.has_sizeof_val() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::sizeof_val(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_SizeofVal::new()
        }
    }

    // .c4.ast.proto.Expr.SizeofType sizeof_tp = 16;


    pub fn get_sizeof_tp(&self) -> &Expr_SizeofType {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(ref v)) => v,
            _ => Expr_SizeofType::default_instance(),
        }
    }
    pub fn clear_sizeof_tp(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_sizeof_tp(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sizeof_tp(&mut self, v: Expr_SizeofType) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sizeof_tp(&mut self) -> &mut Expr_SizeofType {
        if let ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(Expr_SizeofType::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sizeof_tp(&mut self) -> Expr_SizeofType {
        if self.has_sizeof_tp() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_SizeofType::new()
        }
    }

    // .c4.ast.proto.Expr.Unary unary = 17;


    pub fn get_unary(&self) -> &Expr_Unary {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::unary(ref v)) => v,
            _ => Expr_Unary::default_instance(),
        }
    }
    pub fn clear_unary(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_unary(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::unary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unary(&mut self, v: Expr_Unary) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::unary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unary(&mut self) -> &mut Expr_Unary {
        if let ::std::option::Option::Some(Expr_oneof_e::unary(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::unary(Expr_Unary::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::unary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unary(&mut self) -> Expr_Unary {
        if self.has_unary() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::unary(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Unary::new()
        }
    }

    // .c4.ast.proto.Expr.Binary binary = 18;


    pub fn get_binary(&self) -> &Expr_Binary {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::binary(ref v)) => v,
            _ => Expr_Binary::default_instance(),
        }
    }
    pub fn clear_binary(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_binary(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::binary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_binary(&mut self, v: Expr_Binary) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::binary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_binary(&mut self) -> &mut Expr_Binary {
        if let ::std::option::Option::Some(Expr_oneof_e::binary(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::binary(Expr_Binary::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::binary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_binary(&mut self) -> Expr_Binary {
        if self.has_binary() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::binary(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Binary::new()
        }
    }

    // .c4.ast.proto.Expr.Ternary ternary = 19;


    pub fn get_ternary(&self) -> &Expr_Ternary {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::ternary(ref v)) => v,
            _ => Expr_Ternary::default_instance(),
        }
    }
    pub fn clear_ternary(&mut self) {
        self.e = ::std::option::Option::None;
    }

    pub fn has_ternary(&self) -> bool {
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::ternary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ternary(&mut self, v: Expr_Ternary) {
        self.e = ::std::option::Option::Some(Expr_oneof_e::ternary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ternary(&mut self) -> &mut Expr_Ternary {
        if let ::std::option::Option::Some(Expr_oneof_e::ternary(_)) = self.e {
        } else {
            self.e = ::std::option::Option::Some(Expr_oneof_e::ternary(Expr_Ternary::new()));
        }
        match self.e {
            ::std::option::Option::Some(Expr_oneof_e::ternary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ternary(&mut self) -> Expr_Ternary {
        if self.has_ternary() {
            match self.e.take() {
                ::std::option::Option::Some(Expr_oneof_e::ternary(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Ternary::new()
        }
    }
}

impl ::protobuf::Message for Expr {
    fn is_initialized(&self) -> bool {
        if let Some(Expr_oneof_e::integer(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::cast(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::arr_sub(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::func_call(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::dot(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::ptr(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::sizeof_val(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::sizeof_tp(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::unary(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::binary(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_e::ternary(ref v)) = self.e {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::id(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::integer(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::float(is.read_float()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::double(is.read_double()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::char(is.read_uint32()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::wide_char(is.read_uint32()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::string(is.read_string()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::wide_string(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::cast(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::arr_sub(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::func_call(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::dot(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::ptr(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::sizeof_val(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::sizeof_tp(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::unary(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::binary(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.e = ::std::option::Option::Some(Expr_oneof_e::ternary(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.e {
            match v {
                &Expr_oneof_e::id(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &Expr_oneof_e::integer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::float(v) => {
                    my_size += 5;
                },
                &Expr_oneof_e::double(v) => {
                    my_size += 9;
                },
                &Expr_oneof_e::char(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Expr_oneof_e::wide_char(v) => {
                    my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Expr_oneof_e::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(8, &v);
                },
                &Expr_oneof_e::wide_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &Expr_oneof_e::cast(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::arr_sub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::func_call(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::dot(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::ptr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::sizeof_val(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::sizeof_tp(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::unary(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::binary(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_e::ternary(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.e {
            match v {
                &Expr_oneof_e::id(ref v) => {
                    os.write_string(1, v)?;
                },
                &Expr_oneof_e::integer(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::float(v) => {
                    os.write_float(3, v)?;
                },
                &Expr_oneof_e::double(v) => {
                    os.write_double(4, v)?;
                },
                &Expr_oneof_e::char(v) => {
                    os.write_uint32(6, v)?;
                },
                &Expr_oneof_e::wide_char(v) => {
                    os.write_uint32(7, v)?;
                },
                &Expr_oneof_e::string(ref v) => {
                    os.write_string(8, v)?;
                },
                &Expr_oneof_e::wide_string(ref v) => {
                    os.write_string(9, v)?;
                },
                &Expr_oneof_e::cast(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::arr_sub(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::func_call(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::dot(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::ptr(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::sizeof_val(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::sizeof_tp(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::unary(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::binary(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_e::ternary(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr {
        Expr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "id",
                    Expr::has_id,
                    Expr::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Integer>(
                    "integer",
                    Expr::has_integer,
                    Expr::get_integer,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                    "float",
                    Expr::has_float,
                    Expr::get_float,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                    "double",
                    Expr::has_double,
                    Expr::get_double,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                    "char",
                    Expr::has_char,
                    Expr::get_char,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                    "wide_char",
                    Expr::has_wide_char,
                    Expr::get_wide_char,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "string",
                    Expr::has_string,
                    Expr::get_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "wide_string",
                    Expr::has_wide_string,
                    Expr::get_wide_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Cast>(
                    "cast",
                    Expr::has_cast,
                    Expr::get_cast,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_ArrSub>(
                    "arr_sub",
                    Expr::has_arr_sub,
                    Expr::get_arr_sub,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_FuncCall>(
                    "func_call",
                    Expr::has_func_call,
                    Expr::get_func_call,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Dot>(
                    "dot",
                    Expr::has_dot,
                    Expr::get_dot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Ptr>(
                    "ptr",
                    Expr::has_ptr,
                    Expr::get_ptr,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_SizeofVal>(
                    "sizeof_val",
                    Expr::has_sizeof_val,
                    Expr::get_sizeof_val,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_SizeofType>(
                    "sizeof_tp",
                    Expr::has_sizeof_tp,
                    Expr::get_sizeof_tp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Unary>(
                    "unary",
                    Expr::has_unary,
                    Expr::get_unary,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Binary>(
                    "binary",
                    Expr::has_binary,
                    Expr::get_binary,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Ternary>(
                    "ternary",
                    Expr::has_ternary,
                    Expr::get_ternary,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr>(
                    "Expr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr {
        static mut instance: ::protobuf::lazy::Lazy<Expr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr,
        };
        unsafe {
            instance.get(Expr::new)
        }
    }
}

impl ::protobuf::Clear for Expr {
    fn clear(&mut self) {
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.e = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Integer {
    // message fields
    pub n: i64,
    pub size: Expr_Integer_Size,
    pub signed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Integer {
    fn default() -> &'a Expr_Integer {
        <Expr_Integer as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Integer {
    pub fn new() -> Expr_Integer {
        ::std::default::Default::default()
    }

    // int64 n = 1;


    pub fn get_n(&self) -> i64 {
        self.n
    }
    pub fn clear_n(&mut self) {
        self.n = 0;
    }

    // Param is passed by value, moved
    pub fn set_n(&mut self, v: i64) {
        self.n = v;
    }

    // .c4.ast.proto.Expr.Integer.Size size = 2;


    pub fn get_size(&self) -> Expr_Integer_Size {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = Expr_Integer_Size::INT8;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: Expr_Integer_Size) {
        self.size = v;
    }

    // bool signed = 3;


    pub fn get_signed(&self) -> bool {
        self.signed
    }
    pub fn clear_signed(&mut self) {
        self.signed = false;
    }

    // Param is passed by value, moved
    pub fn set_signed(&mut self, v: bool) {
        self.signed = v;
    }
}

impl ::protobuf::Message for Expr_Integer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.n = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.size, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.signed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.n != 0 {
            my_size += ::protobuf::rt::value_size(1, self.n, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != Expr_Integer_Size::INT8 {
            my_size += ::protobuf::rt::enum_size(2, self.size);
        }
        if self.signed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.n != 0 {
            os.write_int64(1, self.n)?;
        }
        if self.size != Expr_Integer_Size::INT8 {
            os.write_enum(2, self.size.value())?;
        }
        if self.signed != false {
            os.write_bool(3, self.signed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Integer {
        Expr_Integer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "n",
                    |m: &Expr_Integer| { &m.n },
                    |m: &mut Expr_Integer| { &mut m.n },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Expr_Integer_Size>>(
                    "size",
                    |m: &Expr_Integer| { &m.size },
                    |m: &mut Expr_Integer| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "signed",
                    |m: &Expr_Integer| { &m.signed },
                    |m: &mut Expr_Integer| { &mut m.signed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Integer>(
                    "Expr_Integer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Integer {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Integer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Integer,
        };
        unsafe {
            instance.get(Expr_Integer::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Integer {
    fn clear(&mut self) {
        self.n = 0;
        self.size = Expr_Integer_Size::INT8;
        self.signed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Integer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Integer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Expr_Integer_Size {
    INT8 = 0,
    INT16 = 1,
    INT32 = 2,
    INT64 = 3,
}

impl ::protobuf::ProtobufEnum for Expr_Integer_Size {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Expr_Integer_Size> {
        match value {
            0 => ::std::option::Option::Some(Expr_Integer_Size::INT8),
            1 => ::std::option::Option::Some(Expr_Integer_Size::INT16),
            2 => ::std::option::Option::Some(Expr_Integer_Size::INT32),
            3 => ::std::option::Option::Some(Expr_Integer_Size::INT64),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Expr_Integer_Size] = &[
            Expr_Integer_Size::INT8,
            Expr_Integer_Size::INT16,
            Expr_Integer_Size::INT32,
            Expr_Integer_Size::INT64,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Expr_Integer_Size", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Expr_Integer_Size {
}

impl ::std::default::Default for Expr_Integer_Size {
    fn default() -> Self {
        Expr_Integer_Size::INT8
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Integer_Size {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Cast {
    // message fields
    pub tp: ::protobuf::SingularPtrField<TypeName>,
    pub tp_loc: ::protobuf::SingularPtrField<Loc>,
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Cast {
    fn default() -> &'a Expr_Cast {
        <Expr_Cast as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Cast {
    pub fn new() -> Expr_Cast {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.TypeName tp = 1;


    pub fn get_tp(&self) -> &TypeName {
        self.tp.as_ref().unwrap_or_else(|| TypeName::default_instance())
    }
    pub fn clear_tp(&mut self) {
        self.tp.clear();
    }

    pub fn has_tp(&self) -> bool {
        self.tp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp(&mut self, v: TypeName) {
        self.tp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tp(&mut self) -> &mut TypeName {
        if self.tp.is_none() {
            self.tp.set_default();
        }
        self.tp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tp(&mut self) -> TypeName {
        self.tp.take().unwrap_or_else(|| TypeName::new())
    }

    // .c4.ast.proto.Loc tp_loc = 2;


    pub fn get_tp_loc(&self) -> &Loc {
        self.tp_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_tp_loc(&mut self) {
        self.tp_loc.clear();
    }

    pub fn has_tp_loc(&self) -> bool {
        self.tp_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_loc(&mut self, v: Loc) {
        self.tp_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tp_loc(&mut self) -> &mut Loc {
        if self.tp_loc.is_none() {
            self.tp_loc.set_default();
        }
        self.tp_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_tp_loc(&mut self) -> Loc {
        self.tp_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 e_idx = 3;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 4;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_Cast {
    fn is_initialized(&self) -> bool {
        for v in &self.tp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tp_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tp)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tp_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tp_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tp_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.e_idx != 0 {
            os.write_int32(3, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Cast {
        Expr_Cast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeName>>(
                    "tp",
                    |m: &Expr_Cast| { &m.tp },
                    |m: &mut Expr_Cast| { &mut m.tp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "tp_loc",
                    |m: &Expr_Cast| { &m.tp_loc },
                    |m: &mut Expr_Cast| { &mut m.tp_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Expr_Cast| { &m.e_idx },
                    |m: &mut Expr_Cast| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Expr_Cast| { &m.e_loc },
                    |m: &mut Expr_Cast| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Cast>(
                    "Expr_Cast",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Cast {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Cast> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Cast,
        };
        unsafe {
            instance.get(Expr_Cast::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Cast {
    fn clear(&mut self) {
        self.tp.clear();
        self.tp_loc.clear();
        self.e_idx = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Cast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Cast {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_ArrSub {
    // message fields
    pub arr_idx: i32,
    pub arr_loc: ::protobuf::SingularPtrField<Loc>,
    pub sub_idx: i32,
    pub sub_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_ArrSub {
    fn default() -> &'a Expr_ArrSub {
        <Expr_ArrSub as ::protobuf::Message>::default_instance()
    }
}

impl Expr_ArrSub {
    pub fn new() -> Expr_ArrSub {
        ::std::default::Default::default()
    }

    // int32 arr_idx = 1;


    pub fn get_arr_idx(&self) -> i32 {
        self.arr_idx
    }
    pub fn clear_arr_idx(&mut self) {
        self.arr_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_arr_idx(&mut self, v: i32) {
        self.arr_idx = v;
    }

    // .c4.ast.proto.Loc arr_loc = 2;


    pub fn get_arr_loc(&self) -> &Loc {
        self.arr_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_arr_loc(&mut self) {
        self.arr_loc.clear();
    }

    pub fn has_arr_loc(&self) -> bool {
        self.arr_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arr_loc(&mut self, v: Loc) {
        self.arr_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arr_loc(&mut self) -> &mut Loc {
        if self.arr_loc.is_none() {
            self.arr_loc.set_default();
        }
        self.arr_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_arr_loc(&mut self) -> Loc {
        self.arr_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 sub_idx = 3;


    pub fn get_sub_idx(&self) -> i32 {
        self.sub_idx
    }
    pub fn clear_sub_idx(&mut self) {
        self.sub_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_sub_idx(&mut self, v: i32) {
        self.sub_idx = v;
    }

    // .c4.ast.proto.Loc sub_loc = 4;


    pub fn get_sub_loc(&self) -> &Loc {
        self.sub_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_sub_loc(&mut self) {
        self.sub_loc.clear();
    }

    pub fn has_sub_loc(&self) -> bool {
        self.sub_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_loc(&mut self, v: Loc) {
        self.sub_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_loc(&mut self) -> &mut Loc {
        if self.sub_loc.is_none() {
            self.sub_loc.set_default();
        }
        self.sub_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_sub_loc(&mut self) -> Loc {
        self.sub_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_ArrSub {
    fn is_initialized(&self) -> bool {
        for v in &self.arr_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sub_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.arr_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arr_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sub_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sub_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.arr_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.arr_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.arr_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.sub_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sub_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sub_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.arr_idx != 0 {
            os.write_int32(1, self.arr_idx)?;
        }
        if let Some(ref v) = self.arr_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.sub_idx != 0 {
            os.write_int32(3, self.sub_idx)?;
        }
        if let Some(ref v) = self.sub_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_ArrSub {
        Expr_ArrSub::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "arr_idx",
                    |m: &Expr_ArrSub| { &m.arr_idx },
                    |m: &mut Expr_ArrSub| { &mut m.arr_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "arr_loc",
                    |m: &Expr_ArrSub| { &m.arr_loc },
                    |m: &mut Expr_ArrSub| { &mut m.arr_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sub_idx",
                    |m: &Expr_ArrSub| { &m.sub_idx },
                    |m: &mut Expr_ArrSub| { &mut m.sub_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "sub_loc",
                    |m: &Expr_ArrSub| { &m.sub_loc },
                    |m: &mut Expr_ArrSub| { &mut m.sub_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_ArrSub>(
                    "Expr_ArrSub",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_ArrSub {
        static mut instance: ::protobuf::lazy::Lazy<Expr_ArrSub> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_ArrSub,
        };
        unsafe {
            instance.get(Expr_ArrSub::new)
        }
    }
}

impl ::protobuf::Clear for Expr_ArrSub {
    fn clear(&mut self) {
        self.arr_idx = 0;
        self.arr_loc.clear();
        self.sub_idx = 0;
        self.sub_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_ArrSub {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_ArrSub {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_FuncCall {
    // message fields
    pub fn_idx: i32,
    pub fn_loc: ::protobuf::SingularPtrField<Loc>,
    pub args: ::std::vec::Vec<i32>,
    pub arg_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_FuncCall {
    fn default() -> &'a Expr_FuncCall {
        <Expr_FuncCall as ::protobuf::Message>::default_instance()
    }
}

impl Expr_FuncCall {
    pub fn new() -> Expr_FuncCall {
        ::std::default::Default::default()
    }

    // int32 fn_idx = 1;


    pub fn get_fn_idx(&self) -> i32 {
        self.fn_idx
    }
    pub fn clear_fn_idx(&mut self) {
        self.fn_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_fn_idx(&mut self, v: i32) {
        self.fn_idx = v;
    }

    // .c4.ast.proto.Loc fn_loc = 2;


    pub fn get_fn_loc(&self) -> &Loc {
        self.fn_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_fn_loc(&mut self) {
        self.fn_loc.clear();
    }

    pub fn has_fn_loc(&self) -> bool {
        self.fn_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fn_loc(&mut self, v: Loc) {
        self.fn_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fn_loc(&mut self) -> &mut Loc {
        if self.fn_loc.is_none() {
            self.fn_loc.set_default();
        }
        self.fn_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fn_loc(&mut self) -> Loc {
        self.fn_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated int32 args = 3;


    pub fn get_args(&self) -> &[i32] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::vec::Vec<i32>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.args, ::std::vec::Vec::new())
    }

    // repeated .c4.ast.proto.Loc arg_locs = 4;


    pub fn get_arg_locs(&self) -> &[Loc] {
        &self.arg_locs
    }
    pub fn clear_arg_locs(&mut self) {
        self.arg_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_arg_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.arg_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arg_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.arg_locs
    }

    // Take field
    pub fn take_arg_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.arg_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Expr_FuncCall {
    fn is_initialized(&self) -> bool {
        for v in &self.fn_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arg_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fn_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fn_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.args)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arg_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fn_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fn_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fn_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.args {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.arg_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fn_idx != 0 {
            os.write_int32(1, self.fn_idx)?;
        }
        if let Some(ref v) = self.fn_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.args {
            os.write_int32(3, *v)?;
        };
        for v in &self.arg_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_FuncCall {
        Expr_FuncCall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "fn_idx",
                    |m: &Expr_FuncCall| { &m.fn_idx },
                    |m: &mut Expr_FuncCall| { &mut m.fn_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "fn_loc",
                    |m: &Expr_FuncCall| { &m.fn_loc },
                    |m: &mut Expr_FuncCall| { &mut m.fn_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "args",
                    |m: &Expr_FuncCall| { &m.args },
                    |m: &mut Expr_FuncCall| { &mut m.args },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "arg_locs",
                    |m: &Expr_FuncCall| { &m.arg_locs },
                    |m: &mut Expr_FuncCall| { &mut m.arg_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_FuncCall>(
                    "Expr_FuncCall",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_FuncCall {
        static mut instance: ::protobuf::lazy::Lazy<Expr_FuncCall> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_FuncCall,
        };
        unsafe {
            instance.get(Expr_FuncCall::new)
        }
    }
}

impl ::protobuf::Clear for Expr_FuncCall {
    fn clear(&mut self) {
        self.fn_idx = 0;
        self.fn_loc.clear();
        self.args.clear();
        self.arg_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_FuncCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_FuncCall {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Dot {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    pub field: ::std::string::String,
    pub field_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Dot {
    fn default() -> &'a Expr_Dot {
        <Expr_Dot as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Dot {
    pub fn new() -> Expr_Dot {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }

    // string field = 3;


    pub fn get_field(&self) -> &str {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc field_loc = 4;


    pub fn get_field_loc(&self) -> &Loc {
        self.field_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_field_loc(&mut self) {
        self.field_loc.clear();
    }

    pub fn has_field_loc(&self) -> bool {
        self.field_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_loc(&mut self, v: Loc) {
        self.field_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_loc(&mut self) -> &mut Loc {
        if self.field_loc.is_none() {
            self.field_loc.set_default();
        }
        self.field_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_loc(&mut self) -> Loc {
        self.field_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_Dot {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field);
        }
        if let Some(ref v) = self.field_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.field.is_empty() {
            os.write_string(3, &self.field)?;
        }
        if let Some(ref v) = self.field_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Dot {
        Expr_Dot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Expr_Dot| { &m.e_idx },
                    |m: &mut Expr_Dot| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Expr_Dot| { &m.e_loc },
                    |m: &mut Expr_Dot| { &mut m.e_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &Expr_Dot| { &m.field },
                    |m: &mut Expr_Dot| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "field_loc",
                    |m: &Expr_Dot| { &m.field_loc },
                    |m: &mut Expr_Dot| { &mut m.field_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Dot>(
                    "Expr_Dot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Dot {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Dot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Dot,
        };
        unsafe {
            instance.get(Expr_Dot::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Dot {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.field.clear();
        self.field_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Dot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Dot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Ptr {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    pub field: ::std::string::String,
    pub field_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Ptr {
    fn default() -> &'a Expr_Ptr {
        <Expr_Ptr as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Ptr {
    pub fn new() -> Expr_Ptr {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }

    // string field = 3;


    pub fn get_field(&self) -> &str {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc field_loc = 4;


    pub fn get_field_loc(&self) -> &Loc {
        self.field_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_field_loc(&mut self) {
        self.field_loc.clear();
    }

    pub fn has_field_loc(&self) -> bool {
        self.field_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_loc(&mut self, v: Loc) {
        self.field_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_loc(&mut self) -> &mut Loc {
        if self.field_loc.is_none() {
            self.field_loc.set_default();
        }
        self.field_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_loc(&mut self) -> Loc {
        self.field_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_Ptr {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field);
        }
        if let Some(ref v) = self.field_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.field.is_empty() {
            os.write_string(3, &self.field)?;
        }
        if let Some(ref v) = self.field_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Ptr {
        Expr_Ptr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Expr_Ptr| { &m.e_idx },
                    |m: &mut Expr_Ptr| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Expr_Ptr| { &m.e_loc },
                    |m: &mut Expr_Ptr| { &mut m.e_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &Expr_Ptr| { &m.field },
                    |m: &mut Expr_Ptr| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "field_loc",
                    |m: &Expr_Ptr| { &m.field_loc },
                    |m: &mut Expr_Ptr| { &mut m.field_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Ptr>(
                    "Expr_Ptr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Ptr {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Ptr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Ptr,
        };
        unsafe {
            instance.get(Expr_Ptr::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Ptr {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.field.clear();
        self.field_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Ptr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Ptr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_SizeofVal {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_SizeofVal {
    fn default() -> &'a Expr_SizeofVal {
        <Expr_SizeofVal as ::protobuf::Message>::default_instance()
    }
}

impl Expr_SizeofVal {
    pub fn new() -> Expr_SizeofVal {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_SizeofVal {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_SizeofVal {
        Expr_SizeofVal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Expr_SizeofVal| { &m.e_idx },
                    |m: &mut Expr_SizeofVal| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Expr_SizeofVal| { &m.e_loc },
                    |m: &mut Expr_SizeofVal| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_SizeofVal>(
                    "Expr_SizeofVal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_SizeofVal {
        static mut instance: ::protobuf::lazy::Lazy<Expr_SizeofVal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_SizeofVal,
        };
        unsafe {
            instance.get(Expr_SizeofVal::new)
        }
    }
}

impl ::protobuf::Clear for Expr_SizeofVal {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_SizeofVal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_SizeofVal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_SizeofType {
    // message fields
    pub tp: ::protobuf::SingularPtrField<TypeName>,
    pub tp_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_SizeofType {
    fn default() -> &'a Expr_SizeofType {
        <Expr_SizeofType as ::protobuf::Message>::default_instance()
    }
}

impl Expr_SizeofType {
    pub fn new() -> Expr_SizeofType {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.TypeName tp = 1;


    pub fn get_tp(&self) -> &TypeName {
        self.tp.as_ref().unwrap_or_else(|| TypeName::default_instance())
    }
    pub fn clear_tp(&mut self) {
        self.tp.clear();
    }

    pub fn has_tp(&self) -> bool {
        self.tp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp(&mut self, v: TypeName) {
        self.tp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tp(&mut self) -> &mut TypeName {
        if self.tp.is_none() {
            self.tp.set_default();
        }
        self.tp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tp(&mut self) -> TypeName {
        self.tp.take().unwrap_or_else(|| TypeName::new())
    }

    // .c4.ast.proto.Loc tp_loc = 2;


    pub fn get_tp_loc(&self) -> &Loc {
        self.tp_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_tp_loc(&mut self) {
        self.tp_loc.clear();
    }

    pub fn has_tp_loc(&self) -> bool {
        self.tp_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_loc(&mut self, v: Loc) {
        self.tp_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tp_loc(&mut self) -> &mut Loc {
        if self.tp_loc.is_none() {
            self.tp_loc.set_default();
        }
        self.tp_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_tp_loc(&mut self) -> Loc {
        self.tp_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_SizeofType {
    fn is_initialized(&self) -> bool {
        for v in &self.tp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tp_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tp)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tp_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tp_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tp_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_SizeofType {
        Expr_SizeofType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeName>>(
                    "tp",
                    |m: &Expr_SizeofType| { &m.tp },
                    |m: &mut Expr_SizeofType| { &mut m.tp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "tp_loc",
                    |m: &Expr_SizeofType| { &m.tp_loc },
                    |m: &mut Expr_SizeofType| { &mut m.tp_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_SizeofType>(
                    "Expr_SizeofType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_SizeofType {
        static mut instance: ::protobuf::lazy::Lazy<Expr_SizeofType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_SizeofType,
        };
        unsafe {
            instance.get(Expr_SizeofType::new)
        }
    }
}

impl ::protobuf::Clear for Expr_SizeofType {
    fn clear(&mut self) {
        self.tp.clear();
        self.tp_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_SizeofType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_SizeofType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Unary {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    pub op: Expr_Unary_Op,
    pub op_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Unary {
    fn default() -> &'a Expr_Unary {
        <Expr_Unary as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Unary {
    pub fn new() -> Expr_Unary {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }

    // .c4.ast.proto.Expr.Unary.Op op = 3;


    pub fn get_op(&self) -> Expr_Unary_Op {
        self.op
    }
    pub fn clear_op(&mut self) {
        self.op = Expr_Unary_Op::PREFIX_INC;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: Expr_Unary_Op) {
        self.op = v;
    }

    // .c4.ast.proto.Loc op_loc = 4;


    pub fn get_op_loc(&self) -> &Loc {
        self.op_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_op_loc(&mut self) {
        self.op_loc.clear();
    }

    pub fn has_op_loc(&self) -> bool {
        self.op_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_loc(&mut self, v: Loc) {
        self.op_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_loc(&mut self) -> &mut Loc {
        if self.op_loc.is_none() {
            self.op_loc.set_default();
        }
        self.op_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_loc(&mut self) -> Loc {
        self.op_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_Unary {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.op_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.op_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.op != Expr_Unary_Op::PREFIX_INC {
            my_size += ::protobuf::rt::enum_size(3, self.op);
        }
        if let Some(ref v) = self.op_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.op != Expr_Unary_Op::PREFIX_INC {
            os.write_enum(3, self.op.value())?;
        }
        if let Some(ref v) = self.op_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Unary {
        Expr_Unary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Expr_Unary| { &m.e_idx },
                    |m: &mut Expr_Unary| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Expr_Unary| { &m.e_loc },
                    |m: &mut Expr_Unary| { &mut m.e_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Expr_Unary_Op>>(
                    "op",
                    |m: &Expr_Unary| { &m.op },
                    |m: &mut Expr_Unary| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "op_loc",
                    |m: &Expr_Unary| { &m.op_loc },
                    |m: &mut Expr_Unary| { &mut m.op_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Unary>(
                    "Expr_Unary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Unary {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Unary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Unary,
        };
        unsafe {
            instance.get(Expr_Unary::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Unary {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.op = Expr_Unary_Op::PREFIX_INC;
        self.op_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Unary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Unary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Expr_Unary_Op {
    PREFIX_INC = 0,
    PREFIX_DEC = 1,
    POSTFIX_INC = 2,
    POSTFIX_DEC = 3,
    REF = 4,
    DEREF = 5,
    POS = 6,
    NEG = 7,
    BIT_NOT = 8,
    LOGIC_NOT = 9,
}

impl ::protobuf::ProtobufEnum for Expr_Unary_Op {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Expr_Unary_Op> {
        match value {
            0 => ::std::option::Option::Some(Expr_Unary_Op::PREFIX_INC),
            1 => ::std::option::Option::Some(Expr_Unary_Op::PREFIX_DEC),
            2 => ::std::option::Option::Some(Expr_Unary_Op::POSTFIX_INC),
            3 => ::std::option::Option::Some(Expr_Unary_Op::POSTFIX_DEC),
            4 => ::std::option::Option::Some(Expr_Unary_Op::REF),
            5 => ::std::option::Option::Some(Expr_Unary_Op::DEREF),
            6 => ::std::option::Option::Some(Expr_Unary_Op::POS),
            7 => ::std::option::Option::Some(Expr_Unary_Op::NEG),
            8 => ::std::option::Option::Some(Expr_Unary_Op::BIT_NOT),
            9 => ::std::option::Option::Some(Expr_Unary_Op::LOGIC_NOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Expr_Unary_Op] = &[
            Expr_Unary_Op::PREFIX_INC,
            Expr_Unary_Op::PREFIX_DEC,
            Expr_Unary_Op::POSTFIX_INC,
            Expr_Unary_Op::POSTFIX_DEC,
            Expr_Unary_Op::REF,
            Expr_Unary_Op::DEREF,
            Expr_Unary_Op::POS,
            Expr_Unary_Op::NEG,
            Expr_Unary_Op::BIT_NOT,
            Expr_Unary_Op::LOGIC_NOT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Expr_Unary_Op", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Expr_Unary_Op {
}

impl ::std::default::Default for Expr_Unary_Op {
    fn default() -> Self {
        Expr_Unary_Op::PREFIX_INC
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Unary_Op {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Binary {
    // message fields
    pub e1_idx: i32,
    pub e1_loc: ::protobuf::SingularPtrField<Loc>,
    pub e2_idx: i32,
    pub e2_loc: ::protobuf::SingularPtrField<Loc>,
    pub op: Expr_Binary_Op,
    pub op_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Binary {
    fn default() -> &'a Expr_Binary {
        <Expr_Binary as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Binary {
    pub fn new() -> Expr_Binary {
        ::std::default::Default::default()
    }

    // int32 e1_idx = 1;


    pub fn get_e1_idx(&self) -> i32 {
        self.e1_idx
    }
    pub fn clear_e1_idx(&mut self) {
        self.e1_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e1_idx(&mut self, v: i32) {
        self.e1_idx = v;
    }

    // .c4.ast.proto.Loc e1_loc = 2;


    pub fn get_e1_loc(&self) -> &Loc {
        self.e1_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e1_loc(&mut self) {
        self.e1_loc.clear();
    }

    pub fn has_e1_loc(&self) -> bool {
        self.e1_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e1_loc(&mut self, v: Loc) {
        self.e1_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e1_loc(&mut self) -> &mut Loc {
        if self.e1_loc.is_none() {
            self.e1_loc.set_default();
        }
        self.e1_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e1_loc(&mut self) -> Loc {
        self.e1_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 e2_idx = 3;


    pub fn get_e2_idx(&self) -> i32 {
        self.e2_idx
    }
    pub fn clear_e2_idx(&mut self) {
        self.e2_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e2_idx(&mut self, v: i32) {
        self.e2_idx = v;
    }

    // .c4.ast.proto.Loc e2_loc = 4;


    pub fn get_e2_loc(&self) -> &Loc {
        self.e2_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e2_loc(&mut self) {
        self.e2_loc.clear();
    }

    pub fn has_e2_loc(&self) -> bool {
        self.e2_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2_loc(&mut self, v: Loc) {
        self.e2_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e2_loc(&mut self) -> &mut Loc {
        if self.e2_loc.is_none() {
            self.e2_loc.set_default();
        }
        self.e2_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e2_loc(&mut self) -> Loc {
        self.e2_loc.take().unwrap_or_else(|| Loc::new())
    }

    // .c4.ast.proto.Expr.Binary.Op op = 5;


    pub fn get_op(&self) -> Expr_Binary_Op {
        self.op
    }
    pub fn clear_op(&mut self) {
        self.op = Expr_Binary_Op::ASSIGN;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: Expr_Binary_Op) {
        self.op = v;
    }

    // .c4.ast.proto.Loc op_loc = 6;


    pub fn get_op_loc(&self) -> &Loc {
        self.op_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_op_loc(&mut self) {
        self.op_loc.clear();
    }

    pub fn has_op_loc(&self) -> bool {
        self.op_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_loc(&mut self, v: Loc) {
        self.op_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_loc(&mut self) -> &mut Loc {
        if self.op_loc.is_none() {
            self.op_loc.set_default();
        }
        self.op_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_loc(&mut self) -> Loc {
        self.op_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_Binary {
    fn is_initialized(&self) -> bool {
        for v in &self.e1_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.e2_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.op_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e1_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e1_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e2_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e2_loc)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.op_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e1_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e1_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e1_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.e2_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.e2_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e2_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.op != Expr_Binary_Op::ASSIGN {
            my_size += ::protobuf::rt::enum_size(5, self.op);
        }
        if let Some(ref v) = self.op_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e1_idx != 0 {
            os.write_int32(1, self.e1_idx)?;
        }
        if let Some(ref v) = self.e1_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.e2_idx != 0 {
            os.write_int32(3, self.e2_idx)?;
        }
        if let Some(ref v) = self.e2_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.op != Expr_Binary_Op::ASSIGN {
            os.write_enum(5, self.op.value())?;
        }
        if let Some(ref v) = self.op_loc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Binary {
        Expr_Binary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e1_idx",
                    |m: &Expr_Binary| { &m.e1_idx },
                    |m: &mut Expr_Binary| { &mut m.e1_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e1_loc",
                    |m: &Expr_Binary| { &m.e1_loc },
                    |m: &mut Expr_Binary| { &mut m.e1_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e2_idx",
                    |m: &Expr_Binary| { &m.e2_idx },
                    |m: &mut Expr_Binary| { &mut m.e2_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e2_loc",
                    |m: &Expr_Binary| { &m.e2_loc },
                    |m: &mut Expr_Binary| { &mut m.e2_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Expr_Binary_Op>>(
                    "op",
                    |m: &Expr_Binary| { &m.op },
                    |m: &mut Expr_Binary| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "op_loc",
                    |m: &Expr_Binary| { &m.op_loc },
                    |m: &mut Expr_Binary| { &mut m.op_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Binary>(
                    "Expr_Binary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Binary {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Binary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Binary,
        };
        unsafe {
            instance.get(Expr_Binary::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Binary {
    fn clear(&mut self) {
        self.e1_idx = 0;
        self.e1_loc.clear();
        self.e2_idx = 0;
        self.e2_loc.clear();
        self.op = Expr_Binary_Op::ASSIGN;
        self.op_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Binary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Binary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Expr_Binary_Op {
    ASSIGN = 0,
    MUL_ASSIGN = 1,
    DIV_ASSIGN = 2,
    MOD_ASSIGN = 3,
    ADD_ASSIGN = 4,
    SUB_ASSIGN = 5,
    L_SHIFT_ASSIGN = 6,
    R_SHIFT_ASSIGN = 7,
    BINARY_AND_ASSIGN = 8,
    XOR_ASSIGN = 9,
    BINARY_OR_ASSIGN = 10,
    COMMA = 11,
    LOGIC_OR = 12,
    LOGIC_AND = 13,
    BIT_OR = 14,
    XOR = 15,
    BIT_AND = 16,
    EQ = 17,
    NEQ = 18,
    LESS = 19,
    GT = 20,
    LEQ = 21,
    GEQ = 22,
    L_SHIFT = 23,
    R_SHIFT = 24,
    ADD = 25,
    SUB = 26,
    MUL = 27,
    DIV = 28,
    MOD = 29,
}

impl ::protobuf::ProtobufEnum for Expr_Binary_Op {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Expr_Binary_Op> {
        match value {
            0 => ::std::option::Option::Some(Expr_Binary_Op::ASSIGN),
            1 => ::std::option::Option::Some(Expr_Binary_Op::MUL_ASSIGN),
            2 => ::std::option::Option::Some(Expr_Binary_Op::DIV_ASSIGN),
            3 => ::std::option::Option::Some(Expr_Binary_Op::MOD_ASSIGN),
            4 => ::std::option::Option::Some(Expr_Binary_Op::ADD_ASSIGN),
            5 => ::std::option::Option::Some(Expr_Binary_Op::SUB_ASSIGN),
            6 => ::std::option::Option::Some(Expr_Binary_Op::L_SHIFT_ASSIGN),
            7 => ::std::option::Option::Some(Expr_Binary_Op::R_SHIFT_ASSIGN),
            8 => ::std::option::Option::Some(Expr_Binary_Op::BINARY_AND_ASSIGN),
            9 => ::std::option::Option::Some(Expr_Binary_Op::XOR_ASSIGN),
            10 => ::std::option::Option::Some(Expr_Binary_Op::BINARY_OR_ASSIGN),
            11 => ::std::option::Option::Some(Expr_Binary_Op::COMMA),
            12 => ::std::option::Option::Some(Expr_Binary_Op::LOGIC_OR),
            13 => ::std::option::Option::Some(Expr_Binary_Op::LOGIC_AND),
            14 => ::std::option::Option::Some(Expr_Binary_Op::BIT_OR),
            15 => ::std::option::Option::Some(Expr_Binary_Op::XOR),
            16 => ::std::option::Option::Some(Expr_Binary_Op::BIT_AND),
            17 => ::std::option::Option::Some(Expr_Binary_Op::EQ),
            18 => ::std::option::Option::Some(Expr_Binary_Op::NEQ),
            19 => ::std::option::Option::Some(Expr_Binary_Op::LESS),
            20 => ::std::option::Option::Some(Expr_Binary_Op::GT),
            21 => ::std::option::Option::Some(Expr_Binary_Op::LEQ),
            22 => ::std::option::Option::Some(Expr_Binary_Op::GEQ),
            23 => ::std::option::Option::Some(Expr_Binary_Op::L_SHIFT),
            24 => ::std::option::Option::Some(Expr_Binary_Op::R_SHIFT),
            25 => ::std::option::Option::Some(Expr_Binary_Op::ADD),
            26 => ::std::option::Option::Some(Expr_Binary_Op::SUB),
            27 => ::std::option::Option::Some(Expr_Binary_Op::MUL),
            28 => ::std::option::Option::Some(Expr_Binary_Op::DIV),
            29 => ::std::option::Option::Some(Expr_Binary_Op::MOD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Expr_Binary_Op] = &[
            Expr_Binary_Op::ASSIGN,
            Expr_Binary_Op::MUL_ASSIGN,
            Expr_Binary_Op::DIV_ASSIGN,
            Expr_Binary_Op::MOD_ASSIGN,
            Expr_Binary_Op::ADD_ASSIGN,
            Expr_Binary_Op::SUB_ASSIGN,
            Expr_Binary_Op::L_SHIFT_ASSIGN,
            Expr_Binary_Op::R_SHIFT_ASSIGN,
            Expr_Binary_Op::BINARY_AND_ASSIGN,
            Expr_Binary_Op::XOR_ASSIGN,
            Expr_Binary_Op::BINARY_OR_ASSIGN,
            Expr_Binary_Op::COMMA,
            Expr_Binary_Op::LOGIC_OR,
            Expr_Binary_Op::LOGIC_AND,
            Expr_Binary_Op::BIT_OR,
            Expr_Binary_Op::XOR,
            Expr_Binary_Op::BIT_AND,
            Expr_Binary_Op::EQ,
            Expr_Binary_Op::NEQ,
            Expr_Binary_Op::LESS,
            Expr_Binary_Op::GT,
            Expr_Binary_Op::LEQ,
            Expr_Binary_Op::GEQ,
            Expr_Binary_Op::L_SHIFT,
            Expr_Binary_Op::R_SHIFT,
            Expr_Binary_Op::ADD,
            Expr_Binary_Op::SUB,
            Expr_Binary_Op::MUL,
            Expr_Binary_Op::DIV,
            Expr_Binary_Op::MOD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Expr_Binary_Op", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Expr_Binary_Op {
}

impl ::std::default::Default for Expr_Binary_Op {
    fn default() -> Self {
        Expr_Binary_Op::ASSIGN
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Binary_Op {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Ternary {
    // message fields
    pub cond_idx: i32,
    pub cond_loc: ::protobuf::SingularPtrField<Loc>,
    pub then_idx: i32,
    pub then_loc: ::protobuf::SingularPtrField<Loc>,
    pub else_idx: i32,
    pub else_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expr_Ternary {
    fn default() -> &'a Expr_Ternary {
        <Expr_Ternary as ::protobuf::Message>::default_instance()
    }
}

impl Expr_Ternary {
    pub fn new() -> Expr_Ternary {
        ::std::default::Default::default()
    }

    // int32 cond_idx = 1;


    pub fn get_cond_idx(&self) -> i32 {
        self.cond_idx
    }
    pub fn clear_cond_idx(&mut self) {
        self.cond_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_cond_idx(&mut self, v: i32) {
        self.cond_idx = v;
    }

    // .c4.ast.proto.Loc cond_loc = 2;


    pub fn get_cond_loc(&self) -> &Loc {
        self.cond_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_cond_loc(&mut self) {
        self.cond_loc.clear();
    }

    pub fn has_cond_loc(&self) -> bool {
        self.cond_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cond_loc(&mut self, v: Loc) {
        self.cond_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cond_loc(&mut self) -> &mut Loc {
        if self.cond_loc.is_none() {
            self.cond_loc.set_default();
        }
        self.cond_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_cond_loc(&mut self) -> Loc {
        self.cond_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 then_idx = 3;


    pub fn get_then_idx(&self) -> i32 {
        self.then_idx
    }
    pub fn clear_then_idx(&mut self) {
        self.then_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_then_idx(&mut self, v: i32) {
        self.then_idx = v;
    }

    // .c4.ast.proto.Loc then_loc = 4;


    pub fn get_then_loc(&self) -> &Loc {
        self.then_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_then_loc(&mut self) {
        self.then_loc.clear();
    }

    pub fn has_then_loc(&self) -> bool {
        self.then_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_then_loc(&mut self, v: Loc) {
        self.then_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_then_loc(&mut self) -> &mut Loc {
        if self.then_loc.is_none() {
            self.then_loc.set_default();
        }
        self.then_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_then_loc(&mut self) -> Loc {
        self.then_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 else_idx = 5;


    pub fn get_else_idx(&self) -> i32 {
        self.else_idx
    }
    pub fn clear_else_idx(&mut self) {
        self.else_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_else_idx(&mut self, v: i32) {
        self.else_idx = v;
    }

    // .c4.ast.proto.Loc else_loc = 6;


    pub fn get_else_loc(&self) -> &Loc {
        self.else_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_else_loc(&mut self) {
        self.else_loc.clear();
    }

    pub fn has_else_loc(&self) -> bool {
        self.else_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_else_loc(&mut self, v: Loc) {
        self.else_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_else_loc(&mut self) -> &mut Loc {
        if self.else_loc.is_none() {
            self.else_loc.set_default();
        }
        self.else_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_else_loc(&mut self) -> Loc {
        self.else_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Expr_Ternary {
    fn is_initialized(&self) -> bool {
        for v in &self.cond_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.else_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cond_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cond_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.then_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.then_loc)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.else_idx = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.else_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cond_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cond_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cond_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.then_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.then_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.then_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.else_idx != 0 {
            my_size += ::protobuf::rt::value_size(5, self.else_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.else_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cond_idx != 0 {
            os.write_int32(1, self.cond_idx)?;
        }
        if let Some(ref v) = self.cond_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.then_idx != 0 {
            os.write_int32(3, self.then_idx)?;
        }
        if let Some(ref v) = self.then_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.else_idx != 0 {
            os.write_int32(5, self.else_idx)?;
        }
        if let Some(ref v) = self.else_loc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Ternary {
        Expr_Ternary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cond_idx",
                    |m: &Expr_Ternary| { &m.cond_idx },
                    |m: &mut Expr_Ternary| { &mut m.cond_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "cond_loc",
                    |m: &Expr_Ternary| { &m.cond_loc },
                    |m: &mut Expr_Ternary| { &mut m.cond_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "then_idx",
                    |m: &Expr_Ternary| { &m.then_idx },
                    |m: &mut Expr_Ternary| { &mut m.then_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "then_loc",
                    |m: &Expr_Ternary| { &m.then_loc },
                    |m: &mut Expr_Ternary| { &mut m.then_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "else_idx",
                    |m: &Expr_Ternary| { &m.else_idx },
                    |m: &mut Expr_Ternary| { &mut m.else_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "else_loc",
                    |m: &Expr_Ternary| { &m.else_loc },
                    |m: &mut Expr_Ternary| { &mut m.else_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Ternary>(
                    "Expr_Ternary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Ternary {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Ternary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Ternary,
        };
        unsafe {
            instance.get(Expr_Ternary::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Ternary {
    fn clear(&mut self) {
        self.cond_idx = 0;
        self.cond_loc.clear();
        self.then_idx = 0;
        self.then_loc.clear();
        self.else_idx = 0;
        self.else_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Ternary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Ternary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier {
    // message oneof groups
    pub s: ::std::option::Option<TypeSpecifier_oneof_s>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier {
    fn default() -> &'a TypeSpecifier {
        <TypeSpecifier as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TypeSpecifier_oneof_s {
    void(TypeSpecifier_Void),
    char(TypeSpecifier_Char),
    short(TypeSpecifier_Short),
    int(TypeSpecifier_Int),
    long(TypeSpecifier_Long),
    float(TypeSpecifier_Float),
    double(TypeSpecifier_Double),
    signed(TypeSpecifier_Signed),
    unsigned(TypeSpecifier_Unsigned),
    field_struct(TypeSpecifier_Struct),
    union(TypeSpecifier_Union),
    field_enum(TypeSpecifier_Enum),
    typedef_name(::std::string::String),
}

impl TypeSpecifier {
    pub fn new() -> TypeSpecifier {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.TypeSpecifier.Void void = 1;


    pub fn get_void(&self) -> &TypeSpecifier_Void {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::void(ref v)) => v,
            _ => TypeSpecifier_Void::default_instance(),
        }
    }
    pub fn clear_void(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_void(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::void(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_void(&mut self, v: TypeSpecifier_Void) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::void(v))
    }

    // Mutable pointer to the field.
    pub fn mut_void(&mut self) -> &mut TypeSpecifier_Void {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::void(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::void(TypeSpecifier_Void::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::void(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_void(&mut self) -> TypeSpecifier_Void {
        if self.has_void() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::void(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Void::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Char char = 2;


    pub fn get_char(&self) -> &TypeSpecifier_Char {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::char(ref v)) => v,
            _ => TypeSpecifier_Char::default_instance(),
        }
    }
    pub fn clear_char(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_char(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::char(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_char(&mut self, v: TypeSpecifier_Char) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::char(v))
    }

    // Mutable pointer to the field.
    pub fn mut_char(&mut self) -> &mut TypeSpecifier_Char {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::char(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::char(TypeSpecifier_Char::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::char(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_char(&mut self) -> TypeSpecifier_Char {
        if self.has_char() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::char(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Char::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Short short = 3;


    pub fn get_short(&self) -> &TypeSpecifier_Short {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::short(ref v)) => v,
            _ => TypeSpecifier_Short::default_instance(),
        }
    }
    pub fn clear_short(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_short(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::short(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_short(&mut self, v: TypeSpecifier_Short) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::short(v))
    }

    // Mutable pointer to the field.
    pub fn mut_short(&mut self) -> &mut TypeSpecifier_Short {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::short(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::short(TypeSpecifier_Short::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::short(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_short(&mut self) -> TypeSpecifier_Short {
        if self.has_short() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::short(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Short::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Int int = 4;


    pub fn get_int(&self) -> &TypeSpecifier_Int {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::int(ref v)) => v,
            _ => TypeSpecifier_Int::default_instance(),
        }
    }
    pub fn clear_int(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: TypeSpecifier_Int) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::int(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int(&mut self) -> &mut TypeSpecifier_Int {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::int(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::int(TypeSpecifier_Int::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::int(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int(&mut self) -> TypeSpecifier_Int {
        if self.has_int() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::int(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Int::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Long long = 5;


    pub fn get_long(&self) -> &TypeSpecifier_Long {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::long(ref v)) => v,
            _ => TypeSpecifier_Long::default_instance(),
        }
    }
    pub fn clear_long(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_long(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::long(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long(&mut self, v: TypeSpecifier_Long) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::long(v))
    }

    // Mutable pointer to the field.
    pub fn mut_long(&mut self) -> &mut TypeSpecifier_Long {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::long(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::long(TypeSpecifier_Long::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::long(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_long(&mut self) -> TypeSpecifier_Long {
        if self.has_long() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::long(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Long::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Float float = 6;


    pub fn get_float(&self) -> &TypeSpecifier_Float {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::float(ref v)) => v,
            _ => TypeSpecifier_Float::default_instance(),
        }
    }
    pub fn clear_float(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: TypeSpecifier_Float) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::float(v))
    }

    // Mutable pointer to the field.
    pub fn mut_float(&mut self) -> &mut TypeSpecifier_Float {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::float(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::float(TypeSpecifier_Float::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::float(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_float(&mut self) -> TypeSpecifier_Float {
        if self.has_float() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::float(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Float::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Double double = 7;


    pub fn get_double(&self) -> &TypeSpecifier_Double {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::double(ref v)) => v,
            _ => TypeSpecifier_Double::default_instance(),
        }
    }
    pub fn clear_double(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: TypeSpecifier_Double) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::double(v))
    }

    // Mutable pointer to the field.
    pub fn mut_double(&mut self) -> &mut TypeSpecifier_Double {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::double(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::double(TypeSpecifier_Double::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::double(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_double(&mut self) -> TypeSpecifier_Double {
        if self.has_double() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::double(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Double::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Signed signed = 8;


    pub fn get_signed(&self) -> &TypeSpecifier_Signed {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(ref v)) => v,
            _ => TypeSpecifier_Signed::default_instance(),
        }
    }
    pub fn clear_signed(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_signed(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed(&mut self, v: TypeSpecifier_Signed) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed(&mut self) -> &mut TypeSpecifier_Signed {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(TypeSpecifier_Signed::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed(&mut self) -> TypeSpecifier_Signed {
        if self.has_signed() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Signed::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Unsigned unsigned = 9;


    pub fn get_unsigned(&self) -> &TypeSpecifier_Unsigned {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(ref v)) => v,
            _ => TypeSpecifier_Unsigned::default_instance(),
        }
    }
    pub fn clear_unsigned(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_unsigned(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unsigned(&mut self, v: TypeSpecifier_Unsigned) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unsigned(&mut self) -> &mut TypeSpecifier_Unsigned {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(TypeSpecifier_Unsigned::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unsigned(&mut self) -> TypeSpecifier_Unsigned {
        if self.has_unsigned() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Unsigned::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Struct struct = 10;


    pub fn get_field_struct(&self) -> &TypeSpecifier_Struct {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(ref v)) => v,
            _ => TypeSpecifier_Struct::default_instance(),
        }
    }
    pub fn clear_field_struct(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_field_struct(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_struct(&mut self, v: TypeSpecifier_Struct) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_struct(&mut self) -> &mut TypeSpecifier_Struct {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(TypeSpecifier_Struct::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_struct(&mut self) -> TypeSpecifier_Struct {
        if self.has_field_struct() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Struct::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Union union = 11;


    pub fn get_union(&self) -> &TypeSpecifier_Union {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::union(ref v)) => v,
            _ => TypeSpecifier_Union::default_instance(),
        }
    }
    pub fn clear_union(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_union(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::union(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_union(&mut self, v: TypeSpecifier_Union) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::union(v))
    }

    // Mutable pointer to the field.
    pub fn mut_union(&mut self) -> &mut TypeSpecifier_Union {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::union(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::union(TypeSpecifier_Union::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::union(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_union(&mut self) -> TypeSpecifier_Union {
        if self.has_union() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::union(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Union::new()
        }
    }

    // .c4.ast.proto.TypeSpecifier.Enum enum = 12;


    pub fn get_field_enum(&self) -> &TypeSpecifier_Enum {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(ref v)) => v,
            _ => TypeSpecifier_Enum::default_instance(),
        }
    }
    pub fn clear_field_enum(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_field_enum(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_enum(&mut self, v: TypeSpecifier_Enum) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_enum(&mut self) -> &mut TypeSpecifier_Enum {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(TypeSpecifier_Enum::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_enum(&mut self) -> TypeSpecifier_Enum {
        if self.has_field_enum() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier_Enum::new()
        }
    }

    // string typedef_name = 13;


    pub fn get_typedef_name(&self) -> &str {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_typedef_name(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_typedef_name(&self) -> bool {
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typedef_name(&mut self, v: ::std::string::String) {
        self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typedef_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(_)) = self.s {
        } else {
            self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(::std::string::String::new()));
        }
        match self.s {
            ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typedef_name(&mut self) -> ::std::string::String {
        if self.has_typedef_name() {
            match self.s.take() {
                ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for TypeSpecifier {
    fn is_initialized(&self) -> bool {
        if let Some(TypeSpecifier_oneof_s::void(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::char(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::short(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::int(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::long(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::float(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::double(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::signed(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::unsigned(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::field_struct(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::union(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TypeSpecifier_oneof_s::field_enum(ref v)) = self.s {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::void(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::char(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::short(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::int(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::long(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::float(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::double(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::signed(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::unsigned(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::field_struct(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::union(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::field_enum(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.s = ::std::option::Option::Some(TypeSpecifier_oneof_s::typedef_name(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.s {
            match v {
                &TypeSpecifier_oneof_s::void(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::char(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::short(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::int(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::long(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::float(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::double(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::signed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::unsigned(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::field_struct(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::union(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::field_enum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeSpecifier_oneof_s::typedef_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(13, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.s {
            match v {
                &TypeSpecifier_oneof_s::void(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::char(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::short(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::int(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::long(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::float(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::double(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::signed(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::unsigned(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::field_struct(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::union(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::field_enum(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeSpecifier_oneof_s::typedef_name(ref v) => {
                    os.write_string(13, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier {
        TypeSpecifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Void>(
                    "void",
                    TypeSpecifier::has_void,
                    TypeSpecifier::get_void,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Char>(
                    "char",
                    TypeSpecifier::has_char,
                    TypeSpecifier::get_char,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Short>(
                    "short",
                    TypeSpecifier::has_short,
                    TypeSpecifier::get_short,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Int>(
                    "int",
                    TypeSpecifier::has_int,
                    TypeSpecifier::get_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Long>(
                    "long",
                    TypeSpecifier::has_long,
                    TypeSpecifier::get_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Float>(
                    "float",
                    TypeSpecifier::has_float,
                    TypeSpecifier::get_float,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Double>(
                    "double",
                    TypeSpecifier::has_double,
                    TypeSpecifier::get_double,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Signed>(
                    "signed",
                    TypeSpecifier::has_signed,
                    TypeSpecifier::get_signed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Unsigned>(
                    "unsigned",
                    TypeSpecifier::has_unsigned,
                    TypeSpecifier::get_unsigned,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Struct>(
                    "struct",
                    TypeSpecifier::has_field_struct,
                    TypeSpecifier::get_field_struct,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Union>(
                    "union",
                    TypeSpecifier::has_union,
                    TypeSpecifier::get_union,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier_Enum>(
                    "enum",
                    TypeSpecifier::has_field_enum,
                    TypeSpecifier::get_field_enum,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "typedef_name",
                    TypeSpecifier::has_typedef_name,
                    TypeSpecifier::get_typedef_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier>(
                    "TypeSpecifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier,
        };
        unsafe {
            instance.get(TypeSpecifier::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier {
    fn clear(&mut self) {
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Void {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Void {
    fn default() -> &'a TypeSpecifier_Void {
        <TypeSpecifier_Void as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Void {
    pub fn new() -> TypeSpecifier_Void {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Void {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Void {
        TypeSpecifier_Void::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Void>(
                    "TypeSpecifier_Void",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Void {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Void> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Void,
        };
        unsafe {
            instance.get(TypeSpecifier_Void::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Void {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Void {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Void {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Char {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Char {
    fn default() -> &'a TypeSpecifier_Char {
        <TypeSpecifier_Char as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Char {
    pub fn new() -> TypeSpecifier_Char {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Char {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Char {
        TypeSpecifier_Char::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Char>(
                    "TypeSpecifier_Char",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Char {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Char> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Char,
        };
        unsafe {
            instance.get(TypeSpecifier_Char::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Char {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Char {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Char {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Short {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Short {
    fn default() -> &'a TypeSpecifier_Short {
        <TypeSpecifier_Short as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Short {
    pub fn new() -> TypeSpecifier_Short {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Short {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Short {
        TypeSpecifier_Short::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Short>(
                    "TypeSpecifier_Short",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Short {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Short> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Short,
        };
        unsafe {
            instance.get(TypeSpecifier_Short::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Short {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Short {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Short {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Int {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Int {
    fn default() -> &'a TypeSpecifier_Int {
        <TypeSpecifier_Int as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Int {
    pub fn new() -> TypeSpecifier_Int {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Int {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Int {
        TypeSpecifier_Int::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Int>(
                    "TypeSpecifier_Int",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Int {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Int> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Int,
        };
        unsafe {
            instance.get(TypeSpecifier_Int::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Int {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Int {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Int {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Long {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Long {
    fn default() -> &'a TypeSpecifier_Long {
        <TypeSpecifier_Long as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Long {
    pub fn new() -> TypeSpecifier_Long {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Long {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Long {
        TypeSpecifier_Long::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Long>(
                    "TypeSpecifier_Long",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Long {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Long> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Long,
        };
        unsafe {
            instance.get(TypeSpecifier_Long::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Long {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Long {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Long {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Float {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Float {
    fn default() -> &'a TypeSpecifier_Float {
        <TypeSpecifier_Float as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Float {
    pub fn new() -> TypeSpecifier_Float {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Float {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Float {
        TypeSpecifier_Float::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Float>(
                    "TypeSpecifier_Float",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Float {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Float> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Float,
        };
        unsafe {
            instance.get(TypeSpecifier_Float::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Float {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Float {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Float {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Double {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Double {
    fn default() -> &'a TypeSpecifier_Double {
        <TypeSpecifier_Double as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Double {
    pub fn new() -> TypeSpecifier_Double {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Double {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Double {
        TypeSpecifier_Double::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Double>(
                    "TypeSpecifier_Double",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Double {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Double> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Double,
        };
        unsafe {
            instance.get(TypeSpecifier_Double::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Double {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Double {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Double {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Signed {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Signed {
    fn default() -> &'a TypeSpecifier_Signed {
        <TypeSpecifier_Signed as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Signed {
    pub fn new() -> TypeSpecifier_Signed {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Signed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Signed {
        TypeSpecifier_Signed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Signed>(
                    "TypeSpecifier_Signed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Signed {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Signed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Signed,
        };
        unsafe {
            instance.get(TypeSpecifier_Signed::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Signed {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Signed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Signed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Unsigned {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Unsigned {
    fn default() -> &'a TypeSpecifier_Unsigned {
        <TypeSpecifier_Unsigned as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Unsigned {
    pub fn new() -> TypeSpecifier_Unsigned {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TypeSpecifier_Unsigned {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Unsigned {
        TypeSpecifier_Unsigned::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Unsigned>(
                    "TypeSpecifier_Unsigned",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Unsigned {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Unsigned> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Unsigned,
        };
        unsafe {
            instance.get(TypeSpecifier_Unsigned::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Unsigned {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Unsigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Unsigned {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Struct {
    // message fields
    pub name: ::std::string::String,
    pub name_loc: ::protobuf::SingularPtrField<Loc>,
    pub bodies: ::protobuf::RepeatedField<StructDeclaration>,
    pub body_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Struct {
    fn default() -> &'a TypeSpecifier_Struct {
        <TypeSpecifier_Struct as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Struct {
    pub fn new() -> TypeSpecifier_Struct {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc name_loc = 2;


    pub fn get_name_loc(&self) -> &Loc {
        self.name_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_name_loc(&mut self) {
        self.name_loc.clear();
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: Loc) {
        self.name_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut Loc {
        if self.name_loc.is_none() {
            self.name_loc.set_default();
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> Loc {
        self.name_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated .c4.ast.proto.StructDeclaration bodies = 3;


    pub fn get_bodies(&self) -> &[StructDeclaration] {
        &self.bodies
    }
    pub fn clear_bodies(&mut self) {
        self.bodies.clear();
    }

    // Param is passed by value, moved
    pub fn set_bodies(&mut self, v: ::protobuf::RepeatedField<StructDeclaration>) {
        self.bodies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bodies(&mut self) -> &mut ::protobuf::RepeatedField<StructDeclaration> {
        &mut self.bodies
    }

    // Take field
    pub fn take_bodies(&mut self) -> ::protobuf::RepeatedField<StructDeclaration> {
        ::std::mem::replace(&mut self.bodies, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc body_locs = 4;


    pub fn get_body_locs(&self) -> &[Loc] {
        &self.body_locs
    }
    pub fn clear_body_locs(&mut self) {
        self.body_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.body_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.body_locs
    }

    // Take field
    pub fn take_body_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.body_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TypeSpecifier_Struct {
    fn is_initialized(&self) -> bool {
        for v in &self.name_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bodies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bodies)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.body_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bodies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.body_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bodies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.body_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Struct {
        TypeSpecifier_Struct::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TypeSpecifier_Struct| { &m.name },
                    |m: &mut TypeSpecifier_Struct| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "name_loc",
                    |m: &TypeSpecifier_Struct| { &m.name_loc },
                    |m: &mut TypeSpecifier_Struct| { &mut m.name_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructDeclaration>>(
                    "bodies",
                    |m: &TypeSpecifier_Struct| { &m.bodies },
                    |m: &mut TypeSpecifier_Struct| { &mut m.bodies },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_locs",
                    |m: &TypeSpecifier_Struct| { &m.body_locs },
                    |m: &mut TypeSpecifier_Struct| { &mut m.body_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Struct>(
                    "TypeSpecifier_Struct",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Struct {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Struct> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Struct,
        };
        unsafe {
            instance.get(TypeSpecifier_Struct::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Struct {
    fn clear(&mut self) {
        self.name.clear();
        self.name_loc.clear();
        self.bodies.clear();
        self.body_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Struct {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Union {
    // message fields
    pub name: ::std::string::String,
    pub name_loc: ::protobuf::SingularPtrField<Loc>,
    pub bodies: ::protobuf::RepeatedField<StructDeclaration>,
    pub body_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Union {
    fn default() -> &'a TypeSpecifier_Union {
        <TypeSpecifier_Union as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Union {
    pub fn new() -> TypeSpecifier_Union {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc name_loc = 2;


    pub fn get_name_loc(&self) -> &Loc {
        self.name_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_name_loc(&mut self) {
        self.name_loc.clear();
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: Loc) {
        self.name_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut Loc {
        if self.name_loc.is_none() {
            self.name_loc.set_default();
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> Loc {
        self.name_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated .c4.ast.proto.StructDeclaration bodies = 3;


    pub fn get_bodies(&self) -> &[StructDeclaration] {
        &self.bodies
    }
    pub fn clear_bodies(&mut self) {
        self.bodies.clear();
    }

    // Param is passed by value, moved
    pub fn set_bodies(&mut self, v: ::protobuf::RepeatedField<StructDeclaration>) {
        self.bodies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bodies(&mut self) -> &mut ::protobuf::RepeatedField<StructDeclaration> {
        &mut self.bodies
    }

    // Take field
    pub fn take_bodies(&mut self) -> ::protobuf::RepeatedField<StructDeclaration> {
        ::std::mem::replace(&mut self.bodies, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc body_locs = 4;


    pub fn get_body_locs(&self) -> &[Loc] {
        &self.body_locs
    }
    pub fn clear_body_locs(&mut self) {
        self.body_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.body_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.body_locs
    }

    // Take field
    pub fn take_body_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.body_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TypeSpecifier_Union {
    fn is_initialized(&self) -> bool {
        for v in &self.name_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bodies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bodies)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.body_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bodies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.body_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bodies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.body_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Union {
        TypeSpecifier_Union::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TypeSpecifier_Union| { &m.name },
                    |m: &mut TypeSpecifier_Union| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "name_loc",
                    |m: &TypeSpecifier_Union| { &m.name_loc },
                    |m: &mut TypeSpecifier_Union| { &mut m.name_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructDeclaration>>(
                    "bodies",
                    |m: &TypeSpecifier_Union| { &m.bodies },
                    |m: &mut TypeSpecifier_Union| { &mut m.bodies },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_locs",
                    |m: &TypeSpecifier_Union| { &m.body_locs },
                    |m: &mut TypeSpecifier_Union| { &mut m.body_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Union>(
                    "TypeSpecifier_Union",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Union {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Union> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Union,
        };
        unsafe {
            instance.get(TypeSpecifier_Union::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Union {
    fn clear(&mut self) {
        self.name.clear();
        self.name_loc.clear();
        self.bodies.clear();
        self.body_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Union {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Union {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Enum {
    // message fields
    pub name: ::std::string::String,
    pub name_loc: ::protobuf::SingularPtrField<Loc>,
    pub bodies: ::protobuf::RepeatedField<TypeSpecifier_Enum_Body>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Enum {
    fn default() -> &'a TypeSpecifier_Enum {
        <TypeSpecifier_Enum as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Enum {
    pub fn new() -> TypeSpecifier_Enum {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc name_loc = 2;


    pub fn get_name_loc(&self) -> &Loc {
        self.name_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_name_loc(&mut self) {
        self.name_loc.clear();
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: Loc) {
        self.name_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut Loc {
        if self.name_loc.is_none() {
            self.name_loc.set_default();
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> Loc {
        self.name_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated .c4.ast.proto.TypeSpecifier.Enum.Body bodies = 3;


    pub fn get_bodies(&self) -> &[TypeSpecifier_Enum_Body] {
        &self.bodies
    }
    pub fn clear_bodies(&mut self) {
        self.bodies.clear();
    }

    // Param is passed by value, moved
    pub fn set_bodies(&mut self, v: ::protobuf::RepeatedField<TypeSpecifier_Enum_Body>) {
        self.bodies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bodies(&mut self) -> &mut ::protobuf::RepeatedField<TypeSpecifier_Enum_Body> {
        &mut self.bodies
    }

    // Take field
    pub fn take_bodies(&mut self) -> ::protobuf::RepeatedField<TypeSpecifier_Enum_Body> {
        ::std::mem::replace(&mut self.bodies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TypeSpecifier_Enum {
    fn is_initialized(&self) -> bool {
        for v in &self.name_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bodies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bodies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bodies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bodies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Enum {
        TypeSpecifier_Enum::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TypeSpecifier_Enum| { &m.name },
                    |m: &mut TypeSpecifier_Enum| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "name_loc",
                    |m: &TypeSpecifier_Enum| { &m.name_loc },
                    |m: &mut TypeSpecifier_Enum| { &mut m.name_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeSpecifier_Enum_Body>>(
                    "bodies",
                    |m: &TypeSpecifier_Enum| { &m.bodies },
                    |m: &mut TypeSpecifier_Enum| { &mut m.bodies },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Enum>(
                    "TypeSpecifier_Enum",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Enum {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Enum> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Enum,
        };
        unsafe {
            instance.get(TypeSpecifier_Enum::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Enum {
    fn clear(&mut self) {
        self.name.clear();
        self.name_loc.clear();
        self.bodies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Enum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Enum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeSpecifier_Enum_Body {
    // message fields
    pub name: ::std::string::String,
    pub name_loc: ::protobuf::SingularPtrField<Loc>,
    pub value: i32,
    pub value_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeSpecifier_Enum_Body {
    fn default() -> &'a TypeSpecifier_Enum_Body {
        <TypeSpecifier_Enum_Body as ::protobuf::Message>::default_instance()
    }
}

impl TypeSpecifier_Enum_Body {
    pub fn new() -> TypeSpecifier_Enum_Body {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc name_loc = 2;


    pub fn get_name_loc(&self) -> &Loc {
        self.name_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_name_loc(&mut self) {
        self.name_loc.clear();
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: Loc) {
        self.name_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut Loc {
        if self.name_loc.is_none() {
            self.name_loc.set_default();
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> Loc {
        self.name_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 value = 3;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    // .c4.ast.proto.Loc value_loc = 4;


    pub fn get_value_loc(&self) -> &Loc {
        self.value_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_value_loc(&mut self) {
        self.value_loc.clear();
    }

    pub fn has_value_loc(&self) -> bool {
        self.value_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_loc(&mut self, v: Loc) {
        self.value_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_loc(&mut self) -> &mut Loc {
        if self.value_loc.is_none() {
            self.value_loc.set_default();
        }
        self.value_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_loc(&mut self) -> Loc {
        self.value_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for TypeSpecifier_Enum_Body {
    fn is_initialized(&self) -> bool {
        for v in &self.name_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.name_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0 {
            os.write_int32(3, self.value)?;
        }
        if let Some(ref v) = self.value_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeSpecifier_Enum_Body {
        TypeSpecifier_Enum_Body::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TypeSpecifier_Enum_Body| { &m.name },
                    |m: &mut TypeSpecifier_Enum_Body| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "name_loc",
                    |m: &TypeSpecifier_Enum_Body| { &m.name_loc },
                    |m: &mut TypeSpecifier_Enum_Body| { &mut m.name_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &TypeSpecifier_Enum_Body| { &m.value },
                    |m: &mut TypeSpecifier_Enum_Body| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "value_loc",
                    |m: &TypeSpecifier_Enum_Body| { &m.value_loc },
                    |m: &mut TypeSpecifier_Enum_Body| { &mut m.value_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeSpecifier_Enum_Body>(
                    "TypeSpecifier_Enum_Body",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeSpecifier_Enum_Body {
        static mut instance: ::protobuf::lazy::Lazy<TypeSpecifier_Enum_Body> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeSpecifier_Enum_Body,
        };
        unsafe {
            instance.get(TypeSpecifier_Enum_Body::new)
        }
    }
}

impl ::protobuf::Clear for TypeSpecifier_Enum_Body {
    fn clear(&mut self) {
        self.name.clear();
        self.name_loc.clear();
        self.value = 0;
        self.value_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeSpecifier_Enum_Body {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeSpecifier_Enum_Body {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructDeclaration {
    // message fields
    pub sp_qls: ::protobuf::RepeatedField<StructDeclaration_SpQl>,
    pub ds: ::protobuf::RepeatedField<StructDeclaration_Decl>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StructDeclaration {
    fn default() -> &'a StructDeclaration {
        <StructDeclaration as ::protobuf::Message>::default_instance()
    }
}

impl StructDeclaration {
    pub fn new() -> StructDeclaration {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.StructDeclaration.SpQl sp_qls = 1;


    pub fn get_sp_qls(&self) -> &[StructDeclaration_SpQl] {
        &self.sp_qls
    }
    pub fn clear_sp_qls(&mut self) {
        self.sp_qls.clear();
    }

    // Param is passed by value, moved
    pub fn set_sp_qls(&mut self, v: ::protobuf::RepeatedField<StructDeclaration_SpQl>) {
        self.sp_qls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sp_qls(&mut self) -> &mut ::protobuf::RepeatedField<StructDeclaration_SpQl> {
        &mut self.sp_qls
    }

    // Take field
    pub fn take_sp_qls(&mut self) -> ::protobuf::RepeatedField<StructDeclaration_SpQl> {
        ::std::mem::replace(&mut self.sp_qls, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.StructDeclaration.Decl ds = 2;


    pub fn get_ds(&self) -> &[StructDeclaration_Decl] {
        &self.ds
    }
    pub fn clear_ds(&mut self) {
        self.ds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds(&mut self, v: ::protobuf::RepeatedField<StructDeclaration_Decl>) {
        self.ds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ds(&mut self) -> &mut ::protobuf::RepeatedField<StructDeclaration_Decl> {
        &mut self.ds
    }

    // Take field
    pub fn take_ds(&mut self) -> ::protobuf::RepeatedField<StructDeclaration_Decl> {
        ::std::mem::replace(&mut self.ds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StructDeclaration {
    fn is_initialized(&self) -> bool {
        for v in &self.sp_qls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sp_qls)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sp_qls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sp_qls {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ds {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructDeclaration {
        StructDeclaration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructDeclaration_SpQl>>(
                    "sp_qls",
                    |m: &StructDeclaration| { &m.sp_qls },
                    |m: &mut StructDeclaration| { &mut m.sp_qls },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructDeclaration_Decl>>(
                    "ds",
                    |m: &StructDeclaration| { &m.ds },
                    |m: &mut StructDeclaration| { &mut m.ds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructDeclaration>(
                    "StructDeclaration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructDeclaration {
        static mut instance: ::protobuf::lazy::Lazy<StructDeclaration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructDeclaration,
        };
        unsafe {
            instance.get(StructDeclaration::new)
        }
    }
}

impl ::protobuf::Clear for StructDeclaration {
    fn clear(&mut self) {
        self.sp_qls.clear();
        self.ds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructDeclaration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructDeclaration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructDeclaration_SpQl {
    // message fields
    pub loc: ::protobuf::SingularPtrField<Loc>,
    // message oneof groups
    pub elem: ::std::option::Option<StructDeclaration_SpQl_oneof_elem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StructDeclaration_SpQl {
    fn default() -> &'a StructDeclaration_SpQl {
        <StructDeclaration_SpQl as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StructDeclaration_SpQl_oneof_elem {
    sp(TypeSpecifier),
    ql(TypeQualifier),
}

impl StructDeclaration_SpQl {
    pub fn new() -> StructDeclaration_SpQl {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.TypeSpecifier sp = 1;


    pub fn get_sp(&self) -> &TypeSpecifier {
        match self.elem {
            ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(ref v)) => v,
            _ => TypeSpecifier::default_instance(),
        }
    }
    pub fn clear_sp(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_sp(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sp(&mut self, v: TypeSpecifier) {
        self.elem = ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sp(&mut self) -> &mut TypeSpecifier {
        if let ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(_)) = self.elem {
        } else {
            self.elem = ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(TypeSpecifier::new()));
        }
        match self.elem {
            ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sp(&mut self) -> TypeSpecifier {
        if self.has_sp() {
            match self.elem.take() {
                ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier::new()
        }
    }

    // .c4.ast.proto.TypeQualifier ql = 2;


    pub fn get_ql(&self) -> TypeQualifier {
        match self.elem {
            ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::ql(v)) => v,
            _ => TypeQualifier::CONST,
        }
    }
    pub fn clear_ql(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_ql(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::ql(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ql(&mut self, v: TypeQualifier) {
        self.elem = ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::ql(v))
    }

    // .c4.ast.proto.Loc loc = 3;


    pub fn get_loc(&self) -> &Loc {
        self.loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_loc(&mut self) {
        self.loc.clear();
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: Loc) {
        self.loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut Loc {
        if self.loc.is_none() {
            self.loc.set_default();
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> Loc {
        self.loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for StructDeclaration_SpQl {
    fn is_initialized(&self) -> bool {
        if let Some(StructDeclaration_SpQl_oneof_elem::sp(ref v)) = self.elem {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::sp(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(StructDeclaration_SpQl_oneof_elem::ql(is.read_enum()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.elem {
            match v {
                &StructDeclaration_SpQl_oneof_elem::sp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructDeclaration_SpQl_oneof_elem::ql(v) => {
                    my_size += ::protobuf::rt::enum_size(2, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.elem {
            match v {
                &StructDeclaration_SpQl_oneof_elem::sp(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructDeclaration_SpQl_oneof_elem::ql(v) => {
                    os.write_enum(2, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructDeclaration_SpQl {
        StructDeclaration_SpQl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier>(
                    "sp",
                    StructDeclaration_SpQl::has_sp,
                    StructDeclaration_SpQl::get_sp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, TypeQualifier>(
                    "ql",
                    StructDeclaration_SpQl::has_ql,
                    StructDeclaration_SpQl::get_ql,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "loc",
                    |m: &StructDeclaration_SpQl| { &m.loc },
                    |m: &mut StructDeclaration_SpQl| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructDeclaration_SpQl>(
                    "StructDeclaration_SpQl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructDeclaration_SpQl {
        static mut instance: ::protobuf::lazy::Lazy<StructDeclaration_SpQl> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructDeclaration_SpQl,
        };
        unsafe {
            instance.get(StructDeclaration_SpQl::new)
        }
    }
}

impl ::protobuf::Clear for StructDeclaration_SpQl {
    fn clear(&mut self) {
        self.elem = ::std::option::Option::None;
        self.elem = ::std::option::Option::None;
        self.loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructDeclaration_SpQl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructDeclaration_SpQl {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructDeclaration_Decl {
    // message fields
    pub d: ::protobuf::SingularPtrField<Declarator>,
    pub d_loc: ::protobuf::SingularPtrField<Loc>,
    pub e: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StructDeclaration_Decl {
    fn default() -> &'a StructDeclaration_Decl {
        <StructDeclaration_Decl as ::protobuf::Message>::default_instance()
    }
}

impl StructDeclaration_Decl {
    pub fn new() -> StructDeclaration_Decl {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.Declarator d = 1;


    pub fn get_d(&self) -> &Declarator {
        self.d.as_ref().unwrap_or_else(|| Declarator::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: Declarator) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut Declarator {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> Declarator {
        self.d.take().unwrap_or_else(|| Declarator::new())
    }

    // .c4.ast.proto.Loc d_loc = 2;


    pub fn get_d_loc(&self) -> &Loc {
        self.d_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_d_loc(&mut self) {
        self.d_loc.clear();
    }

    pub fn has_d_loc(&self) -> bool {
        self.d_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_loc(&mut self, v: Loc) {
        self.d_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d_loc(&mut self) -> &mut Loc {
        if self.d_loc.is_none() {
            self.d_loc.set_default();
        }
        self.d_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_d_loc(&mut self) -> Loc {
        self.d_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 e = 3;


    pub fn get_e(&self) -> i32 {
        self.e
    }
    pub fn clear_e(&mut self) {
        self.e = 0;
    }

    // Param is passed by value, moved
    pub fn set_e(&mut self, v: i32) {
        self.e = v;
    }

    // .c4.ast.proto.Loc e_loc = 4;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for StructDeclaration_Decl {
    fn is_initialized(&self) -> bool {
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.e != 0 {
            my_size += ::protobuf::rt::value_size(3, self.e, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.e != 0 {
            os.write_int32(3, self.e)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructDeclaration_Decl {
        StructDeclaration_Decl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declarator>>(
                    "d",
                    |m: &StructDeclaration_Decl| { &m.d },
                    |m: &mut StructDeclaration_Decl| { &mut m.d },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "d_loc",
                    |m: &StructDeclaration_Decl| { &m.d_loc },
                    |m: &mut StructDeclaration_Decl| { &mut m.d_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e",
                    |m: &StructDeclaration_Decl| { &m.e },
                    |m: &mut StructDeclaration_Decl| { &mut m.e },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &StructDeclaration_Decl| { &m.e_loc },
                    |m: &mut StructDeclaration_Decl| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructDeclaration_Decl>(
                    "StructDeclaration_Decl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructDeclaration_Decl {
        static mut instance: ::protobuf::lazy::Lazy<StructDeclaration_Decl> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructDeclaration_Decl,
        };
        unsafe {
            instance.get(StructDeclaration_Decl::new)
        }
    }
}

impl ::protobuf::Clear for StructDeclaration_Decl {
    fn clear(&mut self) {
        self.d.clear();
        self.d_loc.clear();
        self.e = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructDeclaration_Decl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructDeclaration_Decl {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Declarator {
    // message fields
    pub ptr_idx: i32,
    pub ptr_loc: ::protobuf::SingularPtrField<Loc>,
    pub dd_idx: i32,
    pub dd_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Declarator {
    fn default() -> &'a Declarator {
        <Declarator as ::protobuf::Message>::default_instance()
    }
}

impl Declarator {
    pub fn new() -> Declarator {
        ::std::default::Default::default()
    }

    // int32 ptr_idx = 1;


    pub fn get_ptr_idx(&self) -> i32 {
        self.ptr_idx
    }
    pub fn clear_ptr_idx(&mut self) {
        self.ptr_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_ptr_idx(&mut self, v: i32) {
        self.ptr_idx = v;
    }

    // .c4.ast.proto.Loc ptr_loc = 2;


    pub fn get_ptr_loc(&self) -> &Loc {
        self.ptr_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ptr_loc(&mut self) {
        self.ptr_loc.clear();
    }

    pub fn has_ptr_loc(&self) -> bool {
        self.ptr_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ptr_loc(&mut self, v: Loc) {
        self.ptr_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ptr_loc(&mut self) -> &mut Loc {
        if self.ptr_loc.is_none() {
            self.ptr_loc.set_default();
        }
        self.ptr_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ptr_loc(&mut self) -> Loc {
        self.ptr_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 dd_idx = 3;


    pub fn get_dd_idx(&self) -> i32 {
        self.dd_idx
    }
    pub fn clear_dd_idx(&mut self) {
        self.dd_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dd_idx(&mut self, v: i32) {
        self.dd_idx = v;
    }

    // .c4.ast.proto.Loc dd_loc = 4;


    pub fn get_dd_loc(&self) -> &Loc {
        self.dd_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dd_loc(&mut self) {
        self.dd_loc.clear();
    }

    pub fn has_dd_loc(&self) -> bool {
        self.dd_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dd_loc(&mut self, v: Loc) {
        self.dd_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dd_loc(&mut self) -> &mut Loc {
        if self.dd_loc.is_none() {
            self.dd_loc.set_default();
        }
        self.dd_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dd_loc(&mut self) -> Loc {
        self.dd_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Declarator {
    fn is_initialized(&self) -> bool {
        for v in &self.ptr_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dd_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ptr_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ptr_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dd_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dd_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ptr_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ptr_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ptr_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.dd_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dd_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ptr_idx != 0 {
            os.write_int32(1, self.ptr_idx)?;
        }
        if let Some(ref v) = self.ptr_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.dd_idx != 0 {
            os.write_int32(3, self.dd_idx)?;
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Declarator {
        Declarator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ptr_idx",
                    |m: &Declarator| { &m.ptr_idx },
                    |m: &mut Declarator| { &mut m.ptr_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ptr_loc",
                    |m: &Declarator| { &m.ptr_loc },
                    |m: &mut Declarator| { &mut m.ptr_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dd_idx",
                    |m: &Declarator| { &m.dd_idx },
                    |m: &mut Declarator| { &mut m.dd_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dd_loc",
                    |m: &Declarator| { &m.dd_loc },
                    |m: &mut Declarator| { &mut m.dd_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Declarator>(
                    "Declarator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Declarator {
        static mut instance: ::protobuf::lazy::Lazy<Declarator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Declarator,
        };
        unsafe {
            instance.get(Declarator::new)
        }
    }
}

impl ::protobuf::Clear for Declarator {
    fn clear(&mut self) {
        self.ptr_idx = 0;
        self.ptr_loc.clear();
        self.dd_idx = 0;
        self.dd_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Declarator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Declarator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectDeclarator {
    // message oneof groups
    pub dd: ::std::option::Option<DirectDeclarator_oneof_dd>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectDeclarator {
    fn default() -> &'a DirectDeclarator {
        <DirectDeclarator as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DirectDeclarator_oneof_dd {
    id(DirectDeclarator_Id),
    d(DirectDeclarator_Declarator),
    array(DirectDeclarator_Array),
    ft(DirectDeclarator_FuncType),
    ids_list(DirectDeclarator_IdsList),
}

impl DirectDeclarator {
    pub fn new() -> DirectDeclarator {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.DirectDeclarator.Id id = 1;


    pub fn get_id(&self) -> &DirectDeclarator_Id {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(ref v)) => v,
            _ => DirectDeclarator_Id::default_instance(),
        }
    }
    pub fn clear_id(&mut self) {
        self.dd = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: DirectDeclarator_Id) {
        self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut DirectDeclarator_Id {
        if let ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(_)) = self.dd {
        } else {
            self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(DirectDeclarator_Id::new()));
        }
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> DirectDeclarator_Id {
        if self.has_id() {
            match self.dd.take() {
                ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectDeclarator_Id::new()
        }
    }

    // .c4.ast.proto.DirectDeclarator.Declarator d = 2;


    pub fn get_d(&self) -> &DirectDeclarator_Declarator {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(ref v)) => v,
            _ => DirectDeclarator_Declarator::default_instance(),
        }
    }
    pub fn clear_d(&mut self) {
        self.dd = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: DirectDeclarator_Declarator) {
        self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(v))
    }

    // Mutable pointer to the field.
    pub fn mut_d(&mut self) -> &mut DirectDeclarator_Declarator {
        if let ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(_)) = self.dd {
        } else {
            self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(DirectDeclarator_Declarator::new()));
        }
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_d(&mut self) -> DirectDeclarator_Declarator {
        if self.has_d() {
            match self.dd.take() {
                ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectDeclarator_Declarator::new()
        }
    }

    // .c4.ast.proto.DirectDeclarator.Array array = 3;


    pub fn get_array(&self) -> &DirectDeclarator_Array {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(ref v)) => v,
            _ => DirectDeclarator_Array::default_instance(),
        }
    }
    pub fn clear_array(&mut self) {
        self.dd = ::std::option::Option::None;
    }

    pub fn has_array(&self) -> bool {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_array(&mut self, v: DirectDeclarator_Array) {
        self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_array(&mut self) -> &mut DirectDeclarator_Array {
        if let ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(_)) = self.dd {
        } else {
            self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(DirectDeclarator_Array::new()));
        }
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_array(&mut self) -> DirectDeclarator_Array {
        if self.has_array() {
            match self.dd.take() {
                ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectDeclarator_Array::new()
        }
    }

    // .c4.ast.proto.DirectDeclarator.FuncType ft = 4;


    pub fn get_ft(&self) -> &DirectDeclarator_FuncType {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(ref v)) => v,
            _ => DirectDeclarator_FuncType::default_instance(),
        }
    }
    pub fn clear_ft(&mut self) {
        self.dd = ::std::option::Option::None;
    }

    pub fn has_ft(&self) -> bool {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ft(&mut self, v: DirectDeclarator_FuncType) {
        self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ft(&mut self) -> &mut DirectDeclarator_FuncType {
        if let ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(_)) = self.dd {
        } else {
            self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(DirectDeclarator_FuncType::new()));
        }
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ft(&mut self) -> DirectDeclarator_FuncType {
        if self.has_ft() {
            match self.dd.take() {
                ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectDeclarator_FuncType::new()
        }
    }

    // .c4.ast.proto.DirectDeclarator.IdsList ids_list = 5;


    pub fn get_ids_list(&self) -> &DirectDeclarator_IdsList {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(ref v)) => v,
            _ => DirectDeclarator_IdsList::default_instance(),
        }
    }
    pub fn clear_ids_list(&mut self) {
        self.dd = ::std::option::Option::None;
    }

    pub fn has_ids_list(&self) -> bool {
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ids_list(&mut self, v: DirectDeclarator_IdsList) {
        self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ids_list(&mut self) -> &mut DirectDeclarator_IdsList {
        if let ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(_)) = self.dd {
        } else {
            self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(DirectDeclarator_IdsList::new()));
        }
        match self.dd {
            ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ids_list(&mut self) -> DirectDeclarator_IdsList {
        if self.has_ids_list() {
            match self.dd.take() {
                ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectDeclarator_IdsList::new()
        }
    }
}

impl ::protobuf::Message for DirectDeclarator {
    fn is_initialized(&self) -> bool {
        if let Some(DirectDeclarator_oneof_dd::id(ref v)) = self.dd {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DirectDeclarator_oneof_dd::d(ref v)) = self.dd {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DirectDeclarator_oneof_dd::array(ref v)) = self.dd {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DirectDeclarator_oneof_dd::ft(ref v)) = self.dd {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DirectDeclarator_oneof_dd::ids_list(ref v)) = self.dd {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::id(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::d(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::array(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::ft(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dd = ::std::option::Option::Some(DirectDeclarator_oneof_dd::ids_list(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.dd {
            match v {
                &DirectDeclarator_oneof_dd::id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DirectDeclarator_oneof_dd::d(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DirectDeclarator_oneof_dd::array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DirectDeclarator_oneof_dd::ft(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DirectDeclarator_oneof_dd::ids_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.dd {
            match v {
                &DirectDeclarator_oneof_dd::id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DirectDeclarator_oneof_dd::d(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DirectDeclarator_oneof_dd::array(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DirectDeclarator_oneof_dd::ft(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DirectDeclarator_oneof_dd::ids_list(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectDeclarator {
        DirectDeclarator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectDeclarator_Id>(
                    "id",
                    DirectDeclarator::has_id,
                    DirectDeclarator::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectDeclarator_Declarator>(
                    "d",
                    DirectDeclarator::has_d,
                    DirectDeclarator::get_d,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectDeclarator_Array>(
                    "array",
                    DirectDeclarator::has_array,
                    DirectDeclarator::get_array,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectDeclarator_FuncType>(
                    "ft",
                    DirectDeclarator::has_ft,
                    DirectDeclarator::get_ft,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectDeclarator_IdsList>(
                    "ids_list",
                    DirectDeclarator::has_ids_list,
                    DirectDeclarator::get_ids_list,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectDeclarator>(
                    "DirectDeclarator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectDeclarator {
        static mut instance: ::protobuf::lazy::Lazy<DirectDeclarator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectDeclarator,
        };
        unsafe {
            instance.get(DirectDeclarator::new)
        }
    }
}

impl ::protobuf::Clear for DirectDeclarator {
    fn clear(&mut self) {
        self.dd = ::std::option::Option::None;
        self.dd = ::std::option::Option::None;
        self.dd = ::std::option::Option::None;
        self.dd = ::std::option::Option::None;
        self.dd = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectDeclarator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectDeclarator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectDeclarator_Id {
    // message fields
    pub id: ::std::string::String,
    pub loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectDeclarator_Id {
    fn default() -> &'a DirectDeclarator_Id {
        <DirectDeclarator_Id as ::protobuf::Message>::default_instance()
    }
}

impl DirectDeclarator_Id {
    pub fn new() -> DirectDeclarator_Id {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc loc = 2;


    pub fn get_loc(&self) -> &Loc {
        self.loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_loc(&mut self) {
        self.loc.clear();
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: Loc) {
        self.loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut Loc {
        if self.loc.is_none() {
            self.loc.set_default();
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> Loc {
        self.loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectDeclarator_Id {
    fn is_initialized(&self) -> bool {
        for v in &self.loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectDeclarator_Id {
        DirectDeclarator_Id::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &DirectDeclarator_Id| { &m.id },
                    |m: &mut DirectDeclarator_Id| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "loc",
                    |m: &DirectDeclarator_Id| { &m.loc },
                    |m: &mut DirectDeclarator_Id| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectDeclarator_Id>(
                    "DirectDeclarator_Id",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectDeclarator_Id {
        static mut instance: ::protobuf::lazy::Lazy<DirectDeclarator_Id> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectDeclarator_Id,
        };
        unsafe {
            instance.get(DirectDeclarator_Id::new)
        }
    }
}

impl ::protobuf::Clear for DirectDeclarator_Id {
    fn clear(&mut self) {
        self.id.clear();
        self.loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectDeclarator_Id {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectDeclarator_Id {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectDeclarator_Declarator {
    // message fields
    pub d: ::protobuf::SingularPtrField<Declarator>,
    pub loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectDeclarator_Declarator {
    fn default() -> &'a DirectDeclarator_Declarator {
        <DirectDeclarator_Declarator as ::protobuf::Message>::default_instance()
    }
}

impl DirectDeclarator_Declarator {
    pub fn new() -> DirectDeclarator_Declarator {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.Declarator d = 1;


    pub fn get_d(&self) -> &Declarator {
        self.d.as_ref().unwrap_or_else(|| Declarator::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: Declarator) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut Declarator {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> Declarator {
        self.d.take().unwrap_or_else(|| Declarator::new())
    }

    // .c4.ast.proto.Loc loc = 2;


    pub fn get_loc(&self) -> &Loc {
        self.loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_loc(&mut self) {
        self.loc.clear();
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: Loc) {
        self.loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut Loc {
        if self.loc.is_none() {
            self.loc.set_default();
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> Loc {
        self.loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectDeclarator_Declarator {
    fn is_initialized(&self) -> bool {
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectDeclarator_Declarator {
        DirectDeclarator_Declarator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declarator>>(
                    "d",
                    |m: &DirectDeclarator_Declarator| { &m.d },
                    |m: &mut DirectDeclarator_Declarator| { &mut m.d },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "loc",
                    |m: &DirectDeclarator_Declarator| { &m.loc },
                    |m: &mut DirectDeclarator_Declarator| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectDeclarator_Declarator>(
                    "DirectDeclarator_Declarator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectDeclarator_Declarator {
        static mut instance: ::protobuf::lazy::Lazy<DirectDeclarator_Declarator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectDeclarator_Declarator,
        };
        unsafe {
            instance.get(DirectDeclarator_Declarator::new)
        }
    }
}

impl ::protobuf::Clear for DirectDeclarator_Declarator {
    fn clear(&mut self) {
        self.d.clear();
        self.loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectDeclarator_Declarator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectDeclarator_Declarator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectDeclarator_Array {
    // message fields
    pub dd_idx: i32,
    pub dd_loc: ::protobuf::SingularPtrField<Loc>,
    pub size_idx: i32,
    pub size_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectDeclarator_Array {
    fn default() -> &'a DirectDeclarator_Array {
        <DirectDeclarator_Array as ::protobuf::Message>::default_instance()
    }
}

impl DirectDeclarator_Array {
    pub fn new() -> DirectDeclarator_Array {
        ::std::default::Default::default()
    }

    // int32 dd_idx = 1;


    pub fn get_dd_idx(&self) -> i32 {
        self.dd_idx
    }
    pub fn clear_dd_idx(&mut self) {
        self.dd_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dd_idx(&mut self, v: i32) {
        self.dd_idx = v;
    }

    // .c4.ast.proto.Loc dd_loc = 2;


    pub fn get_dd_loc(&self) -> &Loc {
        self.dd_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dd_loc(&mut self) {
        self.dd_loc.clear();
    }

    pub fn has_dd_loc(&self) -> bool {
        self.dd_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dd_loc(&mut self, v: Loc) {
        self.dd_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dd_loc(&mut self) -> &mut Loc {
        if self.dd_loc.is_none() {
            self.dd_loc.set_default();
        }
        self.dd_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dd_loc(&mut self) -> Loc {
        self.dd_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 size_idx = 3;


    pub fn get_size_idx(&self) -> i32 {
        self.size_idx
    }
    pub fn clear_size_idx(&mut self) {
        self.size_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_idx(&mut self, v: i32) {
        self.size_idx = v;
    }

    // .c4.ast.proto.Loc size_loc = 4;


    pub fn get_size_loc(&self) -> &Loc {
        self.size_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_size_loc(&mut self) {
        self.size_loc.clear();
    }

    pub fn has_size_loc(&self) -> bool {
        self.size_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_loc(&mut self, v: Loc) {
        self.size_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size_loc(&mut self) -> &mut Loc {
        if self.size_loc.is_none() {
            self.size_loc.set_default();
        }
        self.size_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_size_loc(&mut self) -> Loc {
        self.size_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectDeclarator_Array {
    fn is_initialized(&self) -> bool {
        for v in &self.dd_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.size_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dd_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dd_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dd_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dd_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.size_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dd_idx != 0 {
            os.write_int32(1, self.dd_idx)?;
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size_idx != 0 {
            os.write_int32(3, self.size_idx)?;
        }
        if let Some(ref v) = self.size_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectDeclarator_Array {
        DirectDeclarator_Array::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dd_idx",
                    |m: &DirectDeclarator_Array| { &m.dd_idx },
                    |m: &mut DirectDeclarator_Array| { &mut m.dd_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dd_loc",
                    |m: &DirectDeclarator_Array| { &m.dd_loc },
                    |m: &mut DirectDeclarator_Array| { &mut m.dd_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "size_idx",
                    |m: &DirectDeclarator_Array| { &m.size_idx },
                    |m: &mut DirectDeclarator_Array| { &mut m.size_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "size_loc",
                    |m: &DirectDeclarator_Array| { &m.size_loc },
                    |m: &mut DirectDeclarator_Array| { &mut m.size_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectDeclarator_Array>(
                    "DirectDeclarator_Array",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectDeclarator_Array {
        static mut instance: ::protobuf::lazy::Lazy<DirectDeclarator_Array> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectDeclarator_Array,
        };
        unsafe {
            instance.get(DirectDeclarator_Array::new)
        }
    }
}

impl ::protobuf::Clear for DirectDeclarator_Array {
    fn clear(&mut self) {
        self.dd_idx = 0;
        self.dd_loc.clear();
        self.size_idx = 0;
        self.size_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectDeclarator_Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectDeclarator_Array {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectDeclarator_FuncType {
    // message fields
    pub dd_idx: i32,
    pub dd_loc: ::protobuf::SingularPtrField<Loc>,
    pub pds: ::protobuf::RepeatedField<ParamDeclaration>,
    pub pd_locs: ::protobuf::RepeatedField<Loc>,
    pub has_ellipsis: bool,
    pub ellipsis_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectDeclarator_FuncType {
    fn default() -> &'a DirectDeclarator_FuncType {
        <DirectDeclarator_FuncType as ::protobuf::Message>::default_instance()
    }
}

impl DirectDeclarator_FuncType {
    pub fn new() -> DirectDeclarator_FuncType {
        ::std::default::Default::default()
    }

    // int32 dd_idx = 1;


    pub fn get_dd_idx(&self) -> i32 {
        self.dd_idx
    }
    pub fn clear_dd_idx(&mut self) {
        self.dd_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dd_idx(&mut self, v: i32) {
        self.dd_idx = v;
    }

    // .c4.ast.proto.Loc dd_loc = 2;


    pub fn get_dd_loc(&self) -> &Loc {
        self.dd_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dd_loc(&mut self) {
        self.dd_loc.clear();
    }

    pub fn has_dd_loc(&self) -> bool {
        self.dd_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dd_loc(&mut self, v: Loc) {
        self.dd_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dd_loc(&mut self) -> &mut Loc {
        if self.dd_loc.is_none() {
            self.dd_loc.set_default();
        }
        self.dd_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dd_loc(&mut self) -> Loc {
        self.dd_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated .c4.ast.proto.ParamDeclaration pds = 3;


    pub fn get_pds(&self) -> &[ParamDeclaration] {
        &self.pds
    }
    pub fn clear_pds(&mut self) {
        self.pds.clear();
    }

    // Param is passed by value, moved
    pub fn set_pds(&mut self, v: ::protobuf::RepeatedField<ParamDeclaration>) {
        self.pds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pds(&mut self) -> &mut ::protobuf::RepeatedField<ParamDeclaration> {
        &mut self.pds
    }

    // Take field
    pub fn take_pds(&mut self) -> ::protobuf::RepeatedField<ParamDeclaration> {
        ::std::mem::replace(&mut self.pds, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc pd_locs = 4;


    pub fn get_pd_locs(&self) -> &[Loc] {
        &self.pd_locs
    }
    pub fn clear_pd_locs(&mut self) {
        self.pd_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pd_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.pd_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pd_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.pd_locs
    }

    // Take field
    pub fn take_pd_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.pd_locs, ::protobuf::RepeatedField::new())
    }

    // bool has_ellipsis = 5;


    pub fn get_has_ellipsis(&self) -> bool {
        self.has_ellipsis
    }
    pub fn clear_has_ellipsis(&mut self) {
        self.has_ellipsis = false;
    }

    // Param is passed by value, moved
    pub fn set_has_ellipsis(&mut self, v: bool) {
        self.has_ellipsis = v;
    }

    // .c4.ast.proto.Loc ellipsis_loc = 6;


    pub fn get_ellipsis_loc(&self) -> &Loc {
        self.ellipsis_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ellipsis_loc(&mut self) {
        self.ellipsis_loc.clear();
    }

    pub fn has_ellipsis_loc(&self) -> bool {
        self.ellipsis_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ellipsis_loc(&mut self, v: Loc) {
        self.ellipsis_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ellipsis_loc(&mut self) -> &mut Loc {
        if self.ellipsis_loc.is_none() {
            self.ellipsis_loc.set_default();
        }
        self.ellipsis_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ellipsis_loc(&mut self) -> Loc {
        self.ellipsis_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectDeclarator_FuncType {
    fn is_initialized(&self) -> bool {
        for v in &self.dd_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pd_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ellipsis_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dd_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dd_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pd_locs)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_ellipsis = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ellipsis_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dd_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dd_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pd_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.has_ellipsis != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ellipsis_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dd_idx != 0 {
            os.write_int32(1, self.dd_idx)?;
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pd_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.has_ellipsis != false {
            os.write_bool(5, self.has_ellipsis)?;
        }
        if let Some(ref v) = self.ellipsis_loc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectDeclarator_FuncType {
        DirectDeclarator_FuncType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dd_idx",
                    |m: &DirectDeclarator_FuncType| { &m.dd_idx },
                    |m: &mut DirectDeclarator_FuncType| { &mut m.dd_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dd_loc",
                    |m: &DirectDeclarator_FuncType| { &m.dd_loc },
                    |m: &mut DirectDeclarator_FuncType| { &mut m.dd_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ParamDeclaration>>(
                    "pds",
                    |m: &DirectDeclarator_FuncType| { &m.pds },
                    |m: &mut DirectDeclarator_FuncType| { &mut m.pds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "pd_locs",
                    |m: &DirectDeclarator_FuncType| { &m.pd_locs },
                    |m: &mut DirectDeclarator_FuncType| { &mut m.pd_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_ellipsis",
                    |m: &DirectDeclarator_FuncType| { &m.has_ellipsis },
                    |m: &mut DirectDeclarator_FuncType| { &mut m.has_ellipsis },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ellipsis_loc",
                    |m: &DirectDeclarator_FuncType| { &m.ellipsis_loc },
                    |m: &mut DirectDeclarator_FuncType| { &mut m.ellipsis_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectDeclarator_FuncType>(
                    "DirectDeclarator_FuncType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectDeclarator_FuncType {
        static mut instance: ::protobuf::lazy::Lazy<DirectDeclarator_FuncType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectDeclarator_FuncType,
        };
        unsafe {
            instance.get(DirectDeclarator_FuncType::new)
        }
    }
}

impl ::protobuf::Clear for DirectDeclarator_FuncType {
    fn clear(&mut self) {
        self.dd_idx = 0;
        self.dd_loc.clear();
        self.pds.clear();
        self.pd_locs.clear();
        self.has_ellipsis = false;
        self.ellipsis_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectDeclarator_FuncType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectDeclarator_FuncType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectDeclarator_IdsList {
    // message fields
    pub dd_idx: i32,
    pub dd_loc: ::protobuf::SingularPtrField<Loc>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub id_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectDeclarator_IdsList {
    fn default() -> &'a DirectDeclarator_IdsList {
        <DirectDeclarator_IdsList as ::protobuf::Message>::default_instance()
    }
}

impl DirectDeclarator_IdsList {
    pub fn new() -> DirectDeclarator_IdsList {
        ::std::default::Default::default()
    }

    // int32 dd_idx = 1;


    pub fn get_dd_idx(&self) -> i32 {
        self.dd_idx
    }
    pub fn clear_dd_idx(&mut self) {
        self.dd_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dd_idx(&mut self, v: i32) {
        self.dd_idx = v;
    }

    // .c4.ast.proto.Loc dd_loc = 2;


    pub fn get_dd_loc(&self) -> &Loc {
        self.dd_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dd_loc(&mut self) {
        self.dd_loc.clear();
    }

    pub fn has_dd_loc(&self) -> bool {
        self.dd_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dd_loc(&mut self, v: Loc) {
        self.dd_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dd_loc(&mut self) -> &mut Loc {
        if self.dd_loc.is_none() {
            self.dd_loc.set_default();
        }
        self.dd_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dd_loc(&mut self) -> Loc {
        self.dd_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated string ids = 3;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc id_locs = 4;


    pub fn get_id_locs(&self) -> &[Loc] {
        &self.id_locs
    }
    pub fn clear_id_locs(&mut self) {
        self.id_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.id_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.id_locs
    }

    // Take field
    pub fn take_id_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.id_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DirectDeclarator_IdsList {
    fn is_initialized(&self) -> bool {
        for v in &self.dd_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dd_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dd_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.id_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dd_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dd_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.id_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dd_idx != 0 {
            os.write_int32(1, self.dd_idx)?;
        }
        if let Some(ref v) = self.dd_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        for v in &self.id_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectDeclarator_IdsList {
        DirectDeclarator_IdsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dd_idx",
                    |m: &DirectDeclarator_IdsList| { &m.dd_idx },
                    |m: &mut DirectDeclarator_IdsList| { &mut m.dd_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dd_loc",
                    |m: &DirectDeclarator_IdsList| { &m.dd_loc },
                    |m: &mut DirectDeclarator_IdsList| { &mut m.dd_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &DirectDeclarator_IdsList| { &m.ids },
                    |m: &mut DirectDeclarator_IdsList| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "id_locs",
                    |m: &DirectDeclarator_IdsList| { &m.id_locs },
                    |m: &mut DirectDeclarator_IdsList| { &mut m.id_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectDeclarator_IdsList>(
                    "DirectDeclarator_IdsList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectDeclarator_IdsList {
        static mut instance: ::protobuf::lazy::Lazy<DirectDeclarator_IdsList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectDeclarator_IdsList,
        };
        unsafe {
            instance.get(DirectDeclarator_IdsList::new)
        }
    }
}

impl ::protobuf::Clear for DirectDeclarator_IdsList {
    fn clear(&mut self) {
        self.dd_idx = 0;
        self.dd_loc.clear();
        self.ids.clear();
        self.id_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectDeclarator_IdsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectDeclarator_IdsList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbstractDeclarator {
    // message fields
    pub ptr_idx: i32,
    pub ptr_loc: ::protobuf::SingularPtrField<Loc>,
    pub dad_idx: i32,
    pub dad_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbstractDeclarator {
    fn default() -> &'a AbstractDeclarator {
        <AbstractDeclarator as ::protobuf::Message>::default_instance()
    }
}

impl AbstractDeclarator {
    pub fn new() -> AbstractDeclarator {
        ::std::default::Default::default()
    }

    // int32 ptr_idx = 1;


    pub fn get_ptr_idx(&self) -> i32 {
        self.ptr_idx
    }
    pub fn clear_ptr_idx(&mut self) {
        self.ptr_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_ptr_idx(&mut self, v: i32) {
        self.ptr_idx = v;
    }

    // .c4.ast.proto.Loc ptr_loc = 2;


    pub fn get_ptr_loc(&self) -> &Loc {
        self.ptr_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ptr_loc(&mut self) {
        self.ptr_loc.clear();
    }

    pub fn has_ptr_loc(&self) -> bool {
        self.ptr_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ptr_loc(&mut self, v: Loc) {
        self.ptr_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ptr_loc(&mut self) -> &mut Loc {
        if self.ptr_loc.is_none() {
            self.ptr_loc.set_default();
        }
        self.ptr_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ptr_loc(&mut self) -> Loc {
        self.ptr_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 dad_idx = 3;


    pub fn get_dad_idx(&self) -> i32 {
        self.dad_idx
    }
    pub fn clear_dad_idx(&mut self) {
        self.dad_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dad_idx(&mut self, v: i32) {
        self.dad_idx = v;
    }

    // .c4.ast.proto.Loc dad_loc = 4;


    pub fn get_dad_loc(&self) -> &Loc {
        self.dad_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dad_loc(&mut self) {
        self.dad_loc.clear();
    }

    pub fn has_dad_loc(&self) -> bool {
        self.dad_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dad_loc(&mut self, v: Loc) {
        self.dad_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dad_loc(&mut self) -> &mut Loc {
        if self.dad_loc.is_none() {
            self.dad_loc.set_default();
        }
        self.dad_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dad_loc(&mut self) -> Loc {
        self.dad_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for AbstractDeclarator {
    fn is_initialized(&self) -> bool {
        for v in &self.ptr_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dad_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ptr_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ptr_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dad_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dad_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ptr_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ptr_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ptr_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.dad_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dad_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dad_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ptr_idx != 0 {
            os.write_int32(1, self.ptr_idx)?;
        }
        if let Some(ref v) = self.ptr_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.dad_idx != 0 {
            os.write_int32(3, self.dad_idx)?;
        }
        if let Some(ref v) = self.dad_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbstractDeclarator {
        AbstractDeclarator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ptr_idx",
                    |m: &AbstractDeclarator| { &m.ptr_idx },
                    |m: &mut AbstractDeclarator| { &mut m.ptr_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ptr_loc",
                    |m: &AbstractDeclarator| { &m.ptr_loc },
                    |m: &mut AbstractDeclarator| { &mut m.ptr_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dad_idx",
                    |m: &AbstractDeclarator| { &m.dad_idx },
                    |m: &mut AbstractDeclarator| { &mut m.dad_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dad_loc",
                    |m: &AbstractDeclarator| { &m.dad_loc },
                    |m: &mut AbstractDeclarator| { &mut m.dad_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbstractDeclarator>(
                    "AbstractDeclarator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbstractDeclarator {
        static mut instance: ::protobuf::lazy::Lazy<AbstractDeclarator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbstractDeclarator,
        };
        unsafe {
            instance.get(AbstractDeclarator::new)
        }
    }
}

impl ::protobuf::Clear for AbstractDeclarator {
    fn clear(&mut self) {
        self.ptr_idx = 0;
        self.ptr_loc.clear();
        self.dad_idx = 0;
        self.dad_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbstractDeclarator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbstractDeclarator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectAbstractDeclarator {
    // message oneof groups
    pub dad: ::std::option::Option<DirectAbstractDeclarator_oneof_dad>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectAbstractDeclarator {
    fn default() -> &'a DirectAbstractDeclarator {
        <DirectAbstractDeclarator as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DirectAbstractDeclarator_oneof_dad {
    simple(DirectAbstractDeclarator_Simple),
    array(DirectAbstractDeclarator_Array),
    func(DirectAbstractDeclarator_Func),
}

impl DirectAbstractDeclarator {
    pub fn new() -> DirectAbstractDeclarator {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.DirectAbstractDeclarator.Simple simple = 1;


    pub fn get_simple(&self) -> &DirectAbstractDeclarator_Simple {
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(ref v)) => v,
            _ => DirectAbstractDeclarator_Simple::default_instance(),
        }
    }
    pub fn clear_simple(&mut self) {
        self.dad = ::std::option::Option::None;
    }

    pub fn has_simple(&self) -> bool {
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple(&mut self, v: DirectAbstractDeclarator_Simple) {
        self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(v))
    }

    // Mutable pointer to the field.
    pub fn mut_simple(&mut self) -> &mut DirectAbstractDeclarator_Simple {
        if let ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(_)) = self.dad {
        } else {
            self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(DirectAbstractDeclarator_Simple::new()));
        }
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_simple(&mut self) -> DirectAbstractDeclarator_Simple {
        if self.has_simple() {
            match self.dad.take() {
                ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectAbstractDeclarator_Simple::new()
        }
    }

    // .c4.ast.proto.DirectAbstractDeclarator.Array array = 2;


    pub fn get_array(&self) -> &DirectAbstractDeclarator_Array {
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(ref v)) => v,
            _ => DirectAbstractDeclarator_Array::default_instance(),
        }
    }
    pub fn clear_array(&mut self) {
        self.dad = ::std::option::Option::None;
    }

    pub fn has_array(&self) -> bool {
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_array(&mut self, v: DirectAbstractDeclarator_Array) {
        self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_array(&mut self) -> &mut DirectAbstractDeclarator_Array {
        if let ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(_)) = self.dad {
        } else {
            self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(DirectAbstractDeclarator_Array::new()));
        }
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_array(&mut self) -> DirectAbstractDeclarator_Array {
        if self.has_array() {
            match self.dad.take() {
                ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectAbstractDeclarator_Array::new()
        }
    }

    // .c4.ast.proto.DirectAbstractDeclarator.Func func = 3;


    pub fn get_func(&self) -> &DirectAbstractDeclarator_Func {
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(ref v)) => v,
            _ => DirectAbstractDeclarator_Func::default_instance(),
        }
    }
    pub fn clear_func(&mut self) {
        self.dad = ::std::option::Option::None;
    }

    pub fn has_func(&self) -> bool {
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: DirectAbstractDeclarator_Func) {
        self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func(&mut self) -> &mut DirectAbstractDeclarator_Func {
        if let ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(_)) = self.dad {
        } else {
            self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(DirectAbstractDeclarator_Func::new()));
        }
        match self.dad {
            ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func(&mut self) -> DirectAbstractDeclarator_Func {
        if self.has_func() {
            match self.dad.take() {
                ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectAbstractDeclarator_Func::new()
        }
    }
}

impl ::protobuf::Message for DirectAbstractDeclarator {
    fn is_initialized(&self) -> bool {
        if let Some(DirectAbstractDeclarator_oneof_dad::simple(ref v)) = self.dad {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DirectAbstractDeclarator_oneof_dad::array(ref v)) = self.dad {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DirectAbstractDeclarator_oneof_dad::func(ref v)) = self.dad {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::simple(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::array(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dad = ::std::option::Option::Some(DirectAbstractDeclarator_oneof_dad::func(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.dad {
            match v {
                &DirectAbstractDeclarator_oneof_dad::simple(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DirectAbstractDeclarator_oneof_dad::array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DirectAbstractDeclarator_oneof_dad::func(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.dad {
            match v {
                &DirectAbstractDeclarator_oneof_dad::simple(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DirectAbstractDeclarator_oneof_dad::array(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DirectAbstractDeclarator_oneof_dad::func(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectAbstractDeclarator {
        DirectAbstractDeclarator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectAbstractDeclarator_Simple>(
                    "simple",
                    DirectAbstractDeclarator::has_simple,
                    DirectAbstractDeclarator::get_simple,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectAbstractDeclarator_Array>(
                    "array",
                    DirectAbstractDeclarator::has_array,
                    DirectAbstractDeclarator::get_array,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectAbstractDeclarator_Func>(
                    "func",
                    DirectAbstractDeclarator::has_func,
                    DirectAbstractDeclarator::get_func,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectAbstractDeclarator>(
                    "DirectAbstractDeclarator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectAbstractDeclarator {
        static mut instance: ::protobuf::lazy::Lazy<DirectAbstractDeclarator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectAbstractDeclarator,
        };
        unsafe {
            instance.get(DirectAbstractDeclarator::new)
        }
    }
}

impl ::protobuf::Clear for DirectAbstractDeclarator {
    fn clear(&mut self) {
        self.dad = ::std::option::Option::None;
        self.dad = ::std::option::Option::None;
        self.dad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectAbstractDeclarator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectAbstractDeclarator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectAbstractDeclarator_Simple {
    // message fields
    pub ad: ::protobuf::SingularPtrField<AbstractDeclarator>,
    pub ad_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectAbstractDeclarator_Simple {
    fn default() -> &'a DirectAbstractDeclarator_Simple {
        <DirectAbstractDeclarator_Simple as ::protobuf::Message>::default_instance()
    }
}

impl DirectAbstractDeclarator_Simple {
    pub fn new() -> DirectAbstractDeclarator_Simple {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.AbstractDeclarator ad = 1;


    pub fn get_ad(&self) -> &AbstractDeclarator {
        self.ad.as_ref().unwrap_or_else(|| AbstractDeclarator::default_instance())
    }
    pub fn clear_ad(&mut self) {
        self.ad.clear();
    }

    pub fn has_ad(&self) -> bool {
        self.ad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ad(&mut self, v: AbstractDeclarator) {
        self.ad = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ad(&mut self) -> &mut AbstractDeclarator {
        if self.ad.is_none() {
            self.ad.set_default();
        }
        self.ad.as_mut().unwrap()
    }

    // Take field
    pub fn take_ad(&mut self) -> AbstractDeclarator {
        self.ad.take().unwrap_or_else(|| AbstractDeclarator::new())
    }

    // .c4.ast.proto.Loc ad_loc = 2;


    pub fn get_ad_loc(&self) -> &Loc {
        self.ad_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ad_loc(&mut self) {
        self.ad_loc.clear();
    }

    pub fn has_ad_loc(&self) -> bool {
        self.ad_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ad_loc(&mut self, v: Loc) {
        self.ad_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ad_loc(&mut self) -> &mut Loc {
        if self.ad_loc.is_none() {
            self.ad_loc.set_default();
        }
        self.ad_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ad_loc(&mut self) -> Loc {
        self.ad_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectAbstractDeclarator_Simple {
    fn is_initialized(&self) -> bool {
        for v in &self.ad {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ad_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ad)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ad_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ad.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ad_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ad.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ad_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectAbstractDeclarator_Simple {
        DirectAbstractDeclarator_Simple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AbstractDeclarator>>(
                    "ad",
                    |m: &DirectAbstractDeclarator_Simple| { &m.ad },
                    |m: &mut DirectAbstractDeclarator_Simple| { &mut m.ad },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ad_loc",
                    |m: &DirectAbstractDeclarator_Simple| { &m.ad_loc },
                    |m: &mut DirectAbstractDeclarator_Simple| { &mut m.ad_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectAbstractDeclarator_Simple>(
                    "DirectAbstractDeclarator_Simple",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectAbstractDeclarator_Simple {
        static mut instance: ::protobuf::lazy::Lazy<DirectAbstractDeclarator_Simple> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectAbstractDeclarator_Simple,
        };
        unsafe {
            instance.get(DirectAbstractDeclarator_Simple::new)
        }
    }
}

impl ::protobuf::Clear for DirectAbstractDeclarator_Simple {
    fn clear(&mut self) {
        self.ad.clear();
        self.ad_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectAbstractDeclarator_Simple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectAbstractDeclarator_Simple {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectAbstractDeclarator_Array {
    // message fields
    pub dad_idx: i32,
    pub dad_loc: ::protobuf::SingularPtrField<Loc>,
    pub size_idx: i32,
    pub size_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectAbstractDeclarator_Array {
    fn default() -> &'a DirectAbstractDeclarator_Array {
        <DirectAbstractDeclarator_Array as ::protobuf::Message>::default_instance()
    }
}

impl DirectAbstractDeclarator_Array {
    pub fn new() -> DirectAbstractDeclarator_Array {
        ::std::default::Default::default()
    }

    // int32 dad_idx = 1;


    pub fn get_dad_idx(&self) -> i32 {
        self.dad_idx
    }
    pub fn clear_dad_idx(&mut self) {
        self.dad_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dad_idx(&mut self, v: i32) {
        self.dad_idx = v;
    }

    // .c4.ast.proto.Loc dad_loc = 2;


    pub fn get_dad_loc(&self) -> &Loc {
        self.dad_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dad_loc(&mut self) {
        self.dad_loc.clear();
    }

    pub fn has_dad_loc(&self) -> bool {
        self.dad_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dad_loc(&mut self, v: Loc) {
        self.dad_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dad_loc(&mut self) -> &mut Loc {
        if self.dad_loc.is_none() {
            self.dad_loc.set_default();
        }
        self.dad_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dad_loc(&mut self) -> Loc {
        self.dad_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 size_idx = 3;


    pub fn get_size_idx(&self) -> i32 {
        self.size_idx
    }
    pub fn clear_size_idx(&mut self) {
        self.size_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_idx(&mut self, v: i32) {
        self.size_idx = v;
    }

    // .c4.ast.proto.Loc size_loc = 4;


    pub fn get_size_loc(&self) -> &Loc {
        self.size_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_size_loc(&mut self) {
        self.size_loc.clear();
    }

    pub fn has_size_loc(&self) -> bool {
        self.size_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_loc(&mut self, v: Loc) {
        self.size_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size_loc(&mut self) -> &mut Loc {
        if self.size_loc.is_none() {
            self.size_loc.set_default();
        }
        self.size_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_size_loc(&mut self) -> Loc {
        self.size_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectAbstractDeclarator_Array {
    fn is_initialized(&self) -> bool {
        for v in &self.dad_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.size_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dad_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dad_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dad_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dad_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dad_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.size_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dad_idx != 0 {
            os.write_int32(1, self.dad_idx)?;
        }
        if let Some(ref v) = self.dad_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size_idx != 0 {
            os.write_int32(3, self.size_idx)?;
        }
        if let Some(ref v) = self.size_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectAbstractDeclarator_Array {
        DirectAbstractDeclarator_Array::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dad_idx",
                    |m: &DirectAbstractDeclarator_Array| { &m.dad_idx },
                    |m: &mut DirectAbstractDeclarator_Array| { &mut m.dad_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dad_loc",
                    |m: &DirectAbstractDeclarator_Array| { &m.dad_loc },
                    |m: &mut DirectAbstractDeclarator_Array| { &mut m.dad_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "size_idx",
                    |m: &DirectAbstractDeclarator_Array| { &m.size_idx },
                    |m: &mut DirectAbstractDeclarator_Array| { &mut m.size_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "size_loc",
                    |m: &DirectAbstractDeclarator_Array| { &m.size_loc },
                    |m: &mut DirectAbstractDeclarator_Array| { &mut m.size_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectAbstractDeclarator_Array>(
                    "DirectAbstractDeclarator_Array",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectAbstractDeclarator_Array {
        static mut instance: ::protobuf::lazy::Lazy<DirectAbstractDeclarator_Array> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectAbstractDeclarator_Array,
        };
        unsafe {
            instance.get(DirectAbstractDeclarator_Array::new)
        }
    }
}

impl ::protobuf::Clear for DirectAbstractDeclarator_Array {
    fn clear(&mut self) {
        self.dad_idx = 0;
        self.dad_loc.clear();
        self.size_idx = 0;
        self.size_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectAbstractDeclarator_Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectAbstractDeclarator_Array {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectAbstractDeclarator_Func {
    // message fields
    pub dad_idx: i32,
    pub dad_loc: ::protobuf::SingularPtrField<Loc>,
    pub pds: ::protobuf::RepeatedField<ParamDeclaration>,
    pub pd_locs: ::protobuf::RepeatedField<Loc>,
    pub has_ellipsis: bool,
    pub ellipsis_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectAbstractDeclarator_Func {
    fn default() -> &'a DirectAbstractDeclarator_Func {
        <DirectAbstractDeclarator_Func as ::protobuf::Message>::default_instance()
    }
}

impl DirectAbstractDeclarator_Func {
    pub fn new() -> DirectAbstractDeclarator_Func {
        ::std::default::Default::default()
    }

    // int32 dad_idx = 1;


    pub fn get_dad_idx(&self) -> i32 {
        self.dad_idx
    }
    pub fn clear_dad_idx(&mut self) {
        self.dad_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_dad_idx(&mut self, v: i32) {
        self.dad_idx = v;
    }

    // .c4.ast.proto.Loc dad_loc = 2;


    pub fn get_dad_loc(&self) -> &Loc {
        self.dad_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_dad_loc(&mut self) {
        self.dad_loc.clear();
    }

    pub fn has_dad_loc(&self) -> bool {
        self.dad_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dad_loc(&mut self, v: Loc) {
        self.dad_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dad_loc(&mut self) -> &mut Loc {
        if self.dad_loc.is_none() {
            self.dad_loc.set_default();
        }
        self.dad_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_dad_loc(&mut self) -> Loc {
        self.dad_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated .c4.ast.proto.ParamDeclaration pds = 3;


    pub fn get_pds(&self) -> &[ParamDeclaration] {
        &self.pds
    }
    pub fn clear_pds(&mut self) {
        self.pds.clear();
    }

    // Param is passed by value, moved
    pub fn set_pds(&mut self, v: ::protobuf::RepeatedField<ParamDeclaration>) {
        self.pds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pds(&mut self) -> &mut ::protobuf::RepeatedField<ParamDeclaration> {
        &mut self.pds
    }

    // Take field
    pub fn take_pds(&mut self) -> ::protobuf::RepeatedField<ParamDeclaration> {
        ::std::mem::replace(&mut self.pds, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc pd_locs = 4;


    pub fn get_pd_locs(&self) -> &[Loc] {
        &self.pd_locs
    }
    pub fn clear_pd_locs(&mut self) {
        self.pd_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pd_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.pd_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pd_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.pd_locs
    }

    // Take field
    pub fn take_pd_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.pd_locs, ::protobuf::RepeatedField::new())
    }

    // bool has_ellipsis = 5;


    pub fn get_has_ellipsis(&self) -> bool {
        self.has_ellipsis
    }
    pub fn clear_has_ellipsis(&mut self) {
        self.has_ellipsis = false;
    }

    // Param is passed by value, moved
    pub fn set_has_ellipsis(&mut self, v: bool) {
        self.has_ellipsis = v;
    }

    // .c4.ast.proto.Loc ellipsis_loc = 6;


    pub fn get_ellipsis_loc(&self) -> &Loc {
        self.ellipsis_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ellipsis_loc(&mut self) {
        self.ellipsis_loc.clear();
    }

    pub fn has_ellipsis_loc(&self) -> bool {
        self.ellipsis_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ellipsis_loc(&mut self, v: Loc) {
        self.ellipsis_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ellipsis_loc(&mut self) -> &mut Loc {
        if self.ellipsis_loc.is_none() {
            self.ellipsis_loc.set_default();
        }
        self.ellipsis_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ellipsis_loc(&mut self) -> Loc {
        self.ellipsis_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DirectAbstractDeclarator_Func {
    fn is_initialized(&self) -> bool {
        for v in &self.dad_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pd_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ellipsis_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dad_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dad_loc)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pd_locs)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_ellipsis = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ellipsis_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dad_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dad_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dad_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pd_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.has_ellipsis != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ellipsis_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dad_idx != 0 {
            os.write_int32(1, self.dad_idx)?;
        }
        if let Some(ref v) = self.dad_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pd_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.has_ellipsis != false {
            os.write_bool(5, self.has_ellipsis)?;
        }
        if let Some(ref v) = self.ellipsis_loc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectAbstractDeclarator_Func {
        DirectAbstractDeclarator_Func::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dad_idx",
                    |m: &DirectAbstractDeclarator_Func| { &m.dad_idx },
                    |m: &mut DirectAbstractDeclarator_Func| { &mut m.dad_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dad_loc",
                    |m: &DirectAbstractDeclarator_Func| { &m.dad_loc },
                    |m: &mut DirectAbstractDeclarator_Func| { &mut m.dad_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ParamDeclaration>>(
                    "pds",
                    |m: &DirectAbstractDeclarator_Func| { &m.pds },
                    |m: &mut DirectAbstractDeclarator_Func| { &mut m.pds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "pd_locs",
                    |m: &DirectAbstractDeclarator_Func| { &m.pd_locs },
                    |m: &mut DirectAbstractDeclarator_Func| { &mut m.pd_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_ellipsis",
                    |m: &DirectAbstractDeclarator_Func| { &m.has_ellipsis },
                    |m: &mut DirectAbstractDeclarator_Func| { &mut m.has_ellipsis },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ellipsis_loc",
                    |m: &DirectAbstractDeclarator_Func| { &m.ellipsis_loc },
                    |m: &mut DirectAbstractDeclarator_Func| { &mut m.ellipsis_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectAbstractDeclarator_Func>(
                    "DirectAbstractDeclarator_Func",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectAbstractDeclarator_Func {
        static mut instance: ::protobuf::lazy::Lazy<DirectAbstractDeclarator_Func> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectAbstractDeclarator_Func,
        };
        unsafe {
            instance.get(DirectAbstractDeclarator_Func::new)
        }
    }
}

impl ::protobuf::Clear for DirectAbstractDeclarator_Func {
    fn clear(&mut self) {
        self.dad_idx = 0;
        self.dad_loc.clear();
        self.pds.clear();
        self.pd_locs.clear();
        self.has_ellipsis = false;
        self.ellipsis_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectAbstractDeclarator_Func {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectAbstractDeclarator_Func {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParamDeclaration {
    // message oneof groups
    pub pd: ::std::option::Option<ParamDeclaration_oneof_pd>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParamDeclaration {
    fn default() -> &'a ParamDeclaration {
        <ParamDeclaration as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ParamDeclaration_oneof_pd {
    name(ParamDeclaration_Named),
    type_only(ParamDeclaration_TypeOnly),
    type_only_simple(ParamDeclaration_TypeOnlySimple),
}

impl ParamDeclaration {
    pub fn new() -> ParamDeclaration {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.ParamDeclaration.Named name = 1;


    pub fn get_name(&self) -> &ParamDeclaration_Named {
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(ref v)) => v,
            _ => ParamDeclaration_Named::default_instance(),
        }
    }
    pub fn clear_name(&mut self) {
        self.pd = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ParamDeclaration_Named) {
        self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ParamDeclaration_Named {
        if let ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(_)) = self.pd {
        } else {
            self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(ParamDeclaration_Named::new()));
        }
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ParamDeclaration_Named {
        if self.has_name() {
            match self.pd.take() {
                ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ParamDeclaration_Named::new()
        }
    }

    // .c4.ast.proto.ParamDeclaration.TypeOnly type_only = 2;


    pub fn get_type_only(&self) -> &ParamDeclaration_TypeOnly {
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(ref v)) => v,
            _ => ParamDeclaration_TypeOnly::default_instance(),
        }
    }
    pub fn clear_type_only(&mut self) {
        self.pd = ::std::option::Option::None;
    }

    pub fn has_type_only(&self) -> bool {
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_only(&mut self, v: ParamDeclaration_TypeOnly) {
        self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_only(&mut self) -> &mut ParamDeclaration_TypeOnly {
        if let ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(_)) = self.pd {
        } else {
            self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(ParamDeclaration_TypeOnly::new()));
        }
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_only(&mut self) -> ParamDeclaration_TypeOnly {
        if self.has_type_only() {
            match self.pd.take() {
                ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(v)) => v,
                _ => panic!(),
            }
        } else {
            ParamDeclaration_TypeOnly::new()
        }
    }

    // .c4.ast.proto.ParamDeclaration.TypeOnlySimple type_only_simple = 3;


    pub fn get_type_only_simple(&self) -> &ParamDeclaration_TypeOnlySimple {
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(ref v)) => v,
            _ => ParamDeclaration_TypeOnlySimple::default_instance(),
        }
    }
    pub fn clear_type_only_simple(&mut self) {
        self.pd = ::std::option::Option::None;
    }

    pub fn has_type_only_simple(&self) -> bool {
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_only_simple(&mut self, v: ParamDeclaration_TypeOnlySimple) {
        self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_only_simple(&mut self) -> &mut ParamDeclaration_TypeOnlySimple {
        if let ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(_)) = self.pd {
        } else {
            self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(ParamDeclaration_TypeOnlySimple::new()));
        }
        match self.pd {
            ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_only_simple(&mut self) -> ParamDeclaration_TypeOnlySimple {
        if self.has_type_only_simple() {
            match self.pd.take() {
                ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(v)) => v,
                _ => panic!(),
            }
        } else {
            ParamDeclaration_TypeOnlySimple::new()
        }
    }
}

impl ::protobuf::Message for ParamDeclaration {
    fn is_initialized(&self) -> bool {
        if let Some(ParamDeclaration_oneof_pd::name(ref v)) = self.pd {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ParamDeclaration_oneof_pd::type_only(ref v)) = self.pd {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ParamDeclaration_oneof_pd::type_only_simple(ref v)) = self.pd {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::name(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pd = ::std::option::Option::Some(ParamDeclaration_oneof_pd::type_only_simple(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.pd {
            match v {
                &ParamDeclaration_oneof_pd::name(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ParamDeclaration_oneof_pd::type_only(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ParamDeclaration_oneof_pd::type_only_simple(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.pd {
            match v {
                &ParamDeclaration_oneof_pd::name(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ParamDeclaration_oneof_pd::type_only(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ParamDeclaration_oneof_pd::type_only_simple(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParamDeclaration {
        ParamDeclaration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ParamDeclaration_Named>(
                    "name",
                    ParamDeclaration::has_name,
                    ParamDeclaration::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ParamDeclaration_TypeOnly>(
                    "type_only",
                    ParamDeclaration::has_type_only,
                    ParamDeclaration::get_type_only,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ParamDeclaration_TypeOnlySimple>(
                    "type_only_simple",
                    ParamDeclaration::has_type_only_simple,
                    ParamDeclaration::get_type_only_simple,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParamDeclaration>(
                    "ParamDeclaration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParamDeclaration {
        static mut instance: ::protobuf::lazy::Lazy<ParamDeclaration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParamDeclaration,
        };
        unsafe {
            instance.get(ParamDeclaration::new)
        }
    }
}

impl ::protobuf::Clear for ParamDeclaration {
    fn clear(&mut self) {
        self.pd = ::std::option::Option::None;
        self.pd = ::std::option::Option::None;
        self.pd = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParamDeclaration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamDeclaration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParamDeclaration_Named {
    // message fields
    pub dss: ::protobuf::RepeatedField<DeclarationSpecifier>,
    pub ds_locs: ::protobuf::RepeatedField<Loc>,
    pub d: ::protobuf::SingularPtrField<Declarator>,
    pub d_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParamDeclaration_Named {
    fn default() -> &'a ParamDeclaration_Named {
        <ParamDeclaration_Named as ::protobuf::Message>::default_instance()
    }
}

impl ParamDeclaration_Named {
    pub fn new() -> ParamDeclaration_Named {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.DeclarationSpecifier dss = 1;


    pub fn get_dss(&self) -> &[DeclarationSpecifier] {
        &self.dss
    }
    pub fn clear_dss(&mut self) {
        self.dss.clear();
    }

    // Param is passed by value, moved
    pub fn set_dss(&mut self, v: ::protobuf::RepeatedField<DeclarationSpecifier>) {
        self.dss = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dss(&mut self) -> &mut ::protobuf::RepeatedField<DeclarationSpecifier> {
        &mut self.dss
    }

    // Take field
    pub fn take_dss(&mut self) -> ::protobuf::RepeatedField<DeclarationSpecifier> {
        ::std::mem::replace(&mut self.dss, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc ds_locs = 2;


    pub fn get_ds_locs(&self) -> &[Loc] {
        &self.ds_locs
    }
    pub fn clear_ds_locs(&mut self) {
        self.ds_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.ds_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ds_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.ds_locs
    }

    // Take field
    pub fn take_ds_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.ds_locs, ::protobuf::RepeatedField::new())
    }

    // .c4.ast.proto.Declarator d = 3;


    pub fn get_d(&self) -> &Declarator {
        self.d.as_ref().unwrap_or_else(|| Declarator::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: Declarator) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut Declarator {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> Declarator {
        self.d.take().unwrap_or_else(|| Declarator::new())
    }

    // .c4.ast.proto.Loc d_loc = 4;


    pub fn get_d_loc(&self) -> &Loc {
        self.d_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_d_loc(&mut self) {
        self.d_loc.clear();
    }

    pub fn has_d_loc(&self) -> bool {
        self.d_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_loc(&mut self, v: Loc) {
        self.d_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d_loc(&mut self) -> &mut Loc {
        if self.d_loc.is_none() {
            self.d_loc.set_default();
        }
        self.d_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_d_loc(&mut self) -> Loc {
        self.d_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for ParamDeclaration_Named {
    fn is_initialized(&self) -> bool {
        for v in &self.dss {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ds_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dss)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ds_locs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dss {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ds_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dss {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ds_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParamDeclaration_Named {
        ParamDeclaration_Named::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeclarationSpecifier>>(
                    "dss",
                    |m: &ParamDeclaration_Named| { &m.dss },
                    |m: &mut ParamDeclaration_Named| { &mut m.dss },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ds_locs",
                    |m: &ParamDeclaration_Named| { &m.ds_locs },
                    |m: &mut ParamDeclaration_Named| { &mut m.ds_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declarator>>(
                    "d",
                    |m: &ParamDeclaration_Named| { &m.d },
                    |m: &mut ParamDeclaration_Named| { &mut m.d },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "d_loc",
                    |m: &ParamDeclaration_Named| { &m.d_loc },
                    |m: &mut ParamDeclaration_Named| { &mut m.d_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParamDeclaration_Named>(
                    "ParamDeclaration_Named",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParamDeclaration_Named {
        static mut instance: ::protobuf::lazy::Lazy<ParamDeclaration_Named> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParamDeclaration_Named,
        };
        unsafe {
            instance.get(ParamDeclaration_Named::new)
        }
    }
}

impl ::protobuf::Clear for ParamDeclaration_Named {
    fn clear(&mut self) {
        self.dss.clear();
        self.ds_locs.clear();
        self.d.clear();
        self.d_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParamDeclaration_Named {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamDeclaration_Named {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParamDeclaration_TypeOnly {
    // message fields
    pub dss: ::protobuf::RepeatedField<DeclarationSpecifier>,
    pub ds_locs: ::protobuf::RepeatedField<Loc>,
    pub ad: ::protobuf::SingularPtrField<AbstractDeclarator>,
    pub ad_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParamDeclaration_TypeOnly {
    fn default() -> &'a ParamDeclaration_TypeOnly {
        <ParamDeclaration_TypeOnly as ::protobuf::Message>::default_instance()
    }
}

impl ParamDeclaration_TypeOnly {
    pub fn new() -> ParamDeclaration_TypeOnly {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.DeclarationSpecifier dss = 1;


    pub fn get_dss(&self) -> &[DeclarationSpecifier] {
        &self.dss
    }
    pub fn clear_dss(&mut self) {
        self.dss.clear();
    }

    // Param is passed by value, moved
    pub fn set_dss(&mut self, v: ::protobuf::RepeatedField<DeclarationSpecifier>) {
        self.dss = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dss(&mut self) -> &mut ::protobuf::RepeatedField<DeclarationSpecifier> {
        &mut self.dss
    }

    // Take field
    pub fn take_dss(&mut self) -> ::protobuf::RepeatedField<DeclarationSpecifier> {
        ::std::mem::replace(&mut self.dss, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc ds_locs = 2;


    pub fn get_ds_locs(&self) -> &[Loc] {
        &self.ds_locs
    }
    pub fn clear_ds_locs(&mut self) {
        self.ds_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.ds_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ds_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.ds_locs
    }

    // Take field
    pub fn take_ds_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.ds_locs, ::protobuf::RepeatedField::new())
    }

    // .c4.ast.proto.AbstractDeclarator ad = 3;


    pub fn get_ad(&self) -> &AbstractDeclarator {
        self.ad.as_ref().unwrap_or_else(|| AbstractDeclarator::default_instance())
    }
    pub fn clear_ad(&mut self) {
        self.ad.clear();
    }

    pub fn has_ad(&self) -> bool {
        self.ad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ad(&mut self, v: AbstractDeclarator) {
        self.ad = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ad(&mut self) -> &mut AbstractDeclarator {
        if self.ad.is_none() {
            self.ad.set_default();
        }
        self.ad.as_mut().unwrap()
    }

    // Take field
    pub fn take_ad(&mut self) -> AbstractDeclarator {
        self.ad.take().unwrap_or_else(|| AbstractDeclarator::new())
    }

    // .c4.ast.proto.Loc ad_loc = 4;


    pub fn get_ad_loc(&self) -> &Loc {
        self.ad_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ad_loc(&mut self) {
        self.ad_loc.clear();
    }

    pub fn has_ad_loc(&self) -> bool {
        self.ad_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ad_loc(&mut self, v: Loc) {
        self.ad_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ad_loc(&mut self) -> &mut Loc {
        if self.ad_loc.is_none() {
            self.ad_loc.set_default();
        }
        self.ad_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ad_loc(&mut self) -> Loc {
        self.ad_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for ParamDeclaration_TypeOnly {
    fn is_initialized(&self) -> bool {
        for v in &self.dss {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ds_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ad {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ad_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dss)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ds_locs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ad)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ad_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dss {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ds_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.ad.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ad_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dss {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ds_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.ad.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ad_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParamDeclaration_TypeOnly {
        ParamDeclaration_TypeOnly::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeclarationSpecifier>>(
                    "dss",
                    |m: &ParamDeclaration_TypeOnly| { &m.dss },
                    |m: &mut ParamDeclaration_TypeOnly| { &mut m.dss },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ds_locs",
                    |m: &ParamDeclaration_TypeOnly| { &m.ds_locs },
                    |m: &mut ParamDeclaration_TypeOnly| { &mut m.ds_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AbstractDeclarator>>(
                    "ad",
                    |m: &ParamDeclaration_TypeOnly| { &m.ad },
                    |m: &mut ParamDeclaration_TypeOnly| { &mut m.ad },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ad_loc",
                    |m: &ParamDeclaration_TypeOnly| { &m.ad_loc },
                    |m: &mut ParamDeclaration_TypeOnly| { &mut m.ad_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParamDeclaration_TypeOnly>(
                    "ParamDeclaration_TypeOnly",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParamDeclaration_TypeOnly {
        static mut instance: ::protobuf::lazy::Lazy<ParamDeclaration_TypeOnly> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParamDeclaration_TypeOnly,
        };
        unsafe {
            instance.get(ParamDeclaration_TypeOnly::new)
        }
    }
}

impl ::protobuf::Clear for ParamDeclaration_TypeOnly {
    fn clear(&mut self) {
        self.dss.clear();
        self.ds_locs.clear();
        self.ad.clear();
        self.ad_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParamDeclaration_TypeOnly {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamDeclaration_TypeOnly {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParamDeclaration_TypeOnlySimple {
    // message fields
    pub dss: ::protobuf::RepeatedField<DeclarationSpecifier>,
    pub ds_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParamDeclaration_TypeOnlySimple {
    fn default() -> &'a ParamDeclaration_TypeOnlySimple {
        <ParamDeclaration_TypeOnlySimple as ::protobuf::Message>::default_instance()
    }
}

impl ParamDeclaration_TypeOnlySimple {
    pub fn new() -> ParamDeclaration_TypeOnlySimple {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.DeclarationSpecifier dss = 1;


    pub fn get_dss(&self) -> &[DeclarationSpecifier] {
        &self.dss
    }
    pub fn clear_dss(&mut self) {
        self.dss.clear();
    }

    // Param is passed by value, moved
    pub fn set_dss(&mut self, v: ::protobuf::RepeatedField<DeclarationSpecifier>) {
        self.dss = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dss(&mut self) -> &mut ::protobuf::RepeatedField<DeclarationSpecifier> {
        &mut self.dss
    }

    // Take field
    pub fn take_dss(&mut self) -> ::protobuf::RepeatedField<DeclarationSpecifier> {
        ::std::mem::replace(&mut self.dss, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc ds_locs = 2;


    pub fn get_ds_locs(&self) -> &[Loc] {
        &self.ds_locs
    }
    pub fn clear_ds_locs(&mut self) {
        self.ds_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.ds_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ds_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.ds_locs
    }

    // Take field
    pub fn take_ds_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.ds_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ParamDeclaration_TypeOnlySimple {
    fn is_initialized(&self) -> bool {
        for v in &self.dss {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ds_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dss)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ds_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dss {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ds_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dss {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ds_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParamDeclaration_TypeOnlySimple {
        ParamDeclaration_TypeOnlySimple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeclarationSpecifier>>(
                    "dss",
                    |m: &ParamDeclaration_TypeOnlySimple| { &m.dss },
                    |m: &mut ParamDeclaration_TypeOnlySimple| { &mut m.dss },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ds_locs",
                    |m: &ParamDeclaration_TypeOnlySimple| { &m.ds_locs },
                    |m: &mut ParamDeclaration_TypeOnlySimple| { &mut m.ds_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParamDeclaration_TypeOnlySimple>(
                    "ParamDeclaration_TypeOnlySimple",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParamDeclaration_TypeOnlySimple {
        static mut instance: ::protobuf::lazy::Lazy<ParamDeclaration_TypeOnlySimple> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParamDeclaration_TypeOnlySimple,
        };
        unsafe {
            instance.get(ParamDeclaration_TypeOnlySimple::new)
        }
    }
}

impl ::protobuf::Clear for ParamDeclaration_TypeOnlySimple {
    fn clear(&mut self) {
        self.dss.clear();
        self.ds_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParamDeclaration_TypeOnlySimple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamDeclaration_TypeOnlySimple {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeclarationSpecifier {
    // message fields
    pub loc: ::protobuf::SingularPtrField<Loc>,
    // message oneof groups
    pub elem: ::std::option::Option<DeclarationSpecifier_oneof_elem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeclarationSpecifier {
    fn default() -> &'a DeclarationSpecifier {
        <DeclarationSpecifier as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DeclarationSpecifier_oneof_elem {
    scs(StorageClassSpecifier),
    ts(TypeSpecifier),
    tq(TypeQualifier),
}

impl DeclarationSpecifier {
    pub fn new() -> DeclarationSpecifier {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.StorageClassSpecifier scs = 1;


    pub fn get_scs(&self) -> StorageClassSpecifier {
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::scs(v)) => v,
            _ => StorageClassSpecifier::TYPEDEF,
        }
    }
    pub fn clear_scs(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_scs(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::scs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scs(&mut self, v: StorageClassSpecifier) {
        self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::scs(v))
    }

    // .c4.ast.proto.TypeSpecifier ts = 2;


    pub fn get_ts(&self) -> &TypeSpecifier {
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(ref v)) => v,
            _ => TypeSpecifier::default_instance(),
        }
    }
    pub fn clear_ts(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_ts(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ts(&mut self, v: TypeSpecifier) {
        self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ts(&mut self) -> &mut TypeSpecifier {
        if let ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(_)) = self.elem {
        } else {
            self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(TypeSpecifier::new()));
        }
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ts(&mut self) -> TypeSpecifier {
        if self.has_ts() {
            match self.elem.take() {
                ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier::new()
        }
    }

    // .c4.ast.proto.TypeQualifier tq = 3;


    pub fn get_tq(&self) -> TypeQualifier {
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::tq(v)) => v,
            _ => TypeQualifier::CONST,
        }
    }
    pub fn clear_tq(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_tq(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::tq(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tq(&mut self, v: TypeQualifier) {
        self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::tq(v))
    }

    // .c4.ast.proto.Loc loc = 4;


    pub fn get_loc(&self) -> &Loc {
        self.loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_loc(&mut self) {
        self.loc.clear();
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: Loc) {
        self.loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut Loc {
        if self.loc.is_none() {
            self.loc.set_default();
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> Loc {
        self.loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for DeclarationSpecifier {
    fn is_initialized(&self) -> bool {
        if let Some(DeclarationSpecifier_oneof_elem::ts(ref v)) = self.elem {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::scs(is.read_enum()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::ts(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(DeclarationSpecifier_oneof_elem::tq(is.read_enum()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.elem {
            match v {
                &DeclarationSpecifier_oneof_elem::scs(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
                &DeclarationSpecifier_oneof_elem::ts(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DeclarationSpecifier_oneof_elem::tq(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.elem {
            match v {
                &DeclarationSpecifier_oneof_elem::scs(v) => {
                    os.write_enum(1, v.value())?;
                },
                &DeclarationSpecifier_oneof_elem::ts(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DeclarationSpecifier_oneof_elem::tq(v) => {
                    os.write_enum(3, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeclarationSpecifier {
        DeclarationSpecifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, StorageClassSpecifier>(
                    "scs",
                    DeclarationSpecifier::has_scs,
                    DeclarationSpecifier::get_scs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier>(
                    "ts",
                    DeclarationSpecifier::has_ts,
                    DeclarationSpecifier::get_ts,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, TypeQualifier>(
                    "tq",
                    DeclarationSpecifier::has_tq,
                    DeclarationSpecifier::get_tq,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "loc",
                    |m: &DeclarationSpecifier| { &m.loc },
                    |m: &mut DeclarationSpecifier| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeclarationSpecifier>(
                    "DeclarationSpecifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeclarationSpecifier {
        static mut instance: ::protobuf::lazy::Lazy<DeclarationSpecifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeclarationSpecifier,
        };
        unsafe {
            instance.get(DeclarationSpecifier::new)
        }
    }
}

impl ::protobuf::Clear for DeclarationSpecifier {
    fn clear(&mut self) {
        self.elem = ::std::option::Option::None;
        self.elem = ::std::option::Option::None;
        self.elem = ::std::option::Option::None;
        self.loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeclarationSpecifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeclarationSpecifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pointer {
    // message fields
    pub qs: ::std::vec::Vec<TypeQualifier>,
    pub q_locs: ::protobuf::RepeatedField<Loc>,
    pub ptr_idx: i32,
    pub ptr_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pointer {
    fn default() -> &'a Pointer {
        <Pointer as ::protobuf::Message>::default_instance()
    }
}

impl Pointer {
    pub fn new() -> Pointer {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.TypeQualifier qs = 1;


    pub fn get_qs(&self) -> &[TypeQualifier] {
        &self.qs
    }
    pub fn clear_qs(&mut self) {
        self.qs.clear();
    }

    // Param is passed by value, moved
    pub fn set_qs(&mut self, v: ::std::vec::Vec<TypeQualifier>) {
        self.qs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_qs(&mut self) -> &mut ::std::vec::Vec<TypeQualifier> {
        &mut self.qs
    }

    // Take field
    pub fn take_qs(&mut self) -> ::std::vec::Vec<TypeQualifier> {
        ::std::mem::replace(&mut self.qs, ::std::vec::Vec::new())
    }

    // repeated .c4.ast.proto.Loc q_locs = 2;


    pub fn get_q_locs(&self) -> &[Loc] {
        &self.q_locs
    }
    pub fn clear_q_locs(&mut self) {
        self.q_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_q_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.q_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_q_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.q_locs
    }

    // Take field
    pub fn take_q_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.q_locs, ::protobuf::RepeatedField::new())
    }

    // int32 ptr_idx = 3;


    pub fn get_ptr_idx(&self) -> i32 {
        self.ptr_idx
    }
    pub fn clear_ptr_idx(&mut self) {
        self.ptr_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_ptr_idx(&mut self, v: i32) {
        self.ptr_idx = v;
    }

    // .c4.ast.proto.Loc ptr_loc = 4;


    pub fn get_ptr_loc(&self) -> &Loc {
        self.ptr_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ptr_loc(&mut self) {
        self.ptr_loc.clear();
    }

    pub fn has_ptr_loc(&self) -> bool {
        self.ptr_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ptr_loc(&mut self, v: Loc) {
        self.ptr_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ptr_loc(&mut self) -> &mut Loc {
        if self.ptr_loc.is_none() {
            self.ptr_loc.set_default();
        }
        self.ptr_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ptr_loc(&mut self) -> Loc {
        self.ptr_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Pointer {
    fn is_initialized(&self) -> bool {
        for v in &self.q_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ptr_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.qs, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.q_locs)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ptr_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ptr_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.qs {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in &self.q_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.ptr_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ptr_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ptr_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.qs {
            os.write_enum(1, v.value())?;
        };
        for v in &self.q_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.ptr_idx != 0 {
            os.write_int32(3, self.ptr_idx)?;
        }
        if let Some(ref v) = self.ptr_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pointer {
        Pointer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypeQualifier>>(
                    "qs",
                    |m: &Pointer| { &m.qs },
                    |m: &mut Pointer| { &mut m.qs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "q_locs",
                    |m: &Pointer| { &m.q_locs },
                    |m: &mut Pointer| { &mut m.q_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ptr_idx",
                    |m: &Pointer| { &m.ptr_idx },
                    |m: &mut Pointer| { &mut m.ptr_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ptr_loc",
                    |m: &Pointer| { &m.ptr_loc },
                    |m: &mut Pointer| { &mut m.ptr_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pointer>(
                    "Pointer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pointer {
        static mut instance: ::protobuf::lazy::Lazy<Pointer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pointer,
        };
        unsafe {
            instance.get(Pointer::new)
        }
    }
}

impl ::protobuf::Clear for Pointer {
    fn clear(&mut self) {
        self.qs.clear();
        self.q_locs.clear();
        self.ptr_idx = 0;
        self.ptr_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pointer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Initializer {
    // message oneof groups
    pub init: ::std::option::Option<Initializer_oneof_init>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Initializer {
    fn default() -> &'a Initializer {
        <Initializer as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Initializer_oneof_init {
    expr(Initializer_Expr),
    field_struct(Initializer_Struct),
}

impl Initializer {
    pub fn new() -> Initializer {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.Initializer.Expr expr = 1;


    pub fn get_expr(&self) -> &Initializer_Expr {
        match self.init {
            ::std::option::Option::Some(Initializer_oneof_init::expr(ref v)) => v,
            _ => Initializer_Expr::default_instance(),
        }
    }
    pub fn clear_expr(&mut self) {
        self.init = ::std::option::Option::None;
    }

    pub fn has_expr(&self) -> bool {
        match self.init {
            ::std::option::Option::Some(Initializer_oneof_init::expr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Initializer_Expr) {
        self.init = ::std::option::Option::Some(Initializer_oneof_init::expr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_expr(&mut self) -> &mut Initializer_Expr {
        if let ::std::option::Option::Some(Initializer_oneof_init::expr(_)) = self.init {
        } else {
            self.init = ::std::option::Option::Some(Initializer_oneof_init::expr(Initializer_Expr::new()));
        }
        match self.init {
            ::std::option::Option::Some(Initializer_oneof_init::expr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_expr(&mut self) -> Initializer_Expr {
        if self.has_expr() {
            match self.init.take() {
                ::std::option::Option::Some(Initializer_oneof_init::expr(v)) => v,
                _ => panic!(),
            }
        } else {
            Initializer_Expr::new()
        }
    }

    // .c4.ast.proto.Initializer.Struct struct = 2;


    pub fn get_field_struct(&self) -> &Initializer_Struct {
        match self.init {
            ::std::option::Option::Some(Initializer_oneof_init::field_struct(ref v)) => v,
            _ => Initializer_Struct::default_instance(),
        }
    }
    pub fn clear_field_struct(&mut self) {
        self.init = ::std::option::Option::None;
    }

    pub fn has_field_struct(&self) -> bool {
        match self.init {
            ::std::option::Option::Some(Initializer_oneof_init::field_struct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_struct(&mut self, v: Initializer_Struct) {
        self.init = ::std::option::Option::Some(Initializer_oneof_init::field_struct(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_struct(&mut self) -> &mut Initializer_Struct {
        if let ::std::option::Option::Some(Initializer_oneof_init::field_struct(_)) = self.init {
        } else {
            self.init = ::std::option::Option::Some(Initializer_oneof_init::field_struct(Initializer_Struct::new()));
        }
        match self.init {
            ::std::option::Option::Some(Initializer_oneof_init::field_struct(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_struct(&mut self) -> Initializer_Struct {
        if self.has_field_struct() {
            match self.init.take() {
                ::std::option::Option::Some(Initializer_oneof_init::field_struct(v)) => v,
                _ => panic!(),
            }
        } else {
            Initializer_Struct::new()
        }
    }
}

impl ::protobuf::Message for Initializer {
    fn is_initialized(&self) -> bool {
        if let Some(Initializer_oneof_init::expr(ref v)) = self.init {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Initializer_oneof_init::field_struct(ref v)) = self.init {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.init = ::std::option::Option::Some(Initializer_oneof_init::expr(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.init = ::std::option::Option::Some(Initializer_oneof_init::field_struct(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.init {
            match v {
                &Initializer_oneof_init::expr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Initializer_oneof_init::field_struct(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.init {
            match v {
                &Initializer_oneof_init::expr(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Initializer_oneof_init::field_struct(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Initializer {
        Initializer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Initializer_Expr>(
                    "expr",
                    Initializer::has_expr,
                    Initializer::get_expr,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Initializer_Struct>(
                    "struct",
                    Initializer::has_field_struct,
                    Initializer::get_field_struct,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Initializer>(
                    "Initializer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Initializer {
        static mut instance: ::protobuf::lazy::Lazy<Initializer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Initializer,
        };
        unsafe {
            instance.get(Initializer::new)
        }
    }
}

impl ::protobuf::Clear for Initializer {
    fn clear(&mut self) {
        self.init = ::std::option::Option::None;
        self.init = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Initializer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Initializer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Initializer_Expr {
    // message fields
    pub e: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Initializer_Expr {
    fn default() -> &'a Initializer_Expr {
        <Initializer_Expr as ::protobuf::Message>::default_instance()
    }
}

impl Initializer_Expr {
    pub fn new() -> Initializer_Expr {
        ::std::default::Default::default()
    }

    // int32 e = 1;


    pub fn get_e(&self) -> i32 {
        self.e
    }
    pub fn clear_e(&mut self) {
        self.e = 0;
    }

    // Param is passed by value, moved
    pub fn set_e(&mut self, v: i32) {
        self.e = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Initializer_Expr {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e != 0 {
            os.write_int32(1, self.e)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Initializer_Expr {
        Initializer_Expr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e",
                    |m: &Initializer_Expr| { &m.e },
                    |m: &mut Initializer_Expr| { &mut m.e },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Initializer_Expr| { &m.e_loc },
                    |m: &mut Initializer_Expr| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Initializer_Expr>(
                    "Initializer_Expr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Initializer_Expr {
        static mut instance: ::protobuf::lazy::Lazy<Initializer_Expr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Initializer_Expr,
        };
        unsafe {
            instance.get(Initializer_Expr::new)
        }
    }
}

impl ::protobuf::Clear for Initializer_Expr {
    fn clear(&mut self) {
        self.e = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Initializer_Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Initializer_Expr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Initializer_Struct {
    // message fields
    pub inits: ::std::vec::Vec<i32>,
    pub init_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Initializer_Struct {
    fn default() -> &'a Initializer_Struct {
        <Initializer_Struct as ::protobuf::Message>::default_instance()
    }
}

impl Initializer_Struct {
    pub fn new() -> Initializer_Struct {
        ::std::default::Default::default()
    }

    // repeated int32 inits = 1;


    pub fn get_inits(&self) -> &[i32] {
        &self.inits
    }
    pub fn clear_inits(&mut self) {
        self.inits.clear();
    }

    // Param is passed by value, moved
    pub fn set_inits(&mut self, v: ::std::vec::Vec<i32>) {
        self.inits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inits(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.inits
    }

    // Take field
    pub fn take_inits(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.inits, ::std::vec::Vec::new())
    }

    // repeated .c4.ast.proto.Loc init_locs = 2;


    pub fn get_init_locs(&self) -> &[Loc] {
        &self.init_locs
    }
    pub fn clear_init_locs(&mut self) {
        self.init_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_init_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.init_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_init_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.init_locs
    }

    // Take field
    pub fn take_init_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.init_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Initializer_Struct {
    fn is_initialized(&self) -> bool {
        for v in &self.init_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.inits)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.init_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.inits {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.init_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.inits {
            os.write_int32(1, *v)?;
        };
        for v in &self.init_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Initializer_Struct {
        Initializer_Struct::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "inits",
                    |m: &Initializer_Struct| { &m.inits },
                    |m: &mut Initializer_Struct| { &mut m.inits },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "init_locs",
                    |m: &Initializer_Struct| { &m.init_locs },
                    |m: &mut Initializer_Struct| { &mut m.init_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Initializer_Struct>(
                    "Initializer_Struct",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Initializer_Struct {
        static mut instance: ::protobuf::lazy::Lazy<Initializer_Struct> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Initializer_Struct,
        };
        unsafe {
            instance.get(Initializer_Struct::new)
        }
    }
}

impl ::protobuf::Clear for Initializer_Struct {
    fn clear(&mut self) {
        self.inits.clear();
        self.init_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Initializer_Struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Initializer_Struct {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Declaration {
    // message fields
    pub dss: ::protobuf::RepeatedField<DeclarationSpecifier>,
    pub ds_locs: ::protobuf::RepeatedField<Loc>,
    pub ids: ::protobuf::RepeatedField<Declaration_Id>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Declaration {
    fn default() -> &'a Declaration {
        <Declaration as ::protobuf::Message>::default_instance()
    }
}

impl Declaration {
    pub fn new() -> Declaration {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.DeclarationSpecifier dss = 1;


    pub fn get_dss(&self) -> &[DeclarationSpecifier] {
        &self.dss
    }
    pub fn clear_dss(&mut self) {
        self.dss.clear();
    }

    // Param is passed by value, moved
    pub fn set_dss(&mut self, v: ::protobuf::RepeatedField<DeclarationSpecifier>) {
        self.dss = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dss(&mut self) -> &mut ::protobuf::RepeatedField<DeclarationSpecifier> {
        &mut self.dss
    }

    // Take field
    pub fn take_dss(&mut self) -> ::protobuf::RepeatedField<DeclarationSpecifier> {
        ::std::mem::replace(&mut self.dss, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc ds_locs = 2;


    pub fn get_ds_locs(&self) -> &[Loc] {
        &self.ds_locs
    }
    pub fn clear_ds_locs(&mut self) {
        self.ds_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.ds_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ds_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.ds_locs
    }

    // Take field
    pub fn take_ds_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.ds_locs, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Declaration.Id ids = 3;


    pub fn get_ids(&self) -> &[Declaration_Id] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<Declaration_Id>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<Declaration_Id> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<Declaration_Id> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Declaration {
    fn is_initialized(&self) -> bool {
        for v in &self.dss {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ds_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dss)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ds_locs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dss {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ds_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dss {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ds_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ids {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Declaration {
        Declaration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeclarationSpecifier>>(
                    "dss",
                    |m: &Declaration| { &m.dss },
                    |m: &mut Declaration| { &mut m.dss },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ds_locs",
                    |m: &Declaration| { &m.ds_locs },
                    |m: &mut Declaration| { &mut m.ds_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declaration_Id>>(
                    "ids",
                    |m: &Declaration| { &m.ids },
                    |m: &mut Declaration| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Declaration>(
                    "Declaration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Declaration {
        static mut instance: ::protobuf::lazy::Lazy<Declaration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Declaration,
        };
        unsafe {
            instance.get(Declaration::new)
        }
    }
}

impl ::protobuf::Clear for Declaration {
    fn clear(&mut self) {
        self.dss.clear();
        self.ds_locs.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Declaration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Declaration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Declaration_Id {
    // message fields
    pub d: ::protobuf::SingularPtrField<Declarator>,
    pub d_loc: ::protobuf::SingularPtrField<Loc>,
    pub init_idx: i32,
    pub init_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Declaration_Id {
    fn default() -> &'a Declaration_Id {
        <Declaration_Id as ::protobuf::Message>::default_instance()
    }
}

impl Declaration_Id {
    pub fn new() -> Declaration_Id {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.Declarator d = 1;


    pub fn get_d(&self) -> &Declarator {
        self.d.as_ref().unwrap_or_else(|| Declarator::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: Declarator) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut Declarator {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> Declarator {
        self.d.take().unwrap_or_else(|| Declarator::new())
    }

    // .c4.ast.proto.Loc d_loc = 2;


    pub fn get_d_loc(&self) -> &Loc {
        self.d_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_d_loc(&mut self) {
        self.d_loc.clear();
    }

    pub fn has_d_loc(&self) -> bool {
        self.d_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_loc(&mut self, v: Loc) {
        self.d_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d_loc(&mut self) -> &mut Loc {
        if self.d_loc.is_none() {
            self.d_loc.set_default();
        }
        self.d_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_d_loc(&mut self) -> Loc {
        self.d_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 init_idx = 3;


    pub fn get_init_idx(&self) -> i32 {
        self.init_idx
    }
    pub fn clear_init_idx(&mut self) {
        self.init_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_init_idx(&mut self, v: i32) {
        self.init_idx = v;
    }

    // .c4.ast.proto.Loc init_loc = 4;


    pub fn get_init_loc(&self) -> &Loc {
        self.init_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_init_loc(&mut self) {
        self.init_loc.clear();
    }

    pub fn has_init_loc(&self) -> bool {
        self.init_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_init_loc(&mut self, v: Loc) {
        self.init_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_init_loc(&mut self) -> &mut Loc {
        if self.init_loc.is_none() {
            self.init_loc.set_default();
        }
        self.init_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_init_loc(&mut self) -> Loc {
        self.init_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Declaration_Id {
    fn is_initialized(&self) -> bool {
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.init_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.init_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.init_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.init_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.init_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.init_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.init_idx != 0 {
            os.write_int32(3, self.init_idx)?;
        }
        if let Some(ref v) = self.init_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Declaration_Id {
        Declaration_Id::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declarator>>(
                    "d",
                    |m: &Declaration_Id| { &m.d },
                    |m: &mut Declaration_Id| { &mut m.d },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "d_loc",
                    |m: &Declaration_Id| { &m.d_loc },
                    |m: &mut Declaration_Id| { &mut m.d_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "init_idx",
                    |m: &Declaration_Id| { &m.init_idx },
                    |m: &mut Declaration_Id| { &mut m.init_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "init_loc",
                    |m: &Declaration_Id| { &m.init_loc },
                    |m: &mut Declaration_Id| { &mut m.init_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Declaration_Id>(
                    "Declaration_Id",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Declaration_Id {
        static mut instance: ::protobuf::lazy::Lazy<Declaration_Id> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Declaration_Id,
        };
        unsafe {
            instance.get(Declaration_Id::new)
        }
    }
}

impl ::protobuf::Clear for Declaration_Id {
    fn clear(&mut self) {
        self.d.clear();
        self.d_loc.clear();
        self.init_idx = 0;
        self.init_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Declaration_Id {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Declaration_Id {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionDef {
    // message fields
    pub dss: ::protobuf::RepeatedField<DeclarationSpecifier>,
    pub ds_locs: ::protobuf::RepeatedField<Loc>,
    pub d: ::protobuf::SingularPtrField<Declarator>,
    pub d_loc: ::protobuf::SingularPtrField<Loc>,
    pub dls: ::protobuf::RepeatedField<Declaration>,
    pub dl_locs: ::protobuf::RepeatedField<Loc>,
    pub body: ::protobuf::SingularPtrField<Statement_Compound>,
    pub body_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FunctionDef {
    fn default() -> &'a FunctionDef {
        <FunctionDef as ::protobuf::Message>::default_instance()
    }
}

impl FunctionDef {
    pub fn new() -> FunctionDef {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.DeclarationSpecifier dss = 1;


    pub fn get_dss(&self) -> &[DeclarationSpecifier] {
        &self.dss
    }
    pub fn clear_dss(&mut self) {
        self.dss.clear();
    }

    // Param is passed by value, moved
    pub fn set_dss(&mut self, v: ::protobuf::RepeatedField<DeclarationSpecifier>) {
        self.dss = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dss(&mut self) -> &mut ::protobuf::RepeatedField<DeclarationSpecifier> {
        &mut self.dss
    }

    // Take field
    pub fn take_dss(&mut self) -> ::protobuf::RepeatedField<DeclarationSpecifier> {
        ::std::mem::replace(&mut self.dss, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc ds_locs = 2;


    pub fn get_ds_locs(&self) -> &[Loc] {
        &self.ds_locs
    }
    pub fn clear_ds_locs(&mut self) {
        self.ds_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.ds_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ds_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.ds_locs
    }

    // Take field
    pub fn take_ds_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.ds_locs, ::protobuf::RepeatedField::new())
    }

    // .c4.ast.proto.Declarator d = 3;


    pub fn get_d(&self) -> &Declarator {
        self.d.as_ref().unwrap_or_else(|| Declarator::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: Declarator) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut Declarator {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> Declarator {
        self.d.take().unwrap_or_else(|| Declarator::new())
    }

    // .c4.ast.proto.Loc d_loc = 4;


    pub fn get_d_loc(&self) -> &Loc {
        self.d_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_d_loc(&mut self) {
        self.d_loc.clear();
    }

    pub fn has_d_loc(&self) -> bool {
        self.d_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_loc(&mut self, v: Loc) {
        self.d_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d_loc(&mut self) -> &mut Loc {
        if self.d_loc.is_none() {
            self.d_loc.set_default();
        }
        self.d_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_d_loc(&mut self) -> Loc {
        self.d_loc.take().unwrap_or_else(|| Loc::new())
    }

    // repeated .c4.ast.proto.Declaration dls = 5;


    pub fn get_dls(&self) -> &[Declaration] {
        &self.dls
    }
    pub fn clear_dls(&mut self) {
        self.dls.clear();
    }

    // Param is passed by value, moved
    pub fn set_dls(&mut self, v: ::protobuf::RepeatedField<Declaration>) {
        self.dls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dls(&mut self) -> &mut ::protobuf::RepeatedField<Declaration> {
        &mut self.dls
    }

    // Take field
    pub fn take_dls(&mut self) -> ::protobuf::RepeatedField<Declaration> {
        ::std::mem::replace(&mut self.dls, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc dl_locs = 6;


    pub fn get_dl_locs(&self) -> &[Loc] {
        &self.dl_locs
    }
    pub fn clear_dl_locs(&mut self) {
        self.dl_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_dl_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.dl_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dl_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.dl_locs
    }

    // Take field
    pub fn take_dl_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.dl_locs, ::protobuf::RepeatedField::new())
    }

    // .c4.ast.proto.Statement.Compound body = 7;


    pub fn get_body(&self) -> &Statement_Compound {
        self.body.as_ref().unwrap_or_else(|| Statement_Compound::default_instance())
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Statement_Compound) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Statement_Compound {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Statement_Compound {
        self.body.take().unwrap_or_else(|| Statement_Compound::new())
    }

    // .c4.ast.proto.Loc body_loc = 8;


    pub fn get_body_loc(&self) -> &Loc {
        self.body_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_body_loc(&mut self) {
        self.body_loc.clear();
    }

    pub fn has_body_loc(&self) -> bool {
        self.body_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_loc(&mut self, v: Loc) {
        self.body_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_loc(&mut self) -> &mut Loc {
        if self.body_loc.is_none() {
            self.body_loc.set_default();
        }
        self.body_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_loc(&mut self) -> Loc {
        self.body_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for FunctionDef {
    fn is_initialized(&self) -> bool {
        for v in &self.dss {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ds_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dl_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dss)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ds_locs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d_loc)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dls)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dl_locs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dss {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ds_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dl_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dss {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ds_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.d_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dls {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dl_locs {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionDef {
        FunctionDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeclarationSpecifier>>(
                    "dss",
                    |m: &FunctionDef| { &m.dss },
                    |m: &mut FunctionDef| { &mut m.dss },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ds_locs",
                    |m: &FunctionDef| { &m.ds_locs },
                    |m: &mut FunctionDef| { &mut m.ds_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declarator>>(
                    "d",
                    |m: &FunctionDef| { &m.d },
                    |m: &mut FunctionDef| { &mut m.d },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "d_loc",
                    |m: &FunctionDef| { &m.d_loc },
                    |m: &mut FunctionDef| { &mut m.d_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declaration>>(
                    "dls",
                    |m: &FunctionDef| { &m.dls },
                    |m: &mut FunctionDef| { &mut m.dls },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dl_locs",
                    |m: &FunctionDef| { &m.dl_locs },
                    |m: &mut FunctionDef| { &mut m.dl_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement_Compound>>(
                    "body",
                    |m: &FunctionDef| { &m.body },
                    |m: &mut FunctionDef| { &mut m.body },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_loc",
                    |m: &FunctionDef| { &m.body_loc },
                    |m: &mut FunctionDef| { &mut m.body_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FunctionDef>(
                    "FunctionDef",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FunctionDef {
        static mut instance: ::protobuf::lazy::Lazy<FunctionDef> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FunctionDef,
        };
        unsafe {
            instance.get(FunctionDef::new)
        }
    }
}

impl ::protobuf::Clear for FunctionDef {
    fn clear(&mut self) {
        self.dss.clear();
        self.ds_locs.clear();
        self.d.clear();
        self.d_loc.clear();
        self.dls.clear();
        self.dl_locs.clear();
        self.body.clear();
        self.body_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionDef {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement {
    // message oneof groups
    pub stmt: ::std::option::Option<Statement_oneof_stmt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement {
    fn default() -> &'a Statement {
        <Statement as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Statement_oneof_stmt {
    compound(Statement_Compound),
    labeled(Statement_Labeled),
    expr(Statement_Expr),
    if_s(Statement_If),
    switch_s(Statement_Switch),
    while_s(Statement_While),
    do_while_s(Statement_DoWhile),
    for_s(Statement_For),
    goto_s(Statement_Goto),
    continue_s(Statement_Continue),
    break_s(Statement_Break),
    return_s(Statement_Return),
}

impl Statement {
    pub fn new() -> Statement {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.Statement.Compound compound = 1;


    pub fn get_compound(&self) -> &Statement_Compound {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::compound(ref v)) => v,
            _ => Statement_Compound::default_instance(),
        }
    }
    pub fn clear_compound(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_compound(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::compound(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_compound(&mut self, v: Statement_Compound) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::compound(v))
    }

    // Mutable pointer to the field.
    pub fn mut_compound(&mut self) -> &mut Statement_Compound {
        if let ::std::option::Option::Some(Statement_oneof_stmt::compound(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::compound(Statement_Compound::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::compound(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_compound(&mut self) -> Statement_Compound {
        if self.has_compound() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::compound(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Compound::new()
        }
    }

    // .c4.ast.proto.Statement.Labeled labeled = 2;


    pub fn get_labeled(&self) -> &Statement_Labeled {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::labeled(ref v)) => v,
            _ => Statement_Labeled::default_instance(),
        }
    }
    pub fn clear_labeled(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_labeled(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::labeled(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_labeled(&mut self, v: Statement_Labeled) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::labeled(v))
    }

    // Mutable pointer to the field.
    pub fn mut_labeled(&mut self) -> &mut Statement_Labeled {
        if let ::std::option::Option::Some(Statement_oneof_stmt::labeled(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::labeled(Statement_Labeled::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::labeled(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_labeled(&mut self) -> Statement_Labeled {
        if self.has_labeled() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::labeled(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Labeled::new()
        }
    }

    // .c4.ast.proto.Statement.Expr expr = 3;


    pub fn get_expr(&self) -> &Statement_Expr {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::expr(ref v)) => v,
            _ => Statement_Expr::default_instance(),
        }
    }
    pub fn clear_expr(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_expr(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::expr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Statement_Expr) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::expr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_expr(&mut self) -> &mut Statement_Expr {
        if let ::std::option::Option::Some(Statement_oneof_stmt::expr(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::expr(Statement_Expr::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::expr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_expr(&mut self) -> Statement_Expr {
        if self.has_expr() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::expr(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Expr::new()
        }
    }

    // .c4.ast.proto.Statement.If if_s = 4;


    pub fn get_if_s(&self) -> &Statement_If {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::if_s(ref v)) => v,
            _ => Statement_If::default_instance(),
        }
    }
    pub fn clear_if_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_if_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::if_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_if_s(&mut self, v: Statement_If) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::if_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_if_s(&mut self) -> &mut Statement_If {
        if let ::std::option::Option::Some(Statement_oneof_stmt::if_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::if_s(Statement_If::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::if_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_if_s(&mut self) -> Statement_If {
        if self.has_if_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::if_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_If::new()
        }
    }

    // .c4.ast.proto.Statement.Switch switch_s = 5;


    pub fn get_switch_s(&self) -> &Statement_Switch {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::switch_s(ref v)) => v,
            _ => Statement_Switch::default_instance(),
        }
    }
    pub fn clear_switch_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_switch_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::switch_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_s(&mut self, v: Statement_Switch) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::switch_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_s(&mut self) -> &mut Statement_Switch {
        if let ::std::option::Option::Some(Statement_oneof_stmt::switch_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::switch_s(Statement_Switch::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::switch_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_s(&mut self) -> Statement_Switch {
        if self.has_switch_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::switch_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Switch::new()
        }
    }

    // .c4.ast.proto.Statement.While while_s = 6;


    pub fn get_while_s(&self) -> &Statement_While {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::while_s(ref v)) => v,
            _ => Statement_While::default_instance(),
        }
    }
    pub fn clear_while_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_while_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::while_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_while_s(&mut self, v: Statement_While) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::while_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_while_s(&mut self) -> &mut Statement_While {
        if let ::std::option::Option::Some(Statement_oneof_stmt::while_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::while_s(Statement_While::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::while_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_while_s(&mut self) -> Statement_While {
        if self.has_while_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::while_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_While::new()
        }
    }

    // .c4.ast.proto.Statement.DoWhile do_while_s = 7;


    pub fn get_do_while_s(&self) -> &Statement_DoWhile {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(ref v)) => v,
            _ => Statement_DoWhile::default_instance(),
        }
    }
    pub fn clear_do_while_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_do_while_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_do_while_s(&mut self, v: Statement_DoWhile) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_do_while_s(&mut self) -> &mut Statement_DoWhile {
        if let ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(Statement_DoWhile::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_do_while_s(&mut self) -> Statement_DoWhile {
        if self.has_do_while_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_DoWhile::new()
        }
    }

    // .c4.ast.proto.Statement.For for_s = 8;


    pub fn get_for_s(&self) -> &Statement_For {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::for_s(ref v)) => v,
            _ => Statement_For::default_instance(),
        }
    }
    pub fn clear_for_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_for_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::for_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_for_s(&mut self, v: Statement_For) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::for_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_for_s(&mut self) -> &mut Statement_For {
        if let ::std::option::Option::Some(Statement_oneof_stmt::for_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::for_s(Statement_For::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::for_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_for_s(&mut self) -> Statement_For {
        if self.has_for_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::for_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_For::new()
        }
    }

    // .c4.ast.proto.Statement.Goto goto_s = 9;


    pub fn get_goto_s(&self) -> &Statement_Goto {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::goto_s(ref v)) => v,
            _ => Statement_Goto::default_instance(),
        }
    }
    pub fn clear_goto_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_goto_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::goto_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_goto_s(&mut self, v: Statement_Goto) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::goto_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_goto_s(&mut self) -> &mut Statement_Goto {
        if let ::std::option::Option::Some(Statement_oneof_stmt::goto_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::goto_s(Statement_Goto::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::goto_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_goto_s(&mut self) -> Statement_Goto {
        if self.has_goto_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::goto_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Goto::new()
        }
    }

    // .c4.ast.proto.Statement.Continue continue_s = 10;


    pub fn get_continue_s(&self) -> &Statement_Continue {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::continue_s(ref v)) => v,
            _ => Statement_Continue::default_instance(),
        }
    }
    pub fn clear_continue_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_continue_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::continue_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_continue_s(&mut self, v: Statement_Continue) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::continue_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_continue_s(&mut self) -> &mut Statement_Continue {
        if let ::std::option::Option::Some(Statement_oneof_stmt::continue_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::continue_s(Statement_Continue::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::continue_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_continue_s(&mut self) -> Statement_Continue {
        if self.has_continue_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::continue_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Continue::new()
        }
    }

    // .c4.ast.proto.Statement.Break break_s = 11;


    pub fn get_break_s(&self) -> &Statement_Break {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::break_s(ref v)) => v,
            _ => Statement_Break::default_instance(),
        }
    }
    pub fn clear_break_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_break_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::break_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_break_s(&mut self, v: Statement_Break) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::break_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_break_s(&mut self) -> &mut Statement_Break {
        if let ::std::option::Option::Some(Statement_oneof_stmt::break_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::break_s(Statement_Break::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::break_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_break_s(&mut self) -> Statement_Break {
        if self.has_break_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::break_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Break::new()
        }
    }

    // .c4.ast.proto.Statement.Return return_s = 12;


    pub fn get_return_s(&self) -> &Statement_Return {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::return_s(ref v)) => v,
            _ => Statement_Return::default_instance(),
        }
    }
    pub fn clear_return_s(&mut self) {
        self.stmt = ::std::option::Option::None;
    }

    pub fn has_return_s(&self) -> bool {
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::return_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_return_s(&mut self, v: Statement_Return) {
        self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::return_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_return_s(&mut self) -> &mut Statement_Return {
        if let ::std::option::Option::Some(Statement_oneof_stmt::return_s(_)) = self.stmt {
        } else {
            self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::return_s(Statement_Return::new()));
        }
        match self.stmt {
            ::std::option::Option::Some(Statement_oneof_stmt::return_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_return_s(&mut self) -> Statement_Return {
        if self.has_return_s() {
            match self.stmt.take() {
                ::std::option::Option::Some(Statement_oneof_stmt::return_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Return::new()
        }
    }
}

impl ::protobuf::Message for Statement {
    fn is_initialized(&self) -> bool {
        if let Some(Statement_oneof_stmt::compound(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::labeled(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::expr(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::if_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::switch_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::while_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::do_while_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::for_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::goto_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::continue_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::break_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_oneof_stmt::return_s(ref v)) = self.stmt {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::compound(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::labeled(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::expr(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::if_s(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::switch_s(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::while_s(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::do_while_s(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::for_s(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::goto_s(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::continue_s(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::break_s(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stmt = ::std::option::Option::Some(Statement_oneof_stmt::return_s(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.stmt {
            match v {
                &Statement_oneof_stmt::compound(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::labeled(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::expr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::if_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::switch_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::while_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::do_while_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::for_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::goto_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::continue_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::break_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_oneof_stmt::return_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.stmt {
            match v {
                &Statement_oneof_stmt::compound(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::labeled(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::expr(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::if_s(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::switch_s(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::while_s(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::do_while_s(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::for_s(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::goto_s(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::continue_s(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::break_s(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_oneof_stmt::return_s(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement {
        Statement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Compound>(
                    "compound",
                    Statement::has_compound,
                    Statement::get_compound,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Labeled>(
                    "labeled",
                    Statement::has_labeled,
                    Statement::get_labeled,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Expr>(
                    "expr",
                    Statement::has_expr,
                    Statement::get_expr,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_If>(
                    "if_s",
                    Statement::has_if_s,
                    Statement::get_if_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Switch>(
                    "switch_s",
                    Statement::has_switch_s,
                    Statement::get_switch_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_While>(
                    "while_s",
                    Statement::has_while_s,
                    Statement::get_while_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_DoWhile>(
                    "do_while_s",
                    Statement::has_do_while_s,
                    Statement::get_do_while_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_For>(
                    "for_s",
                    Statement::has_for_s,
                    Statement::get_for_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Goto>(
                    "goto_s",
                    Statement::has_goto_s,
                    Statement::get_goto_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Continue>(
                    "continue_s",
                    Statement::has_continue_s,
                    Statement::get_continue_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Break>(
                    "break_s",
                    Statement::has_break_s,
                    Statement::get_break_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Return>(
                    "return_s",
                    Statement::has_return_s,
                    Statement::get_return_s,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement>(
                    "Statement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement {
        static mut instance: ::protobuf::lazy::Lazy<Statement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement,
        };
        unsafe {
            instance.get(Statement::new)
        }
    }
}

impl ::protobuf::Clear for Statement {
    fn clear(&mut self) {
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.stmt = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Compound {
    // message fields
    pub dls: ::protobuf::RepeatedField<Declaration>,
    pub dl_locs: ::protobuf::RepeatedField<Loc>,
    pub stmt_idxes: ::std::vec::Vec<i32>,
    pub stmt_locs: ::protobuf::RepeatedField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Compound {
    fn default() -> &'a Statement_Compound {
        <Statement_Compound as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Compound {
    pub fn new() -> Statement_Compound {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.Declaration dls = 1;


    pub fn get_dls(&self) -> &[Declaration] {
        &self.dls
    }
    pub fn clear_dls(&mut self) {
        self.dls.clear();
    }

    // Param is passed by value, moved
    pub fn set_dls(&mut self, v: ::protobuf::RepeatedField<Declaration>) {
        self.dls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dls(&mut self) -> &mut ::protobuf::RepeatedField<Declaration> {
        &mut self.dls
    }

    // Take field
    pub fn take_dls(&mut self) -> ::protobuf::RepeatedField<Declaration> {
        ::std::mem::replace(&mut self.dls, ::protobuf::RepeatedField::new())
    }

    // repeated .c4.ast.proto.Loc dl_locs = 2;


    pub fn get_dl_locs(&self) -> &[Loc] {
        &self.dl_locs
    }
    pub fn clear_dl_locs(&mut self) {
        self.dl_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_dl_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.dl_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dl_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.dl_locs
    }

    // Take field
    pub fn take_dl_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.dl_locs, ::protobuf::RepeatedField::new())
    }

    // repeated int32 stmt_idxes = 3;


    pub fn get_stmt_idxes(&self) -> &[i32] {
        &self.stmt_idxes
    }
    pub fn clear_stmt_idxes(&mut self) {
        self.stmt_idxes.clear();
    }

    // Param is passed by value, moved
    pub fn set_stmt_idxes(&mut self, v: ::std::vec::Vec<i32>) {
        self.stmt_idxes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stmt_idxes(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.stmt_idxes
    }

    // Take field
    pub fn take_stmt_idxes(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.stmt_idxes, ::std::vec::Vec::new())
    }

    // repeated .c4.ast.proto.Loc stmt_locs = 4;


    pub fn get_stmt_locs(&self) -> &[Loc] {
        &self.stmt_locs
    }
    pub fn clear_stmt_locs(&mut self) {
        self.stmt_locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_stmt_locs(&mut self, v: ::protobuf::RepeatedField<Loc>) {
        self.stmt_locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stmt_locs(&mut self) -> &mut ::protobuf::RepeatedField<Loc> {
        &mut self.stmt_locs
    }

    // Take field
    pub fn take_stmt_locs(&mut self) -> ::protobuf::RepeatedField<Loc> {
        ::std::mem::replace(&mut self.stmt_locs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Statement_Compound {
    fn is_initialized(&self) -> bool {
        for v in &self.dls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dl_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stmt_locs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dls)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dl_locs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.stmt_idxes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stmt_locs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dl_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stmt_idxes {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.stmt_locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dls {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dl_locs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stmt_idxes {
            os.write_int32(3, *v)?;
        };
        for v in &self.stmt_locs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Compound {
        Statement_Compound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Declaration>>(
                    "dls",
                    |m: &Statement_Compound| { &m.dls },
                    |m: &mut Statement_Compound| { &mut m.dls },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "dl_locs",
                    |m: &Statement_Compound| { &m.dl_locs },
                    |m: &mut Statement_Compound| { &mut m.dl_locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stmt_idxes",
                    |m: &Statement_Compound| { &m.stmt_idxes },
                    |m: &mut Statement_Compound| { &mut m.stmt_idxes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "stmt_locs",
                    |m: &Statement_Compound| { &m.stmt_locs },
                    |m: &mut Statement_Compound| { &mut m.stmt_locs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Compound>(
                    "Statement_Compound",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Compound {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Compound> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Compound,
        };
        unsafe {
            instance.get(Statement_Compound::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Compound {
    fn clear(&mut self) {
        self.dls.clear();
        self.dl_locs.clear();
        self.stmt_idxes.clear();
        self.stmt_locs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Compound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Compound {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Labeled {
    // message oneof groups
    pub l: ::std::option::Option<Statement_Labeled_oneof_l>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Labeled {
    fn default() -> &'a Statement_Labeled {
        <Statement_Labeled as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Statement_Labeled_oneof_l {
    id(Statement_Labeled_Id),
    case_s(Statement_Labeled_Case),
    default_s(Statement_Labeled_Default),
}

impl Statement_Labeled {
    pub fn new() -> Statement_Labeled {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.Statement.Labeled.Id id = 1;


    pub fn get_id(&self) -> &Statement_Labeled_Id {
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::id(ref v)) => v,
            _ => Statement_Labeled_Id::default_instance(),
        }
    }
    pub fn clear_id(&mut self) {
        self.l = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: Statement_Labeled_Id) {
        self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut Statement_Labeled_Id {
        if let ::std::option::Option::Some(Statement_Labeled_oneof_l::id(_)) = self.l {
        } else {
            self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::id(Statement_Labeled_Id::new()));
        }
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> Statement_Labeled_Id {
        if self.has_id() {
            match self.l.take() {
                ::std::option::Option::Some(Statement_Labeled_oneof_l::id(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Labeled_Id::new()
        }
    }

    // .c4.ast.proto.Statement.Labeled.Case case_s = 2;


    pub fn get_case_s(&self) -> &Statement_Labeled_Case {
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(ref v)) => v,
            _ => Statement_Labeled_Case::default_instance(),
        }
    }
    pub fn clear_case_s(&mut self) {
        self.l = ::std::option::Option::None;
    }

    pub fn has_case_s(&self) -> bool {
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_case_s(&mut self, v: Statement_Labeled_Case) {
        self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_case_s(&mut self) -> &mut Statement_Labeled_Case {
        if let ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(_)) = self.l {
        } else {
            self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(Statement_Labeled_Case::new()));
        }
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_case_s(&mut self) -> Statement_Labeled_Case {
        if self.has_case_s() {
            match self.l.take() {
                ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Labeled_Case::new()
        }
    }

    // .c4.ast.proto.Statement.Labeled.Default default_s = 3;


    pub fn get_default_s(&self) -> &Statement_Labeled_Default {
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(ref v)) => v,
            _ => Statement_Labeled_Default::default_instance(),
        }
    }
    pub fn clear_default_s(&mut self) {
        self.l = ::std::option::Option::None;
    }

    pub fn has_default_s(&self) -> bool {
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_s(&mut self, v: Statement_Labeled_Default) {
        self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_s(&mut self) -> &mut Statement_Labeled_Default {
        if let ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(_)) = self.l {
        } else {
            self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(Statement_Labeled_Default::new()));
        }
        match self.l {
            ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_s(&mut self) -> Statement_Labeled_Default {
        if self.has_default_s() {
            match self.l.take() {
                ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(v)) => v,
                _ => panic!(),
            }
        } else {
            Statement_Labeled_Default::new()
        }
    }
}

impl ::protobuf::Message for Statement_Labeled {
    fn is_initialized(&self) -> bool {
        if let Some(Statement_Labeled_oneof_l::id(ref v)) = self.l {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_Labeled_oneof_l::case_s(ref v)) = self.l {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Statement_Labeled_oneof_l::default_s(ref v)) = self.l {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::id(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::case_s(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.l = ::std::option::Option::Some(Statement_Labeled_oneof_l::default_s(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.l {
            match v {
                &Statement_Labeled_oneof_l::id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_Labeled_oneof_l::case_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Statement_Labeled_oneof_l::default_s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.l {
            match v {
                &Statement_Labeled_oneof_l::id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_Labeled_oneof_l::case_s(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Statement_Labeled_oneof_l::default_s(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Labeled {
        Statement_Labeled::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Labeled_Id>(
                    "id",
                    Statement_Labeled::has_id,
                    Statement_Labeled::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Labeled_Case>(
                    "case_s",
                    Statement_Labeled::has_case_s,
                    Statement_Labeled::get_case_s,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Statement_Labeled_Default>(
                    "default_s",
                    Statement_Labeled::has_default_s,
                    Statement_Labeled::get_default_s,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Labeled>(
                    "Statement_Labeled",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Labeled {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Labeled> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Labeled,
        };
        unsafe {
            instance.get(Statement_Labeled::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Labeled {
    fn clear(&mut self) {
        self.l = ::std::option::Option::None;
        self.l = ::std::option::Option::None;
        self.l = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Labeled {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Labeled {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Labeled_Id {
    // message fields
    pub id: ::std::string::String,
    pub id_loc: ::protobuf::SingularPtrField<Loc>,
    pub stmt_idx: i32,
    pub stmt_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Labeled_Id {
    fn default() -> &'a Statement_Labeled_Id {
        <Statement_Labeled_Id as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Labeled_Id {
    pub fn new() -> Statement_Labeled_Id {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc id_loc = 2;


    pub fn get_id_loc(&self) -> &Loc {
        self.id_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_id_loc(&mut self) {
        self.id_loc.clear();
    }

    pub fn has_id_loc(&self) -> bool {
        self.id_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_loc(&mut self, v: Loc) {
        self.id_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_loc(&mut self) -> &mut Loc {
        if self.id_loc.is_none() {
            self.id_loc.set_default();
        }
        self.id_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_id_loc(&mut self) -> Loc {
        self.id_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 stmt_idx = 3;


    pub fn get_stmt_idx(&self) -> i32 {
        self.stmt_idx
    }
    pub fn clear_stmt_idx(&mut self) {
        self.stmt_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_stmt_idx(&mut self, v: i32) {
        self.stmt_idx = v;
    }

    // .c4.ast.proto.Loc stmt_loc = 4;


    pub fn get_stmt_loc(&self) -> &Loc {
        self.stmt_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_stmt_loc(&mut self) {
        self.stmt_loc.clear();
    }

    pub fn has_stmt_loc(&self) -> bool {
        self.stmt_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stmt_loc(&mut self, v: Loc) {
        self.stmt_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stmt_loc(&mut self) -> &mut Loc {
        if self.stmt_loc.is_none() {
            self.stmt_loc.set_default();
        }
        self.stmt_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_stmt_loc(&mut self) -> Loc {
        self.stmt_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Labeled_Id {
    fn is_initialized(&self) -> bool {
        for v in &self.id_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stmt_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stmt_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stmt_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.id_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stmt_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.stmt_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stmt_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.id_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stmt_idx != 0 {
            os.write_int32(3, self.stmt_idx)?;
        }
        if let Some(ref v) = self.stmt_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Labeled_Id {
        Statement_Labeled_Id::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Statement_Labeled_Id| { &m.id },
                    |m: &mut Statement_Labeled_Id| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "id_loc",
                    |m: &Statement_Labeled_Id| { &m.id_loc },
                    |m: &mut Statement_Labeled_Id| { &mut m.id_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stmt_idx",
                    |m: &Statement_Labeled_Id| { &m.stmt_idx },
                    |m: &mut Statement_Labeled_Id| { &mut m.stmt_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "stmt_loc",
                    |m: &Statement_Labeled_Id| { &m.stmt_loc },
                    |m: &mut Statement_Labeled_Id| { &mut m.stmt_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Labeled_Id>(
                    "Statement_Labeled_Id",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Labeled_Id {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Labeled_Id> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Labeled_Id,
        };
        unsafe {
            instance.get(Statement_Labeled_Id::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Labeled_Id {
    fn clear(&mut self) {
        self.id.clear();
        self.id_loc.clear();
        self.stmt_idx = 0;
        self.stmt_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Labeled_Id {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Labeled_Id {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Labeled_Case {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    pub stmt_idx: i32,
    pub stmt_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Labeled_Case {
    fn default() -> &'a Statement_Labeled_Case {
        <Statement_Labeled_Case as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Labeled_Case {
    pub fn new() -> Statement_Labeled_Case {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 stmt_idx = 3;


    pub fn get_stmt_idx(&self) -> i32 {
        self.stmt_idx
    }
    pub fn clear_stmt_idx(&mut self) {
        self.stmt_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_stmt_idx(&mut self, v: i32) {
        self.stmt_idx = v;
    }

    // .c4.ast.proto.Loc stmt_loc = 4;


    pub fn get_stmt_loc(&self) -> &Loc {
        self.stmt_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_stmt_loc(&mut self) {
        self.stmt_loc.clear();
    }

    pub fn has_stmt_loc(&self) -> bool {
        self.stmt_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stmt_loc(&mut self, v: Loc) {
        self.stmt_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stmt_loc(&mut self) -> &mut Loc {
        if self.stmt_loc.is_none() {
            self.stmt_loc.set_default();
        }
        self.stmt_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_stmt_loc(&mut self) -> Loc {
        self.stmt_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Labeled_Case {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stmt_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stmt_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stmt_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stmt_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.stmt_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stmt_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stmt_idx != 0 {
            os.write_int32(3, self.stmt_idx)?;
        }
        if let Some(ref v) = self.stmt_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Labeled_Case {
        Statement_Labeled_Case::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Statement_Labeled_Case| { &m.e_idx },
                    |m: &mut Statement_Labeled_Case| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Statement_Labeled_Case| { &m.e_loc },
                    |m: &mut Statement_Labeled_Case| { &mut m.e_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stmt_idx",
                    |m: &Statement_Labeled_Case| { &m.stmt_idx },
                    |m: &mut Statement_Labeled_Case| { &mut m.stmt_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "stmt_loc",
                    |m: &Statement_Labeled_Case| { &m.stmt_loc },
                    |m: &mut Statement_Labeled_Case| { &mut m.stmt_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Labeled_Case>(
                    "Statement_Labeled_Case",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Labeled_Case {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Labeled_Case> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Labeled_Case,
        };
        unsafe {
            instance.get(Statement_Labeled_Case::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Labeled_Case {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.stmt_idx = 0;
        self.stmt_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Labeled_Case {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Labeled_Case {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Labeled_Default {
    // message fields
    pub stmt_idx: i32,
    pub stmt_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Labeled_Default {
    fn default() -> &'a Statement_Labeled_Default {
        <Statement_Labeled_Default as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Labeled_Default {
    pub fn new() -> Statement_Labeled_Default {
        ::std::default::Default::default()
    }

    // int32 stmt_idx = 1;


    pub fn get_stmt_idx(&self) -> i32 {
        self.stmt_idx
    }
    pub fn clear_stmt_idx(&mut self) {
        self.stmt_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_stmt_idx(&mut self, v: i32) {
        self.stmt_idx = v;
    }

    // .c4.ast.proto.Loc stmt_loc = 2;


    pub fn get_stmt_loc(&self) -> &Loc {
        self.stmt_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_stmt_loc(&mut self) {
        self.stmt_loc.clear();
    }

    pub fn has_stmt_loc(&self) -> bool {
        self.stmt_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stmt_loc(&mut self, v: Loc) {
        self.stmt_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stmt_loc(&mut self) -> &mut Loc {
        if self.stmt_loc.is_none() {
            self.stmt_loc.set_default();
        }
        self.stmt_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_stmt_loc(&mut self) -> Loc {
        self.stmt_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Labeled_Default {
    fn is_initialized(&self) -> bool {
        for v in &self.stmt_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stmt_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stmt_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.stmt_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.stmt_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stmt_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.stmt_idx != 0 {
            os.write_int32(1, self.stmt_idx)?;
        }
        if let Some(ref v) = self.stmt_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Labeled_Default {
        Statement_Labeled_Default::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stmt_idx",
                    |m: &Statement_Labeled_Default| { &m.stmt_idx },
                    |m: &mut Statement_Labeled_Default| { &mut m.stmt_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "stmt_loc",
                    |m: &Statement_Labeled_Default| { &m.stmt_loc },
                    |m: &mut Statement_Labeled_Default| { &mut m.stmt_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Labeled_Default>(
                    "Statement_Labeled_Default",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Labeled_Default {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Labeled_Default> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Labeled_Default,
        };
        unsafe {
            instance.get(Statement_Labeled_Default::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Labeled_Default {
    fn clear(&mut self) {
        self.stmt_idx = 0;
        self.stmt_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Labeled_Default {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Labeled_Default {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Expr {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Expr {
    fn default() -> &'a Statement_Expr {
        <Statement_Expr as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Expr {
    pub fn new() -> Statement_Expr {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Expr {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Expr {
        Statement_Expr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Statement_Expr| { &m.e_idx },
                    |m: &mut Statement_Expr| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Statement_Expr| { &m.e_loc },
                    |m: &mut Statement_Expr| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Expr>(
                    "Statement_Expr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Expr {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Expr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Expr,
        };
        unsafe {
            instance.get(Statement_Expr::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Expr {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Expr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_If {
    // message fields
    pub cond_idx: i32,
    pub cond_loc: ::protobuf::SingularPtrField<Loc>,
    pub then_idx: i32,
    pub then_loc: ::protobuf::SingularPtrField<Loc>,
    pub else_idx: i32,
    pub else_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_If {
    fn default() -> &'a Statement_If {
        <Statement_If as ::protobuf::Message>::default_instance()
    }
}

impl Statement_If {
    pub fn new() -> Statement_If {
        ::std::default::Default::default()
    }

    // int32 cond_idx = 1;


    pub fn get_cond_idx(&self) -> i32 {
        self.cond_idx
    }
    pub fn clear_cond_idx(&mut self) {
        self.cond_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_cond_idx(&mut self, v: i32) {
        self.cond_idx = v;
    }

    // .c4.ast.proto.Loc cond_loc = 2;


    pub fn get_cond_loc(&self) -> &Loc {
        self.cond_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_cond_loc(&mut self) {
        self.cond_loc.clear();
    }

    pub fn has_cond_loc(&self) -> bool {
        self.cond_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cond_loc(&mut self, v: Loc) {
        self.cond_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cond_loc(&mut self) -> &mut Loc {
        if self.cond_loc.is_none() {
            self.cond_loc.set_default();
        }
        self.cond_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_cond_loc(&mut self) -> Loc {
        self.cond_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 then_idx = 3;


    pub fn get_then_idx(&self) -> i32 {
        self.then_idx
    }
    pub fn clear_then_idx(&mut self) {
        self.then_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_then_idx(&mut self, v: i32) {
        self.then_idx = v;
    }

    // .c4.ast.proto.Loc then_loc = 4;


    pub fn get_then_loc(&self) -> &Loc {
        self.then_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_then_loc(&mut self) {
        self.then_loc.clear();
    }

    pub fn has_then_loc(&self) -> bool {
        self.then_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_then_loc(&mut self, v: Loc) {
        self.then_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_then_loc(&mut self) -> &mut Loc {
        if self.then_loc.is_none() {
            self.then_loc.set_default();
        }
        self.then_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_then_loc(&mut self) -> Loc {
        self.then_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 else_idx = 5;


    pub fn get_else_idx(&self) -> i32 {
        self.else_idx
    }
    pub fn clear_else_idx(&mut self) {
        self.else_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_else_idx(&mut self, v: i32) {
        self.else_idx = v;
    }

    // .c4.ast.proto.Loc else_loc = 6;


    pub fn get_else_loc(&self) -> &Loc {
        self.else_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_else_loc(&mut self) {
        self.else_loc.clear();
    }

    pub fn has_else_loc(&self) -> bool {
        self.else_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_else_loc(&mut self, v: Loc) {
        self.else_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_else_loc(&mut self) -> &mut Loc {
        if self.else_loc.is_none() {
            self.else_loc.set_default();
        }
        self.else_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_else_loc(&mut self) -> Loc {
        self.else_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_If {
    fn is_initialized(&self) -> bool {
        for v in &self.cond_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.else_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cond_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cond_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.then_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.then_loc)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.else_idx = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.else_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cond_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cond_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cond_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.then_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.then_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.then_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.else_idx != 0 {
            my_size += ::protobuf::rt::value_size(5, self.else_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.else_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cond_idx != 0 {
            os.write_int32(1, self.cond_idx)?;
        }
        if let Some(ref v) = self.cond_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.then_idx != 0 {
            os.write_int32(3, self.then_idx)?;
        }
        if let Some(ref v) = self.then_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.else_idx != 0 {
            os.write_int32(5, self.else_idx)?;
        }
        if let Some(ref v) = self.else_loc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_If {
        Statement_If::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cond_idx",
                    |m: &Statement_If| { &m.cond_idx },
                    |m: &mut Statement_If| { &mut m.cond_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "cond_loc",
                    |m: &Statement_If| { &m.cond_loc },
                    |m: &mut Statement_If| { &mut m.cond_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "then_idx",
                    |m: &Statement_If| { &m.then_idx },
                    |m: &mut Statement_If| { &mut m.then_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "then_loc",
                    |m: &Statement_If| { &m.then_loc },
                    |m: &mut Statement_If| { &mut m.then_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "else_idx",
                    |m: &Statement_If| { &m.else_idx },
                    |m: &mut Statement_If| { &mut m.else_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "else_loc",
                    |m: &Statement_If| { &m.else_loc },
                    |m: &mut Statement_If| { &mut m.else_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_If>(
                    "Statement_If",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_If {
        static mut instance: ::protobuf::lazy::Lazy<Statement_If> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_If,
        };
        unsafe {
            instance.get(Statement_If::new)
        }
    }
}

impl ::protobuf::Clear for Statement_If {
    fn clear(&mut self) {
        self.cond_idx = 0;
        self.cond_loc.clear();
        self.then_idx = 0;
        self.then_loc.clear();
        self.else_idx = 0;
        self.else_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_If {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_If {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Switch {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    pub body_idx: i32,
    pub body_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Switch {
    fn default() -> &'a Statement_Switch {
        <Statement_Switch as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Switch {
    pub fn new() -> Statement_Switch {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 body_idx = 3;


    pub fn get_body_idx(&self) -> i32 {
        self.body_idx
    }
    pub fn clear_body_idx(&mut self) {
        self.body_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_body_idx(&mut self, v: i32) {
        self.body_idx = v;
    }

    // .c4.ast.proto.Loc body_loc = 4;


    pub fn get_body_loc(&self) -> &Loc {
        self.body_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_body_loc(&mut self) {
        self.body_loc.clear();
    }

    pub fn has_body_loc(&self) -> bool {
        self.body_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_loc(&mut self, v: Loc) {
        self.body_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_loc(&mut self) -> &mut Loc {
        if self.body_loc.is_none() {
            self.body_loc.set_default();
        }
        self.body_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_loc(&mut self) -> Loc {
        self.body_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Switch {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.body_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.body_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.body_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.body_idx != 0 {
            os.write_int32(3, self.body_idx)?;
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Switch {
        Statement_Switch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Statement_Switch| { &m.e_idx },
                    |m: &mut Statement_Switch| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Statement_Switch| { &m.e_loc },
                    |m: &mut Statement_Switch| { &mut m.e_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "body_idx",
                    |m: &Statement_Switch| { &m.body_idx },
                    |m: &mut Statement_Switch| { &mut m.body_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_loc",
                    |m: &Statement_Switch| { &m.body_loc },
                    |m: &mut Statement_Switch| { &mut m.body_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Switch>(
                    "Statement_Switch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Switch {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Switch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Switch,
        };
        unsafe {
            instance.get(Statement_Switch::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Switch {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.body_idx = 0;
        self.body_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Switch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Switch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_While {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    pub body_idx: i32,
    pub body_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_While {
    fn default() -> &'a Statement_While {
        <Statement_While as ::protobuf::Message>::default_instance()
    }
}

impl Statement_While {
    pub fn new() -> Statement_While {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 body_idx = 3;


    pub fn get_body_idx(&self) -> i32 {
        self.body_idx
    }
    pub fn clear_body_idx(&mut self) {
        self.body_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_body_idx(&mut self, v: i32) {
        self.body_idx = v;
    }

    // .c4.ast.proto.Loc body_loc = 4;


    pub fn get_body_loc(&self) -> &Loc {
        self.body_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_body_loc(&mut self) {
        self.body_loc.clear();
    }

    pub fn has_body_loc(&self) -> bool {
        self.body_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_loc(&mut self, v: Loc) {
        self.body_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_loc(&mut self) -> &mut Loc {
        if self.body_loc.is_none() {
            self.body_loc.set_default();
        }
        self.body_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_loc(&mut self) -> Loc {
        self.body_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_While {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.body_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.body_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.body_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.body_idx != 0 {
            os.write_int32(3, self.body_idx)?;
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_While {
        Statement_While::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Statement_While| { &m.e_idx },
                    |m: &mut Statement_While| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Statement_While| { &m.e_loc },
                    |m: &mut Statement_While| { &mut m.e_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "body_idx",
                    |m: &Statement_While| { &m.body_idx },
                    |m: &mut Statement_While| { &mut m.body_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_loc",
                    |m: &Statement_While| { &m.body_loc },
                    |m: &mut Statement_While| { &mut m.body_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_While>(
                    "Statement_While",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_While {
        static mut instance: ::protobuf::lazy::Lazy<Statement_While> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_While,
        };
        unsafe {
            instance.get(Statement_While::new)
        }
    }
}

impl ::protobuf::Clear for Statement_While {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.body_idx = 0;
        self.body_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_While {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_While {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_DoWhile {
    // message fields
    pub body_idx: i32,
    pub body_loc: ::protobuf::SingularPtrField<Loc>,
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_DoWhile {
    fn default() -> &'a Statement_DoWhile {
        <Statement_DoWhile as ::protobuf::Message>::default_instance()
    }
}

impl Statement_DoWhile {
    pub fn new() -> Statement_DoWhile {
        ::std::default::Default::default()
    }

    // int32 body_idx = 1;


    pub fn get_body_idx(&self) -> i32 {
        self.body_idx
    }
    pub fn clear_body_idx(&mut self) {
        self.body_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_body_idx(&mut self, v: i32) {
        self.body_idx = v;
    }

    // .c4.ast.proto.Loc body_loc = 2;


    pub fn get_body_loc(&self) -> &Loc {
        self.body_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_body_loc(&mut self) {
        self.body_loc.clear();
    }

    pub fn has_body_loc(&self) -> bool {
        self.body_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_loc(&mut self, v: Loc) {
        self.body_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_loc(&mut self) -> &mut Loc {
        if self.body_loc.is_none() {
            self.body_loc.set_default();
        }
        self.body_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_loc(&mut self) -> Loc {
        self.body_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 e_idx = 3;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 4;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_DoWhile {
    fn is_initialized(&self) -> bool {
        for v in &self.body_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.body_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.body_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.body_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.body_idx != 0 {
            os.write_int32(1, self.body_idx)?;
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.e_idx != 0 {
            os.write_int32(3, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_DoWhile {
        Statement_DoWhile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "body_idx",
                    |m: &Statement_DoWhile| { &m.body_idx },
                    |m: &mut Statement_DoWhile| { &mut m.body_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_loc",
                    |m: &Statement_DoWhile| { &m.body_loc },
                    |m: &mut Statement_DoWhile| { &mut m.body_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Statement_DoWhile| { &m.e_idx },
                    |m: &mut Statement_DoWhile| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Statement_DoWhile| { &m.e_loc },
                    |m: &mut Statement_DoWhile| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_DoWhile>(
                    "Statement_DoWhile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_DoWhile {
        static mut instance: ::protobuf::lazy::Lazy<Statement_DoWhile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_DoWhile,
        };
        unsafe {
            instance.get(Statement_DoWhile::new)
        }
    }
}

impl ::protobuf::Clear for Statement_DoWhile {
    fn clear(&mut self) {
        self.body_idx = 0;
        self.body_loc.clear();
        self.e_idx = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_DoWhile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_DoWhile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_For {
    // message fields
    pub e1_idx: i32,
    pub e1_loc: ::protobuf::SingularPtrField<Loc>,
    pub e2_idx: i32,
    pub e2_loc: ::protobuf::SingularPtrField<Loc>,
    pub e3_idx: i32,
    pub e3_loc: ::protobuf::SingularPtrField<Loc>,
    pub body_idx: i32,
    pub body_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_For {
    fn default() -> &'a Statement_For {
        <Statement_For as ::protobuf::Message>::default_instance()
    }
}

impl Statement_For {
    pub fn new() -> Statement_For {
        ::std::default::Default::default()
    }

    // int32 e1_idx = 1;


    pub fn get_e1_idx(&self) -> i32 {
        self.e1_idx
    }
    pub fn clear_e1_idx(&mut self) {
        self.e1_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e1_idx(&mut self, v: i32) {
        self.e1_idx = v;
    }

    // .c4.ast.proto.Loc e1_loc = 2;


    pub fn get_e1_loc(&self) -> &Loc {
        self.e1_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e1_loc(&mut self) {
        self.e1_loc.clear();
    }

    pub fn has_e1_loc(&self) -> bool {
        self.e1_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e1_loc(&mut self, v: Loc) {
        self.e1_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e1_loc(&mut self) -> &mut Loc {
        if self.e1_loc.is_none() {
            self.e1_loc.set_default();
        }
        self.e1_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e1_loc(&mut self) -> Loc {
        self.e1_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 e2_idx = 3;


    pub fn get_e2_idx(&self) -> i32 {
        self.e2_idx
    }
    pub fn clear_e2_idx(&mut self) {
        self.e2_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e2_idx(&mut self, v: i32) {
        self.e2_idx = v;
    }

    // .c4.ast.proto.Loc e2_loc = 4;


    pub fn get_e2_loc(&self) -> &Loc {
        self.e2_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e2_loc(&mut self) {
        self.e2_loc.clear();
    }

    pub fn has_e2_loc(&self) -> bool {
        self.e2_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2_loc(&mut self, v: Loc) {
        self.e2_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e2_loc(&mut self) -> &mut Loc {
        if self.e2_loc.is_none() {
            self.e2_loc.set_default();
        }
        self.e2_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e2_loc(&mut self) -> Loc {
        self.e2_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 e3_idx = 5;


    pub fn get_e3_idx(&self) -> i32 {
        self.e3_idx
    }
    pub fn clear_e3_idx(&mut self) {
        self.e3_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e3_idx(&mut self, v: i32) {
        self.e3_idx = v;
    }

    // .c4.ast.proto.Loc e3_loc = 6;


    pub fn get_e3_loc(&self) -> &Loc {
        self.e3_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e3_loc(&mut self) {
        self.e3_loc.clear();
    }

    pub fn has_e3_loc(&self) -> bool {
        self.e3_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e3_loc(&mut self, v: Loc) {
        self.e3_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e3_loc(&mut self) -> &mut Loc {
        if self.e3_loc.is_none() {
            self.e3_loc.set_default();
        }
        self.e3_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e3_loc(&mut self) -> Loc {
        self.e3_loc.take().unwrap_or_else(|| Loc::new())
    }

    // int32 body_idx = 7;


    pub fn get_body_idx(&self) -> i32 {
        self.body_idx
    }
    pub fn clear_body_idx(&mut self) {
        self.body_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_body_idx(&mut self, v: i32) {
        self.body_idx = v;
    }

    // .c4.ast.proto.Loc body_loc = 8;


    pub fn get_body_loc(&self) -> &Loc {
        self.body_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_body_loc(&mut self) {
        self.body_loc.clear();
    }

    pub fn has_body_loc(&self) -> bool {
        self.body_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_loc(&mut self, v: Loc) {
        self.body_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_loc(&mut self) -> &mut Loc {
        if self.body_loc.is_none() {
            self.body_loc.set_default();
        }
        self.body_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_loc(&mut self) -> Loc {
        self.body_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_For {
    fn is_initialized(&self) -> bool {
        for v in &self.e1_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.e2_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.e3_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e1_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e1_loc)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e2_idx = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e2_loc)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e3_idx = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e3_loc)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.body_idx = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e1_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e1_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e1_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.e2_idx != 0 {
            my_size += ::protobuf::rt::value_size(3, self.e2_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e2_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.e3_idx != 0 {
            my_size += ::protobuf::rt::value_size(5, self.e3_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e3_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.body_idx != 0 {
            my_size += ::protobuf::rt::value_size(7, self.body_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e1_idx != 0 {
            os.write_int32(1, self.e1_idx)?;
        }
        if let Some(ref v) = self.e1_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.e2_idx != 0 {
            os.write_int32(3, self.e2_idx)?;
        }
        if let Some(ref v) = self.e2_loc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.e3_idx != 0 {
            os.write_int32(5, self.e3_idx)?;
        }
        if let Some(ref v) = self.e3_loc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.body_idx != 0 {
            os.write_int32(7, self.body_idx)?;
        }
        if let Some(ref v) = self.body_loc.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_For {
        Statement_For::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e1_idx",
                    |m: &Statement_For| { &m.e1_idx },
                    |m: &mut Statement_For| { &mut m.e1_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e1_loc",
                    |m: &Statement_For| { &m.e1_loc },
                    |m: &mut Statement_For| { &mut m.e1_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e2_idx",
                    |m: &Statement_For| { &m.e2_idx },
                    |m: &mut Statement_For| { &mut m.e2_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e2_loc",
                    |m: &Statement_For| { &m.e2_loc },
                    |m: &mut Statement_For| { &mut m.e2_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e3_idx",
                    |m: &Statement_For| { &m.e3_idx },
                    |m: &mut Statement_For| { &mut m.e3_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e3_loc",
                    |m: &Statement_For| { &m.e3_loc },
                    |m: &mut Statement_For| { &mut m.e3_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "body_idx",
                    |m: &Statement_For| { &m.body_idx },
                    |m: &mut Statement_For| { &mut m.body_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "body_loc",
                    |m: &Statement_For| { &m.body_loc },
                    |m: &mut Statement_For| { &mut m.body_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_For>(
                    "Statement_For",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_For {
        static mut instance: ::protobuf::lazy::Lazy<Statement_For> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_For,
        };
        unsafe {
            instance.get(Statement_For::new)
        }
    }
}

impl ::protobuf::Clear for Statement_For {
    fn clear(&mut self) {
        self.e1_idx = 0;
        self.e1_loc.clear();
        self.e2_idx = 0;
        self.e2_loc.clear();
        self.e3_idx = 0;
        self.e3_loc.clear();
        self.body_idx = 0;
        self.body_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_For {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_For {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Goto {
    // message fields
    pub id: ::std::string::String,
    pub id_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Goto {
    fn default() -> &'a Statement_Goto {
        <Statement_Goto as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Goto {
    pub fn new() -> Statement_Goto {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .c4.ast.proto.Loc id_loc = 2;


    pub fn get_id_loc(&self) -> &Loc {
        self.id_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_id_loc(&mut self) {
        self.id_loc.clear();
    }

    pub fn has_id_loc(&self) -> bool {
        self.id_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_loc(&mut self, v: Loc) {
        self.id_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_loc(&mut self) -> &mut Loc {
        if self.id_loc.is_none() {
            self.id_loc.set_default();
        }
        self.id_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_id_loc(&mut self) -> Loc {
        self.id_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Goto {
    fn is_initialized(&self) -> bool {
        for v in &self.id_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.id_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.id_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Goto {
        Statement_Goto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Statement_Goto| { &m.id },
                    |m: &mut Statement_Goto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "id_loc",
                    |m: &Statement_Goto| { &m.id_loc },
                    |m: &mut Statement_Goto| { &mut m.id_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Goto>(
                    "Statement_Goto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Goto {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Goto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Goto,
        };
        unsafe {
            instance.get(Statement_Goto::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Goto {
    fn clear(&mut self) {
        self.id.clear();
        self.id_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Goto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Goto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Continue {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Continue {
    fn default() -> &'a Statement_Continue {
        <Statement_Continue as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Continue {
    pub fn new() -> Statement_Continue {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Statement_Continue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Continue {
        Statement_Continue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Continue>(
                    "Statement_Continue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Continue {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Continue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Continue,
        };
        unsafe {
            instance.get(Statement_Continue::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Continue {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Continue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Continue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Break {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Break {
    fn default() -> &'a Statement_Break {
        <Statement_Break as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Break {
    pub fn new() -> Statement_Break {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Statement_Break {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Break {
        Statement_Break::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Break>(
                    "Statement_Break",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Break {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Break> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Break,
        };
        unsafe {
            instance.get(Statement_Break::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Break {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Break {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Break {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement_Return {
    // message fields
    pub e_idx: i32,
    pub e_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement_Return {
    fn default() -> &'a Statement_Return {
        <Statement_Return as ::protobuf::Message>::default_instance()
    }
}

impl Statement_Return {
    pub fn new() -> Statement_Return {
        ::std::default::Default::default()
    }

    // int32 e_idx = 1;


    pub fn get_e_idx(&self) -> i32 {
        self.e_idx
    }
    pub fn clear_e_idx(&mut self) {
        self.e_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_e_idx(&mut self, v: i32) {
        self.e_idx = v;
    }

    // .c4.ast.proto.Loc e_loc = 2;


    pub fn get_e_loc(&self) -> &Loc {
        self.e_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_e_loc(&mut self) {
        self.e_loc.clear();
    }

    pub fn has_e_loc(&self) -> bool {
        self.e_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e_loc(&mut self, v: Loc) {
        self.e_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_e_loc(&mut self) -> &mut Loc {
        if self.e_loc.is_none() {
            self.e_loc.set_default();
        }
        self.e_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_e_loc(&mut self) -> Loc {
        self.e_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for Statement_Return {
    fn is_initialized(&self) -> bool {
        for v in &self.e_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.e_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.e_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.e_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.e_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.e_idx != 0 {
            os.write_int32(1, self.e_idx)?;
        }
        if let Some(ref v) = self.e_loc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement_Return {
        Statement_Return::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "e_idx",
                    |m: &Statement_Return| { &m.e_idx },
                    |m: &mut Statement_Return| { &mut m.e_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "e_loc",
                    |m: &Statement_Return| { &m.e_loc },
                    |m: &mut Statement_Return| { &mut m.e_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement_Return>(
                    "Statement_Return",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement_Return {
        static mut instance: ::protobuf::lazy::Lazy<Statement_Return> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement_Return,
        };
        unsafe {
            instance.get(Statement_Return::new)
        }
    }
}

impl ::protobuf::Clear for Statement_Return {
    fn clear(&mut self) {
        self.e_idx = 0;
        self.e_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement_Return {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement_Return {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeName {
    // message fields
    pub sp_qls: ::protobuf::RepeatedField<TypeName_SpQl>,
    pub ad: ::protobuf::SingularPtrField<AbstractDeclarator>,
    pub ad_loc: ::protobuf::SingularPtrField<Loc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeName {
    fn default() -> &'a TypeName {
        <TypeName as ::protobuf::Message>::default_instance()
    }
}

impl TypeName {
    pub fn new() -> TypeName {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.TypeName.SpQl sp_qls = 1;


    pub fn get_sp_qls(&self) -> &[TypeName_SpQl] {
        &self.sp_qls
    }
    pub fn clear_sp_qls(&mut self) {
        self.sp_qls.clear();
    }

    // Param is passed by value, moved
    pub fn set_sp_qls(&mut self, v: ::protobuf::RepeatedField<TypeName_SpQl>) {
        self.sp_qls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sp_qls(&mut self) -> &mut ::protobuf::RepeatedField<TypeName_SpQl> {
        &mut self.sp_qls
    }

    // Take field
    pub fn take_sp_qls(&mut self) -> ::protobuf::RepeatedField<TypeName_SpQl> {
        ::std::mem::replace(&mut self.sp_qls, ::protobuf::RepeatedField::new())
    }

    // .c4.ast.proto.AbstractDeclarator ad = 2;


    pub fn get_ad(&self) -> &AbstractDeclarator {
        self.ad.as_ref().unwrap_or_else(|| AbstractDeclarator::default_instance())
    }
    pub fn clear_ad(&mut self) {
        self.ad.clear();
    }

    pub fn has_ad(&self) -> bool {
        self.ad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ad(&mut self, v: AbstractDeclarator) {
        self.ad = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ad(&mut self) -> &mut AbstractDeclarator {
        if self.ad.is_none() {
            self.ad.set_default();
        }
        self.ad.as_mut().unwrap()
    }

    // Take field
    pub fn take_ad(&mut self) -> AbstractDeclarator {
        self.ad.take().unwrap_or_else(|| AbstractDeclarator::new())
    }

    // .c4.ast.proto.Loc ad_loc = 3;


    pub fn get_ad_loc(&self) -> &Loc {
        self.ad_loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_ad_loc(&mut self) {
        self.ad_loc.clear();
    }

    pub fn has_ad_loc(&self) -> bool {
        self.ad_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ad_loc(&mut self, v: Loc) {
        self.ad_loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ad_loc(&mut self) -> &mut Loc {
        if self.ad_loc.is_none() {
            self.ad_loc.set_default();
        }
        self.ad_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_ad_loc(&mut self) -> Loc {
        self.ad_loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for TypeName {
    fn is_initialized(&self) -> bool {
        for v in &self.sp_qls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ad {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ad_loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sp_qls)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ad)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ad_loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sp_qls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.ad.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ad_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sp_qls {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.ad.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ad_loc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeName {
        TypeName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeName_SpQl>>(
                    "sp_qls",
                    |m: &TypeName| { &m.sp_qls },
                    |m: &mut TypeName| { &mut m.sp_qls },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AbstractDeclarator>>(
                    "ad",
                    |m: &TypeName| { &m.ad },
                    |m: &mut TypeName| { &mut m.ad },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "ad_loc",
                    |m: &TypeName| { &m.ad_loc },
                    |m: &mut TypeName| { &mut m.ad_loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeName>(
                    "TypeName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeName {
        static mut instance: ::protobuf::lazy::Lazy<TypeName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeName,
        };
        unsafe {
            instance.get(TypeName::new)
        }
    }
}

impl ::protobuf::Clear for TypeName {
    fn clear(&mut self) {
        self.sp_qls.clear();
        self.ad.clear();
        self.ad_loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeName_SpQl {
    // message fields
    pub loc: ::protobuf::SingularPtrField<Loc>,
    // message oneof groups
    pub elem: ::std::option::Option<TypeName_SpQl_oneof_elem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeName_SpQl {
    fn default() -> &'a TypeName_SpQl {
        <TypeName_SpQl as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TypeName_SpQl_oneof_elem {
    sp(TypeSpecifier),
    ql(TypeQualifier),
}

impl TypeName_SpQl {
    pub fn new() -> TypeName_SpQl {
        ::std::default::Default::default()
    }

    // .c4.ast.proto.TypeSpecifier sp = 1;


    pub fn get_sp(&self) -> &TypeSpecifier {
        match self.elem {
            ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(ref v)) => v,
            _ => TypeSpecifier::default_instance(),
        }
    }
    pub fn clear_sp(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_sp(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sp(&mut self, v: TypeSpecifier) {
        self.elem = ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sp(&mut self) -> &mut TypeSpecifier {
        if let ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(_)) = self.elem {
        } else {
            self.elem = ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(TypeSpecifier::new()));
        }
        match self.elem {
            ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sp(&mut self) -> TypeSpecifier {
        if self.has_sp() {
            match self.elem.take() {
                ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeSpecifier::new()
        }
    }

    // .c4.ast.proto.TypeQualifier ql = 2;


    pub fn get_ql(&self) -> TypeQualifier {
        match self.elem {
            ::std::option::Option::Some(TypeName_SpQl_oneof_elem::ql(v)) => v,
            _ => TypeQualifier::CONST,
        }
    }
    pub fn clear_ql(&mut self) {
        self.elem = ::std::option::Option::None;
    }

    pub fn has_ql(&self) -> bool {
        match self.elem {
            ::std::option::Option::Some(TypeName_SpQl_oneof_elem::ql(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ql(&mut self, v: TypeQualifier) {
        self.elem = ::std::option::Option::Some(TypeName_SpQl_oneof_elem::ql(v))
    }

    // .c4.ast.proto.Loc loc = 3;


    pub fn get_loc(&self) -> &Loc {
        self.loc.as_ref().unwrap_or_else(|| Loc::default_instance())
    }
    pub fn clear_loc(&mut self) {
        self.loc.clear();
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: Loc) {
        self.loc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut Loc {
        if self.loc.is_none() {
            self.loc.set_default();
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> Loc {
        self.loc.take().unwrap_or_else(|| Loc::new())
    }
}

impl ::protobuf::Message for TypeName_SpQl {
    fn is_initialized(&self) -> bool {
        if let Some(TypeName_SpQl_oneof_elem::sp(ref v)) = self.elem {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.loc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(TypeName_SpQl_oneof_elem::sp(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.elem = ::std::option::Option::Some(TypeName_SpQl_oneof_elem::ql(is.read_enum()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.elem {
            match v {
                &TypeName_SpQl_oneof_elem::sp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypeName_SpQl_oneof_elem::ql(v) => {
                    my_size += ::protobuf::rt::enum_size(2, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.elem {
            match v {
                &TypeName_SpQl_oneof_elem::sp(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypeName_SpQl_oneof_elem::ql(v) => {
                    os.write_enum(2, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeName_SpQl {
        TypeName_SpQl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeSpecifier>(
                    "sp",
                    TypeName_SpQl::has_sp,
                    TypeName_SpQl::get_sp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, TypeQualifier>(
                    "ql",
                    TypeName_SpQl::has_ql,
                    TypeName_SpQl::get_ql,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc>>(
                    "loc",
                    |m: &TypeName_SpQl| { &m.loc },
                    |m: &mut TypeName_SpQl| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeName_SpQl>(
                    "TypeName_SpQl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeName_SpQl {
        static mut instance: ::protobuf::lazy::Lazy<TypeName_SpQl> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeName_SpQl,
        };
        unsafe {
            instance.get(TypeName_SpQl::new)
        }
    }
}

impl ::protobuf::Clear for TypeName_SpQl {
    fn clear(&mut self) {
        self.elem = ::std::option::Option::None;
        self.elem = ::std::option::Option::None;
        self.loc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeName_SpQl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeName_SpQl {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Loc {
    // message fields
    pub levels: ::protobuf::RepeatedField<Loc_Range>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Loc {
    fn default() -> &'a Loc {
        <Loc as ::protobuf::Message>::default_instance()
    }
}

impl Loc {
    pub fn new() -> Loc {
        ::std::default::Default::default()
    }

    // repeated .c4.ast.proto.Loc.Range levels = 1;


    pub fn get_levels(&self) -> &[Loc_Range] {
        &self.levels
    }
    pub fn clear_levels(&mut self) {
        self.levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_levels(&mut self, v: ::protobuf::RepeatedField<Loc_Range>) {
        self.levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_levels(&mut self) -> &mut ::protobuf::RepeatedField<Loc_Range> {
        &mut self.levels
    }

    // Take field
    pub fn take_levels(&mut self) -> ::protobuf::RepeatedField<Loc_Range> {
        ::std::mem::replace(&mut self.levels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Loc {
    fn is_initialized(&self) -> bool {
        for v in &self.levels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.levels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.levels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.levels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Loc {
        Loc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Loc_Range>>(
                    "levels",
                    |m: &Loc| { &m.levels },
                    |m: &mut Loc| { &mut m.levels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Loc>(
                    "Loc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Loc {
        static mut instance: ::protobuf::lazy::Lazy<Loc> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Loc,
        };
        unsafe {
            instance.get(Loc::new)
        }
    }
}

impl ::protobuf::Clear for Loc {
    fn clear(&mut self) {
        self.levels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Loc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Loc {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Loc_Range {
    // message fields
    pub line_begin: i32,
    pub col_begin: i32,
    pub line_end: i32,
    pub col_end: i32,
    pub file_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Loc_Range {
    fn default() -> &'a Loc_Range {
        <Loc_Range as ::protobuf::Message>::default_instance()
    }
}

impl Loc_Range {
    pub fn new() -> Loc_Range {
        ::std::default::Default::default()
    }

    // int32 line_begin = 1;


    pub fn get_line_begin(&self) -> i32 {
        self.line_begin
    }
    pub fn clear_line_begin(&mut self) {
        self.line_begin = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_begin(&mut self, v: i32) {
        self.line_begin = v;
    }

    // int32 col_begin = 2;


    pub fn get_col_begin(&self) -> i32 {
        self.col_begin
    }
    pub fn clear_col_begin(&mut self) {
        self.col_begin = 0;
    }

    // Param is passed by value, moved
    pub fn set_col_begin(&mut self, v: i32) {
        self.col_begin = v;
    }

    // int32 line_end = 3;


    pub fn get_line_end(&self) -> i32 {
        self.line_end
    }
    pub fn clear_line_end(&mut self) {
        self.line_end = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_end(&mut self, v: i32) {
        self.line_end = v;
    }

    // int32 col_end = 4;


    pub fn get_col_end(&self) -> i32 {
        self.col_end
    }
    pub fn clear_col_end(&mut self) {
        self.col_end = 0;
    }

    // Param is passed by value, moved
    pub fn set_col_end(&mut self, v: i32) {
        self.col_end = v;
    }

    // string file_name = 5;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Loc_Range {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.line_begin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.col_begin = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.line_end = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.col_end = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.line_begin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.line_begin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.col_begin != 0 {
            my_size += ::protobuf::rt::value_size(2, self.col_begin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.line_end != 0 {
            my_size += ::protobuf::rt::value_size(3, self.line_end, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.col_end != 0 {
            my_size += ::protobuf::rt::value_size(4, self.col_end, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.file_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.line_begin != 0 {
            os.write_int32(1, self.line_begin)?;
        }
        if self.col_begin != 0 {
            os.write_int32(2, self.col_begin)?;
        }
        if self.line_end != 0 {
            os.write_int32(3, self.line_end)?;
        }
        if self.col_end != 0 {
            os.write_int32(4, self.col_end)?;
        }
        if !self.file_name.is_empty() {
            os.write_string(5, &self.file_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Loc_Range {
        Loc_Range::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "line_begin",
                    |m: &Loc_Range| { &m.line_begin },
                    |m: &mut Loc_Range| { &mut m.line_begin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "col_begin",
                    |m: &Loc_Range| { &m.col_begin },
                    |m: &mut Loc_Range| { &mut m.col_begin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "line_end",
                    |m: &Loc_Range| { &m.line_end },
                    |m: &mut Loc_Range| { &mut m.line_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "col_end",
                    |m: &Loc_Range| { &m.col_end },
                    |m: &mut Loc_Range| { &mut m.col_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_name",
                    |m: &Loc_Range| { &m.file_name },
                    |m: &mut Loc_Range| { &mut m.file_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Loc_Range>(
                    "Loc_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Loc_Range {
        static mut instance: ::protobuf::lazy::Lazy<Loc_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Loc_Range,
        };
        unsafe {
            instance.get(Loc_Range::new)
        }
    }
}

impl ::protobuf::Clear for Loc_Range {
    fn clear(&mut self) {
        self.line_begin = 0;
        self.col_begin = 0;
        self.line_end = 0;
        self.col_end = 0;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Loc_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Loc_Range {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TypeQualifier {
    CONST = 0,
    VOLATILE = 1,
}

impl ::protobuf::ProtobufEnum for TypeQualifier {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeQualifier> {
        match value {
            0 => ::std::option::Option::Some(TypeQualifier::CONST),
            1 => ::std::option::Option::Some(TypeQualifier::VOLATILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypeQualifier] = &[
            TypeQualifier::CONST,
            TypeQualifier::VOLATILE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TypeQualifier", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TypeQualifier {
}

impl ::std::default::Default for TypeQualifier {
    fn default() -> Self {
        TypeQualifier::CONST
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeQualifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StorageClassSpecifier {
    TYPEDEF = 0,
    EXTERN = 1,
    STATIC = 2,
    AUTO = 3,
    REGISTER = 4,
}

impl ::protobuf::ProtobufEnum for StorageClassSpecifier {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StorageClassSpecifier> {
        match value {
            0 => ::std::option::Option::Some(StorageClassSpecifier::TYPEDEF),
            1 => ::std::option::Option::Some(StorageClassSpecifier::EXTERN),
            2 => ::std::option::Option::Some(StorageClassSpecifier::STATIC),
            3 => ::std::option::Option::Some(StorageClassSpecifier::AUTO),
            4 => ::std::option::Option::Some(StorageClassSpecifier::REGISTER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StorageClassSpecifier] = &[
            StorageClassSpecifier::TYPEDEF,
            StorageClassSpecifier::EXTERN,
            StorageClassSpecifier::STATIC,
            StorageClassSpecifier::AUTO,
            StorageClassSpecifier::REGISTER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StorageClassSpecifier", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StorageClassSpecifier {
}

impl ::std::default::Default for StorageClassSpecifier {
    fn default() -> Self {
        StorageClassSpecifier::TYPEDEF
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageClassSpecifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tast.proto\x12\x0cc4.ast.proto\"\xf7\x03\n\x0fTranslationUnit\x12,\n\
    \x03eds\x18\x01\x20\x03(\x0b2\x1a.c4.ast.proto.ExternalDeclR\x03eds\x12*\
    \n\x07ed_locs\x18\x02\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x06edLocs\x12(\
    \n\x05exprs\x18\x03\x20\x03(\x0b2\x12.c4.ast.proto.ExprR\x05exprs\x12M\n\
    \x12direct_declarators\x18\x04\x20\x03(\x0b2\x1e.c4.ast.proto.DirectDecl\
    aratorR\x11directDeclarators\x12f\n\x1bdirect_abstract_declarators\x18\
    \x05\x20\x03(\x0b2&.c4.ast.proto.DirectAbstractDeclaratorR\x19directAbst\
    ractDeclarators\x121\n\x08pointers\x18\x06\x20\x03(\x0b2\x15.c4.ast.prot\
    o.PointerR\x08pointers\x12=\n\x0cinitializers\x18\x07\x20\x03(\x0b2\x19.\
    c4.ast.proto.InitializerR\x0cinitializers\x127\n\nstatements\x18\x08\x20\
    \x03(\x0b2\x17.c4.ast.proto.StatementR\nstatements\"\x93\x01\n\x0cExtern\
    alDecl\x12+\n\x02fd\x18\x01\x20\x01(\x0b2\x19.c4.ast.proto.FunctionDefH\
    \0R\x02fd\x12+\n\x02dl\x18\x02\x20\x01(\x0b2\x19.c4.ast.proto.Declaratio\
    nH\0R\x02dl\x12#\n\x03loc\x18\x03\x20\x01(\x0b2\x11.c4.ast.proto.LocR\
    \x03locB\x04\n\x02ed\"\xa8\x17\n\x04Expr\x12\x10\n\x02id\x18\x01\x20\x01\
    (\tH\0R\x02id\x126\n\x07integer\x18\x02\x20\x01(\x0b2\x1a.c4.ast.proto.E\
    xpr.IntegerH\0R\x07integer\x12\x16\n\x05float\x18\x03\x20\x01(\x02H\0R\
    \x05float\x12\x18\n\x06double\x18\x04\x20\x01(\x01H\0R\x06double\x12\x14\
    \n\x04char\x18\x06\x20\x01(\rH\0R\x04char\x12\x1d\n\twide_char\x18\x07\
    \x20\x01(\rH\0R\x08wideChar\x12\x18\n\x06string\x18\x08\x20\x01(\tH\0R\
    \x06string\x12!\n\x0bwide_string\x18\t\x20\x01(\tH\0R\nwideString\x12-\n\
    \x04cast\x18\n\x20\x01(\x0b2\x17.c4.ast.proto.Expr.CastH\0R\x04cast\x124\
    \n\x07arr_sub\x18\x0b\x20\x01(\x0b2\x19.c4.ast.proto.Expr.ArrSubH\0R\x06\
    arrSub\x12:\n\tfunc_call\x18\x0c\x20\x01(\x0b2\x1b.c4.ast.proto.Expr.Fun\
    cCallH\0R\x08funcCall\x12*\n\x03dot\x18\r\x20\x01(\x0b2\x16.c4.ast.proto\
    .Expr.DotH\0R\x03dot\x12*\n\x03ptr\x18\x0e\x20\x01(\x0b2\x16.c4.ast.prot\
    o.Expr.PtrH\0R\x03ptr\x12=\n\nsizeof_val\x18\x0f\x20\x01(\x0b2\x1c.c4.as\
    t.proto.Expr.SizeofValH\0R\tsizeofVal\x12<\n\tsizeof_tp\x18\x10\x20\x01(\
    \x0b2\x1d.c4.ast.proto.Expr.SizeofTypeH\0R\x08sizeofTp\x120\n\x05unary\
    \x18\x11\x20\x01(\x0b2\x18.c4.ast.proto.Expr.UnaryH\0R\x05unary\x123\n\
    \x06binary\x18\x12\x20\x01(\x0b2\x19.c4.ast.proto.Expr.BinaryH\0R\x06bin\
    ary\x126\n\x07ternary\x18\x13\x20\x01(\x0b2\x1a.c4.ast.proto.Expr.Ternar\
    yH\0R\x07ternary\x1a\x97\x01\n\x07Integer\x12\x0c\n\x01n\x18\x01\x20\x01\
    (\x03R\x01n\x123\n\x04size\x18\x02\x20\x01(\x0e2\x1f.c4.ast.proto.Expr.I\
    nteger.SizeR\x04size\x12\x16\n\x06signed\x18\x03\x20\x01(\x08R\x06signed\
    \"1\n\x04Size\x12\x08\n\x04INT8\x10\0\x12\t\n\x05INT16\x10\x01\x12\t\n\
    \x05INT32\x10\x02\x12\t\n\x05INT64\x10\x03\x1a\x95\x01\n\x04Cast\x12&\n\
    \x02tp\x18\x01\x20\x01(\x0b2\x16.c4.ast.proto.TypeNameR\x02tp\x12(\n\x06\
    tp_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05tpLoc\x12\x13\n\
    \x05e_idx\x18\x03\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\x04\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x04eLoc\x1a\x92\x01\n\x06ArrSub\x12\x17\n\
    \x07arr_idx\x18\x01\x20\x01(\x05R\x06arrIdx\x12*\n\x07arr_loc\x18\x02\
    \x20\x01(\x0b2\x11.c4.ast.proto.LocR\x06arrLoc\x12\x17\n\x07sub_idx\x18\
    \x03\x20\x01(\x05R\x06subIdx\x12*\n\x07sub_loc\x18\x04\x20\x01(\x0b2\x11\
    .c4.ast.proto.LocR\x06subLoc\x1a\x8d\x01\n\x08FuncCall\x12\x15\n\x06fn_i\
    dx\x18\x01\x20\x01(\x05R\x05fnIdx\x12(\n\x06fn_loc\x18\x02\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x05fnLoc\x12\x12\n\x04args\x18\x03\x20\x03(\x05R\
    \x04args\x12,\n\x08arg_locs\x18\x04\x20\x03(\x0b2\x11.c4.ast.proto.LocR\
    \x07argLocs\x1a\x88\x01\n\x03Dot\x12\x13\n\x05e_idx\x18\x01\x20\x01(\x05\
    R\x04eIdx\x12&\n\x05e_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\
    \x04eLoc\x12\x14\n\x05field\x18\x03\x20\x01(\tR\x05field\x12.\n\tfield_l\
    oc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x08fieldLoc\x1a\x88\x01\n\
    \x03Ptr\x12\x13\n\x05e_idx\x18\x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\
    \x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04eLoc\x12\x14\n\x05field\
    \x18\x03\x20\x01(\tR\x05field\x12.\n\tfield_loc\x18\x04\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x08fieldLoc\x1aH\n\tSizeofVal\x12\x13\n\x05e_idx\
    \x18\x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\x02\x20\x01(\x0b2\x11\
    .c4.ast.proto.LocR\x04eLoc\x1a^\n\nSizeofType\x12&\n\x02tp\x18\x01\x20\
    \x01(\x0b2\x16.c4.ast.proto.TypeNameR\x02tp\x12(\n\x06tp_loc\x18\x02\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x05tpLoc\x1a\xa6\x02\n\x05Unary\x12\x13\
    \n\x05e_idx\x18\x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\x02\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x04eLoc\x12+\n\x02op\x18\x03\x20\x01(\
    \x0e2\x1b.c4.ast.proto.Expr.Unary.OpR\x02op\x12(\n\x06op_loc\x18\x04\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x05opLoc\"\x88\x01\n\x02Op\x12\x0e\n\nP\
    REFIX_INC\x10\0\x12\x0e\n\nPREFIX_DEC\x10\x01\x12\x0f\n\x0bPOSTFIX_INC\
    \x10\x02\x12\x0f\n\x0bPOSTFIX_DEC\x10\x03\x12\x07\n\x03REF\x10\x04\x12\t\
    \n\x05DEREF\x10\x05\x12\x07\n\x03POS\x10\x06\x12\x07\n\x03NEG\x10\x07\
    \x12\x0b\n\x07BIT_NOT\x10\x08\x12\r\n\tLOGIC_NOT\x10\t\x1a\xf0\x04\n\x06\
    Binary\x12\x15\n\x06e1_idx\x18\x01\x20\x01(\x05R\x05e1Idx\x12(\n\x06e1_l\
    oc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05e1Loc\x12\x15\n\x06e2_\
    idx\x18\x03\x20\x01(\x05R\x05e2Idx\x12(\n\x06e2_loc\x18\x04\x20\x01(\x0b\
    2\x11.c4.ast.proto.LocR\x05e2Loc\x12,\n\x02op\x18\x05\x20\x01(\x0e2\x1c.\
    c4.ast.proto.Expr.Binary.OpR\x02op\x12(\n\x06op_loc\x18\x06\x20\x01(\x0b\
    2\x11.c4.ast.proto.LocR\x05opLoc\"\x8b\x03\n\x02Op\x12\n\n\x06ASSIGN\x10\
    \0\x12\x0e\n\nMUL_ASSIGN\x10\x01\x12\x0e\n\nDIV_ASSIGN\x10\x02\x12\x0e\n\
    \nMOD_ASSIGN\x10\x03\x12\x0e\n\nADD_ASSIGN\x10\x04\x12\x0e\n\nSUB_ASSIGN\
    \x10\x05\x12\x12\n\x0eL_SHIFT_ASSIGN\x10\x06\x12\x12\n\x0eR_SHIFT_ASSIGN\
    \x10\x07\x12\x15\n\x11BINARY_AND_ASSIGN\x10\x08\x12\x0e\n\nXOR_ASSIGN\
    \x10\t\x12\x14\n\x10BINARY_OR_ASSIGN\x10\n\x12\t\n\x05COMMA\x10\x0b\x12\
    \x0c\n\x08LOGIC_OR\x10\x0c\x12\r\n\tLOGIC_AND\x10\r\x12\n\n\x06BIT_OR\
    \x10\x0e\x12\x07\n\x03XOR\x10\x0f\x12\x0b\n\x07BIT_AND\x10\x10\x12\x06\n\
    \x02EQ\x10\x11\x12\x07\n\x03NEQ\x10\x12\x12\x08\n\x04LESS\x10\x13\x12\
    \x06\n\x02GT\x10\x14\x12\x07\n\x03LEQ\x10\x15\x12\x07\n\x03GEQ\x10\x16\
    \x12\x0b\n\x07L_SHIFT\x10\x17\x12\x0b\n\x07R_SHIFT\x10\x18\x12\x07\n\x03\
    ADD\x10\x19\x12\x07\n\x03SUB\x10\x1a\x12\x07\n\x03MUL\x10\x1b\x12\x07\n\
    \x03DIV\x10\x1c\x12\x07\n\x03MOD\x10\x1d\x1a\xe4\x01\n\x07Ternary\x12\
    \x19\n\x08cond_idx\x18\x01\x20\x01(\x05R\x07condIdx\x12,\n\x08cond_loc\
    \x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07condLoc\x12\x19\n\x08the\
    n_idx\x18\x03\x20\x01(\x05R\x07thenIdx\x12,\n\x08then_loc\x18\x04\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x07thenLoc\x12\x19\n\x08else_idx\x18\
    \x05\x20\x01(\x05R\x07elseIdx\x12,\n\x08else_loc\x18\x06\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x07elseLocB\x03\n\x01e\"\xd4\x0b\n\rTypeSpecifier\
    \x126\n\x04void\x18\x01\x20\x01(\x0b2\x20.c4.ast.proto.TypeSpecifier.Voi\
    dH\0R\x04void\x126\n\x04char\x18\x02\x20\x01(\x0b2\x20.c4.ast.proto.Type\
    Specifier.CharH\0R\x04char\x129\n\x05short\x18\x03\x20\x01(\x0b2!.c4.ast\
    .proto.TypeSpecifier.ShortH\0R\x05short\x123\n\x03int\x18\x04\x20\x01(\
    \x0b2\x1f.c4.ast.proto.TypeSpecifier.IntH\0R\x03int\x126\n\x04long\x18\
    \x05\x20\x01(\x0b2\x20.c4.ast.proto.TypeSpecifier.LongH\0R\x04long\x129\
    \n\x05float\x18\x06\x20\x01(\x0b2!.c4.ast.proto.TypeSpecifier.FloatH\0R\
    \x05float\x12<\n\x06double\x18\x07\x20\x01(\x0b2\".c4.ast.proto.TypeSpec\
    ifier.DoubleH\0R\x06double\x12<\n\x06signed\x18\x08\x20\x01(\x0b2\".c4.a\
    st.proto.TypeSpecifier.SignedH\0R\x06signed\x12B\n\x08unsigned\x18\t\x20\
    \x01(\x0b2$.c4.ast.proto.TypeSpecifier.UnsignedH\0R\x08unsigned\x12<\n\
    \x06struct\x18\n\x20\x01(\x0b2\".c4.ast.proto.TypeSpecifier.StructH\0R\
    \x06struct\x129\n\x05union\x18\x0b\x20\x01(\x0b2!.c4.ast.proto.TypeSpeci\
    fier.UnionH\0R\x05union\x126\n\x04enum\x18\x0c\x20\x01(\x0b2\x20.c4.ast.\
    proto.TypeSpecifier.EnumH\0R\x04enum\x12#\n\x0ctypedef_name\x18\r\x20\
    \x01(\tH\0R\x0btypedefName\x1a\x06\n\x04Void\x1a\x06\n\x04Char\x1a\x07\n\
    \x05Short\x1a\x05\n\x03Int\x1a\x06\n\x04Long\x1a\x07\n\x05Float\x1a\x08\
    \n\x06Double\x1a\x08\n\x06Signed\x1a\n\n\x08Unsigned\x1a\xb3\x01\n\x06St\
    ruct\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12,\n\x08name_loc\
    \x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07nameLoc\x127\n\x06bodies\
    \x18\x03\x20\x03(\x0b2\x1f.c4.ast.proto.StructDeclarationR\x06bodies\x12\
    .\n\tbody_locs\x18\x04\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x08bodyLocs\
    \x1a\xb2\x01\n\x05Union\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12,\n\x08name_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07nameL\
    oc\x127\n\x06bodies\x18\x03\x20\x03(\x0b2\x1f.c4.ast.proto.StructDeclara\
    tionR\x06bodies\x12.\n\tbody_locs\x18\x04\x20\x03(\x0b2\x11.c4.ast.proto\
    .LocR\x08bodyLocs\x1a\x98\x02\n\x04Enum\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12,\n\x08name_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.pro\
    to.LocR\x07nameLoc\x12=\n\x06bodies\x18\x03\x20\x03(\x0b2%.c4.ast.proto.\
    TypeSpecifier.Enum.BodyR\x06bodies\x1a\x8e\x01\n\x04Body\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12,\n\x08name_loc\x18\x02\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x07nameLoc\x12\x14\n\x05value\x18\x03\x20\x01(\
    \x05R\x05value\x12.\n\tvalue_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto.\
    LocR\x08valueLocB\x03\n\x01s\"\xa9\x03\n\x11StructDeclaration\x12;\n\x06\
    sp_qls\x18\x01\x20\x03(\x0b2$.c4.ast.proto.StructDeclaration.SpQlR\x05sp\
    Qls\x124\n\x02ds\x18\x02\x20\x03(\x0b2$.c4.ast.proto.StructDeclaration.D\
    eclR\x02ds\x1a\x91\x01\n\x04SpQl\x12-\n\x02sp\x18\x01\x20\x01(\x0b2\x1b.\
    c4.ast.proto.TypeSpecifierH\0R\x02sp\x12-\n\x02ql\x18\x02\x20\x01(\x0e2\
    \x1b.c4.ast.proto.TypeQualifierH\0R\x02ql\x12#\n\x03loc\x18\x03\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x03locB\x06\n\x04elem\x1a\x8c\x01\n\x04Decl\
    \x12&\n\x01d\x18\x01\x20\x01(\x0b2\x18.c4.ast.proto.DeclaratorR\x01d\x12\
    &\n\x05d_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04dLoc\x12\x0c\
    \n\x01e\x18\x03\x20\x01(\x05R\x01e\x12&\n\x05e_loc\x18\x04\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x04eLoc\"\x92\x01\n\nDeclarator\x12\x17\n\x07ptr_\
    idx\x18\x01\x20\x01(\x05R\x06ptrIdx\x12*\n\x07ptr_loc\x18\x02\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x06ptrLoc\x12\x15\n\x06dd_idx\x18\x03\x20\
    \x01(\x05R\x05ddIdx\x12(\n\x06dd_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.pr\
    oto.LocR\x05ddLoc\"\x80\x08\n\x10DirectDeclarator\x123\n\x02id\x18\x01\
    \x20\x01(\x0b2!.c4.ast.proto.DirectDeclarator.IdH\0R\x02id\x129\n\x01d\
    \x18\x02\x20\x01(\x0b2).c4.ast.proto.DirectDeclarator.DeclaratorH\0R\x01\
    d\x12<\n\x05array\x18\x03\x20\x01(\x0b2$.c4.ast.proto.DirectDeclarator.A\
    rrayH\0R\x05array\x129\n\x02ft\x18\x04\x20\x01(\x0b2'.c4.ast.proto.Direc\
    tDeclarator.FuncTypeH\0R\x02ft\x12C\n\x08ids_list\x18\x05\x20\x01(\x0b2&\
    .c4.ast.proto.DirectDeclarator.IdsListH\0R\x07idsList\x1a9\n\x02Id\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12#\n\x03loc\x18\x02\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x03loc\x1aY\n\nDeclarator\x12&\n\x01d\x18\
    \x01\x20\x01(\x0b2\x18.c4.ast.proto.DeclaratorR\x01d\x12#\n\x03loc\x18\
    \x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x03loc\x1a\x91\x01\n\x05Array\
    \x12\x15\n\x06dd_idx\x18\x01\x20\x01(\x05R\x05ddIdx\x12(\n\x06dd_loc\x18\
    \x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05ddLoc\x12\x19\n\x08size_idx\
    \x18\x03\x20\x01(\x05R\x07sizeIdx\x12,\n\x08size_loc\x18\x04\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x07sizeLoc\x1a\x82\x02\n\x08FuncType\x12\x15\
    \n\x06dd_idx\x18\x01\x20\x01(\x05R\x05ddIdx\x12(\n\x06dd_loc\x18\x02\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x05ddLoc\x120\n\x03pds\x18\x03\x20\x03(\
    \x0b2\x1e.c4.ast.proto.ParamDeclarationR\x03pds\x12*\n\x07pd_locs\x18\
    \x04\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x06pdLocs\x12!\n\x0chas_ellipsi\
    s\x18\x05\x20\x01(\x08R\x0bhasEllipsis\x124\n\x0cellipsis_loc\x18\x06\
    \x20\x01(\x0b2\x11.c4.ast.proto.LocR\x0bellipsisLoc\x1a\x88\x01\n\x07Ids\
    List\x12\x15\n\x06dd_idx\x18\x01\x20\x01(\x05R\x05ddIdx\x12(\n\x06dd_loc\
    \x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05ddLoc\x12\x10\n\x03ids\
    \x18\x03\x20\x03(\tR\x03ids\x12*\n\x07id_locs\x18\x04\x20\x03(\x0b2\x11.\
    c4.ast.proto.LocR\x06idLocsB\x04\n\x02dd\"\x9e\x01\n\x12AbstractDeclarat\
    or\x12\x17\n\x07ptr_idx\x18\x01\x20\x01(\x05R\x06ptrIdx\x12*\n\x07ptr_lo\
    c\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x06ptrLoc\x12\x17\n\x07dad\
    _idx\x18\x03\x20\x01(\x05R\x06dadIdx\x12*\n\x07dad_loc\x18\x04\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x06dadLoc\"\xf6\x05\n\x18DirectAbstractDecla\
    rator\x12G\n\x06simple\x18\x01\x20\x01(\x0b2-.c4.ast.proto.DirectAbstrac\
    tDeclarator.SimpleH\0R\x06simple\x12D\n\x05array\x18\x02\x20\x01(\x0b2,.\
    c4.ast.proto.DirectAbstractDeclarator.ArrayH\0R\x05array\x12A\n\x04func\
    \x18\x03\x20\x01(\x0b2+.c4.ast.proto.DirectAbstractDeclarator.FuncH\0R\
    \x04func\x1ad\n\x06Simple\x120\n\x02ad\x18\x01\x20\x01(\x0b2\x20.c4.ast.\
    proto.AbstractDeclaratorR\x02ad\x12(\n\x06ad_loc\x18\x02\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x05adLoc\x1a\x95\x01\n\x05Array\x12\x17\n\x07dad_\
    idx\x18\x01\x20\x01(\x05R\x06dadIdx\x12*\n\x07dad_loc\x18\x02\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x06dadLoc\x12\x19\n\x08size_idx\x18\x03\x20\
    \x01(\x05R\x07sizeIdx\x12,\n\x08size_loc\x18\x04\x20\x01(\x0b2\x11.c4.as\
    t.proto.LocR\x07sizeLoc\x1a\x82\x02\n\x04Func\x12\x17\n\x07dad_idx\x18\
    \x01\x20\x01(\x05R\x06dadIdx\x12*\n\x07dad_loc\x18\x02\x20\x01(\x0b2\x11\
    .c4.ast.proto.LocR\x06dadLoc\x120\n\x03pds\x18\x03\x20\x03(\x0b2\x1e.c4.\
    ast.proto.ParamDeclarationR\x03pds\x12*\n\x07pd_locs\x18\x04\x20\x03(\
    \x0b2\x11.c4.ast.proto.LocR\x06pdLocs\x12!\n\x0chas_ellipsis\x18\x05\x20\
    \x01(\x08R\x0bhasEllipsis\x124\n\x0cellipsis_loc\x18\x06\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x0bellipsisLocB\x05\n\x03dad\"\xf2\x05\n\x10Param\
    Declaration\x12:\n\x04name\x18\x01\x20\x01(\x0b2$.c4.ast.proto.ParamDecl\
    aration.NamedH\0R\x04name\x12F\n\ttype_only\x18\x02\x20\x01(\x0b2'.c4.as\
    t.proto.ParamDeclaration.TypeOnlyH\0R\x08typeOnly\x12Y\n\x10type_only_si\
    mple\x18\x03\x20\x01(\x0b2-.c4.ast.proto.ParamDeclaration.TypeOnlySimple\
    H\0R\x0etypeOnlySimple\x1a\xb9\x01\n\x05Named\x124\n\x03dss\x18\x01\x20\
    \x03(\x0b2\".c4.ast.proto.DeclarationSpecifierR\x03dss\x12*\n\x07ds_locs\
    \x18\x02\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x06dsLocs\x12&\n\x01d\x18\
    \x03\x20\x01(\x0b2\x18.c4.ast.proto.DeclaratorR\x01d\x12&\n\x05d_loc\x18\
    \x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04dLoc\x1a\xc8\x01\n\x08TypeOn\
    ly\x124\n\x03dss\x18\x01\x20\x03(\x0b2\".c4.ast.proto.DeclarationSpecifi\
    erR\x03dss\x12*\n\x07ds_locs\x18\x02\x20\x03(\x0b2\x11.c4.ast.proto.LocR\
    \x06dsLocs\x120\n\x02ad\x18\x03\x20\x01(\x0b2\x20.c4.ast.proto.AbstractD\
    eclaratorR\x02ad\x12(\n\x06ad_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto\
    .LocR\x05adLoc\x1ar\n\x0eTypeOnlySimple\x124\n\x03dss\x18\x01\x20\x03(\
    \x0b2\".c4.ast.proto.DeclarationSpecifierR\x03dss\x12*\n\x07ds_locs\x18\
    \x02\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x06dsLocsB\x04\n\x02pd\"\xda\
    \x01\n\x14DeclarationSpecifier\x127\n\x03scs\x18\x01\x20\x01(\x0e2#.c4.a\
    st.proto.StorageClassSpecifierH\0R\x03scs\x12-\n\x02ts\x18\x02\x20\x01(\
    \x0b2\x1b.c4.ast.proto.TypeSpecifierH\0R\x02ts\x12-\n\x02tq\x18\x03\x20\
    \x01(\x0e2\x1b.c4.ast.proto.TypeQualifierH\0R\x02tq\x12#\n\x03loc\x18\
    \x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x03locB\x06\n\x04elem\"\xa5\x01\
    \n\x07Pointer\x12+\n\x02qs\x18\x01\x20\x03(\x0e2\x1b.c4.ast.proto.TypeQu\
    alifierR\x02qs\x12(\n\x06q_locs\x18\x02\x20\x03(\x0b2\x11.c4.ast.proto.L\
    ocR\x05qLocs\x12\x17\n\x07ptr_idx\x18\x03\x20\x01(\x05R\x06ptrIdx\x12*\n\
    \x07ptr_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x06ptrLoc\"\x95\
    \x02\n\x0bInitializer\x124\n\x04expr\x18\x01\x20\x01(\x0b2\x1e.c4.ast.pr\
    oto.Initializer.ExprH\0R\x04expr\x12:\n\x06struct\x18\x02\x20\x01(\x0b2\
    \x20.c4.ast.proto.Initializer.StructH\0R\x06struct\x1a<\n\x04Expr\x12\
    \x0c\n\x01e\x18\x01\x20\x01(\x05R\x01e\x12&\n\x05e_loc\x18\x02\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x04eLoc\x1aN\n\x06Struct\x12\x14\n\x05inits\
    \x18\x01\x20\x03(\x05R\x05inits\x12.\n\tinit_locs\x18\x02\x20\x03(\x0b2\
    \x11.c4.ast.proto.LocR\x08initLocsB\x06\n\x04init\"\xbf\x02\n\x0bDeclara\
    tion\x124\n\x03dss\x18\x01\x20\x03(\x0b2\".c4.ast.proto.DeclarationSpeci\
    fierR\x03dss\x12*\n\x07ds_locs\x18\x02\x20\x03(\x0b2\x11.c4.ast.proto.Lo\
    cR\x06dsLocs\x12.\n\x03ids\x18\x03\x20\x03(\x0b2\x1c.c4.ast.proto.Declar\
    ation.IdR\x03ids\x1a\x9d\x01\n\x02Id\x12&\n\x01d\x18\x01\x20\x01(\x0b2\
    \x18.c4.ast.proto.DeclaratorR\x01d\x12&\n\x05d_loc\x18\x02\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x04dLoc\x12\x19\n\x08init_idx\x18\x03\x20\x01(\
    \x05R\x07initIdx\x12,\n\x08init_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.pro\
    to.LocR\x07initLoc\"\xfc\x02\n\x0bFunctionDef\x124\n\x03dss\x18\x01\x20\
    \x03(\x0b2\".c4.ast.proto.DeclarationSpecifierR\x03dss\x12*\n\x07ds_locs\
    \x18\x02\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x06dsLocs\x12&\n\x01d\x18\
    \x03\x20\x01(\x0b2\x18.c4.ast.proto.DeclaratorR\x01d\x12&\n\x05d_loc\x18\
    \x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04dLoc\x12+\n\x03dls\x18\x05\
    \x20\x03(\x0b2\x19.c4.ast.proto.DeclarationR\x03dls\x12*\n\x07dl_locs\
    \x18\x06\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x06dlLocs\x124\n\x04body\
    \x18\x07\x20\x01(\x0b2\x20.c4.ast.proto.Statement.CompoundR\x04body\x12,\
    \n\x08body_loc\x18\x08\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07bodyLoc\"\
    \xce\x14\n\tStatement\x12>\n\x08compound\x18\x01\x20\x01(\x0b2\x20.c4.as\
    t.proto.Statement.CompoundH\0R\x08compound\x12;\n\x07labeled\x18\x02\x20\
    \x01(\x0b2\x1f.c4.ast.proto.Statement.LabeledH\0R\x07labeled\x122\n\x04e\
    xpr\x18\x03\x20\x01(\x0b2\x1c.c4.ast.proto.Statement.ExprH\0R\x04expr\
    \x12/\n\x04if_s\x18\x04\x20\x01(\x0b2\x1a.c4.ast.proto.Statement.IfH\0R\
    \x03ifS\x12;\n\x08switch_s\x18\x05\x20\x01(\x0b2\x1e.c4.ast.proto.Statem\
    ent.SwitchH\0R\x07switchS\x128\n\x07while_s\x18\x06\x20\x01(\x0b2\x1d.c4\
    .ast.proto.Statement.WhileH\0R\x06whileS\x12?\n\ndo_while_s\x18\x07\x20\
    \x01(\x0b2\x1f.c4.ast.proto.Statement.DoWhileH\0R\x08doWhileS\x122\n\x05\
    for_s\x18\x08\x20\x01(\x0b2\x1b.c4.ast.proto.Statement.ForH\0R\x04forS\
    \x125\n\x06goto_s\x18\t\x20\x01(\x0b2\x1c.c4.ast.proto.Statement.GotoH\0\
    R\x05gotoS\x12A\n\ncontinue_s\x18\n\x20\x01(\x0b2\x20.c4.ast.proto.State\
    ment.ContinueH\0R\tcontinueS\x128\n\x07break_s\x18\x0b\x20\x01(\x0b2\x1d\
    .c4.ast.proto.Statement.BreakH\0R\x06breakS\x12;\n\x08return_s\x18\x0c\
    \x20\x01(\x0b2\x1e.c4.ast.proto.Statement.ReturnH\0R\x07returnS\x1a\xb2\
    \x01\n\x08Compound\x12+\n\x03dls\x18\x01\x20\x03(\x0b2\x19.c4.ast.proto.\
    DeclarationR\x03dls\x12*\n\x07dl_locs\x18\x02\x20\x03(\x0b2\x11.c4.ast.p\
    roto.LocR\x06dlLocs\x12\x1d\n\nstmt_idxes\x18\x03\x20\x03(\x05R\tstmtIdx\
    es\x12.\n\tstmt_locs\x18\x04\x20\x03(\x0b2\x11.c4.ast.proto.LocR\x08stmt\
    Locs\x1a\xb8\x04\n\x07Labeled\x124\n\x02id\x18\x01\x20\x01(\x0b2\".c4.as\
    t.proto.Statement.Labeled.IdH\0R\x02id\x12=\n\x06case_s\x18\x02\x20\x01(\
    \x0b2$.c4.ast.proto.Statement.Labeled.CaseH\0R\x05caseS\x12F\n\tdefault_\
    s\x18\x03\x20\x01(\x0b2'.c4.ast.proto.Statement.Labeled.DefaultH\0R\x08d\
    efaultS\x1a\x87\x01\n\x02Id\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12(\n\x06id_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05idLoc\
    \x12\x19\n\x08stmt_idx\x18\x03\x20\x01(\x05R\x07stmtIdx\x12,\n\x08stmt_l\
    oc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07stmtLoc\x1a\x8c\x01\n\
    \x04Case\x12\x13\n\x05e_idx\x18\x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_lo\
    c\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04eLoc\x12\x19\n\x08stmt_\
    idx\x18\x03\x20\x01(\x05R\x07stmtIdx\x12,\n\x08stmt_loc\x18\x04\x20\x01(\
    \x0b2\x11.c4.ast.proto.LocR\x07stmtLoc\x1aR\n\x07Default\x12\x19\n\x08st\
    mt_idx\x18\x01\x20\x01(\x05R\x07stmtIdx\x12,\n\x08stmt_loc\x18\x02\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x07stmtLocB\x03\n\x01l\x1aC\n\x04Expr\
    \x12\x13\n\x05e_idx\x18\x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\
    \x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04eLoc\x1a\xdf\x01\n\x02If\x12\
    \x19\n\x08cond_idx\x18\x01\x20\x01(\x05R\x07condIdx\x12,\n\x08cond_loc\
    \x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07condLoc\x12\x19\n\x08the\
    n_idx\x18\x03\x20\x01(\x05R\x07thenIdx\x12,\n\x08then_loc\x18\x04\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x07thenLoc\x12\x19\n\x08else_idx\x18\
    \x05\x20\x01(\x05R\x07elseIdx\x12,\n\x08else_loc\x18\x06\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x07elseLoc\x1a\x8e\x01\n\x06Switch\x12\x13\n\x05e\
    _idx\x18\x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\x02\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x04eLoc\x12\x19\n\x08body_idx\x18\x03\x20\x01(\
    \x05R\x07bodyIdx\x12,\n\x08body_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.pro\
    to.LocR\x07bodyLoc\x1a\x8d\x01\n\x05While\x12\x13\n\x05e_idx\x18\x01\x20\
    \x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.prot\
    o.LocR\x04eLoc\x12\x19\n\x08body_idx\x18\x03\x20\x01(\x05R\x07bodyIdx\
    \x12,\n\x08body_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07bodyL\
    oc\x1a\x8f\x01\n\x07DoWhile\x12\x19\n\x08body_idx\x18\x01\x20\x01(\x05R\
    \x07bodyIdx\x12,\n\x08body_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.Lo\
    cR\x07bodyLoc\x12\x13\n\x05e_idx\x18\x03\x20\x01(\x05R\x04eIdx\x12&\n\
    \x05e_loc\x18\x04\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x04eLoc\x1a\x91\
    \x02\n\x03For\x12\x15\n\x06e1_idx\x18\x01\x20\x01(\x05R\x05e1Idx\x12(\n\
    \x06e1_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05e1Loc\x12\x15\
    \n\x06e2_idx\x18\x03\x20\x01(\x05R\x05e2Idx\x12(\n\x06e2_loc\x18\x04\x20\
    \x01(\x0b2\x11.c4.ast.proto.LocR\x05e2Loc\x12\x15\n\x06e3_idx\x18\x05\
    \x20\x01(\x05R\x05e3Idx\x12(\n\x06e3_loc\x18\x06\x20\x01(\x0b2\x11.c4.as\
    t.proto.LocR\x05e3Loc\x12\x19\n\x08body_idx\x18\x07\x20\x01(\x05R\x07bod\
    yIdx\x12,\n\x08body_loc\x18\x08\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x07b\
    odyLoc\x1a@\n\x04Goto\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12(\n\
    \x06id_loc\x18\x02\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05idLoc\x1a\n\n\
    \x08Continue\x1a\x07\n\x05Break\x1aE\n\x06Return\x12\x13\n\x05e_idx\x18\
    \x01\x20\x01(\x05R\x04eIdx\x12&\n\x05e_loc\x18\x02\x20\x01(\x0b2\x11.c4.\
    ast.proto.LocR\x04eLocB\x06\n\x04stmt\"\xae\x02\n\x08TypeName\x122\n\x06\
    sp_qls\x18\x01\x20\x03(\x0b2\x1b.c4.ast.proto.TypeName.SpQlR\x05spQls\
    \x120\n\x02ad\x18\x02\x20\x01(\x0b2\x20.c4.ast.proto.AbstractDeclaratorR\
    \x02ad\x12(\n\x06ad_loc\x18\x03\x20\x01(\x0b2\x11.c4.ast.proto.LocR\x05a\
    dLoc\x1a\x91\x01\n\x04SpQl\x12-\n\x02sp\x18\x01\x20\x01(\x0b2\x1b.c4.ast\
    .proto.TypeSpecifierH\0R\x02sp\x12-\n\x02ql\x18\x02\x20\x01(\x0e2\x1b.c4\
    .ast.proto.TypeQualifierH\0R\x02ql\x12#\n\x03loc\x18\x03\x20\x01(\x0b2\
    \x11.c4.ast.proto.LocR\x03locB\x06\n\x04elem\"\xcd\x01\n\x03Loc\x12/\n\
    \x06levels\x18\x01\x20\x03(\x0b2\x17.c4.ast.proto.Loc.RangeR\x06levels\
    \x1a\x94\x01\n\x05Range\x12\x1d\n\nline_begin\x18\x01\x20\x01(\x05R\tlin\
    eBegin\x12\x1b\n\tcol_begin\x18\x02\x20\x01(\x05R\x08colBegin\x12\x19\n\
    \x08line_end\x18\x03\x20\x01(\x05R\x07lineEnd\x12\x17\n\x07col_end\x18\
    \x04\x20\x01(\x05R\x06colEnd\x12\x1b\n\tfile_name\x18\x05\x20\x01(\tR\
    \x08fileName*(\n\rTypeQualifier\x12\t\n\x05CONST\x10\0\x12\x0c\n\x08VOLA\
    TILE\x10\x01*T\n\x15StorageClassSpecifier\x12\x0b\n\x07TYPEDEF\x10\0\x12\
    \n\n\x06EXTERN\x10\x01\x12\n\n\x06STATIC\x10\x02\x12\x08\n\x04AUTO\x10\
    \x03\x12\x0c\n\x08REGISTER\x10\x04J\xe0\xc4\x01\n\x07\x12\x05\0\0\xaf\
    \x04\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\
    \x15\n9\n\x02\x04\0\x12\x04\x05\0\x12\x01\x1a-\x20type\x20TranslationUni\
    t\x20=\x20Seq[L[ExternalDecl]]\n\n\n\n\x03\x04\0\x01\x12\x03\x05\x08\x17\
    \n\x0b\n\x04\x04\0\x02\0\x12\x03\x06\x02\x20\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\x06\x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x06\x0b\x17\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x06\x18\x1b\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x06\x1e\x1f\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x07\x02\x1b\n\x0c\
    \n\x05\x04\0\x02\x01\x04\x12\x03\x07\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\
    \x12\x03\x07\x0b\x0e\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x07\x0f\x16\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x07\x19\x1a\n\x9f\x01\n\x04\x04\0\
    \x02\x02\x12\x03\x0c\x02\x1a\x1a\x91\x01\x20recursive\x20data\x20structu\
    res\x20are\x20impossible\x20in\x20protobuf.\x20they\x20will\x20be\x20unn\
    ested\n\x20and\x20referrd\x20to\x20by\x20indices.\n\x20valid\x20indices\
    \x20start\x20at\x201\x20instead\x20of\x200.\n\n\x0c\n\x05\x04\0\x02\x02\
    \x04\x12\x03\x0c\x02\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x0c\x0b\x0f\
    \n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0c\x10\x15\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\x0c\x18\x19\n\x0b\n\x04\x04\0\x02\x03\x12\x03\r\x023\n\
    \x0c\n\x05\x04\0\x02\x03\x04\x12\x03\r\x02\n\n\x0c\n\x05\x04\0\x02\x03\
    \x06\x12\x03\r\x0b\x1b\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\r\x1c.\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\r12\n\x0b\n\x04\x04\0\x02\x04\x12\
    \x03\x0e\x02D\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03\x0e\x02\n\n\x0c\n\
    \x05\x04\0\x02\x04\x06\x12\x03\x0e\x0b#\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03\x0e$?\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x0eBC\n\x0b\n\x04\
    \x04\0\x02\x05\x12\x03\x0f\x02\x20\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\
    \x0f\x02\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\x0f\x0b\x12\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03\x0f\x13\x1b\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03\x0f\x1e\x1f\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x10\x02(\n\x0c\n\x05\
    \x04\0\x02\x06\x04\x12\x03\x10\x02\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\
    \x03\x10\x0b\x16\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x10\x17#\n\x0c\n\
    \x05\x04\0\x02\x06\x03\x12\x03\x10&'\n\x0b\n\x04\x04\0\x02\x07\x12\x03\
    \x11\x02$\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03\x11\x02\n\n\x0c\n\x05\
    \x04\0\x02\x07\x06\x12\x03\x11\x0b\x14\n\x0c\n\x05\x04\0\x02\x07\x01\x12\
    \x03\x11\x15\x1f\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x11\"#\nH\n\x02\
    \x04\x01\x12\x04\x15\0\x1b\x01\x1a<\x20type\x20ExternalDecl\x20=\x20Eith\
    er[L[FunctionDef],\x20L[Declaration]]\n\n\n\n\x03\x04\x01\x01\x12\x03\
    \x15\x08\x14\n\x0c\n\x04\x04\x01\x08\0\x12\x04\x16\x02\x19\x03\n\x0c\n\
    \x05\x04\x01\x08\0\x01\x12\x03\x16\x08\n\n\x0b\n\x04\x04\x01\x02\0\x12\
    \x03\x17\x04\x17\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x17\x04\x0f\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03\x17\x10\x12\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03\x17\x15\x16\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x18\x04\x17\
    \n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x18\x04\x0f\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03\x18\x10\x12\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\
    \x18\x15\x16\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x1a\x02\x0e\n\x0c\n\x05\
    \x04\x01\x02\x02\x06\x12\x03\x1a\x02\x05\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03\x1a\x06\t\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x1a\x0c\r\n\
    \x0b\n\x02\x04\x02\x12\x05\x1d\0\xb6\x01\x01\n\n\n\x03\x04\x02\x01\x12\
    \x03\x1d\x08\x0c\n/\n\x04\x04\x02\x03\0\x12\x04\x20\x02*\x03\x1a!\x20one\
    \x20message\x20for\x208\x20literal\x20types\n\n\x0c\n\x05\x04\x02\x03\0\
    \x01\x12\x03\x20\n\x11\n\x0e\n\x06\x04\x02\x03\0\x04\0\x12\x04!\x04&\x05\
    \n\x0e\n\x07\x04\x02\x03\0\x04\0\x01\x12\x03!\t\r\n\x0f\n\x08\x04\x02\
    \x03\0\x04\0\x02\0\x12\x03\"\x06\x0f\n\x10\n\t\x04\x02\x03\0\x04\0\x02\0\
    \x01\x12\x03\"\x06\n\n\x10\n\t\x04\x02\x03\0\x04\0\x02\0\x02\x12\x03\"\r\
    \x0e\n\x0f\n\x08\x04\x02\x03\0\x04\0\x02\x01\x12\x03#\x06\x10\n\x10\n\t\
    \x04\x02\x03\0\x04\0\x02\x01\x01\x12\x03#\x06\x0b\n\x10\n\t\x04\x02\x03\
    \0\x04\0\x02\x01\x02\x12\x03#\x0e\x0f\n\x0f\n\x08\x04\x02\x03\0\x04\0\
    \x02\x02\x12\x03$\x06\x10\n\x10\n\t\x04\x02\x03\0\x04\0\x02\x02\x01\x12\
    \x03$\x06\x0b\n\x10\n\t\x04\x02\x03\0\x04\0\x02\x02\x02\x12\x03$\x0e\x0f\
    \n\x0f\n\x08\x04\x02\x03\0\x04\0\x02\x03\x12\x03%\x06\x10\n\x10\n\t\x04\
    \x02\x03\0\x04\0\x02\x03\x01\x12\x03%\x06\x0b\n\x10\n\t\x04\x02\x03\0\
    \x04\0\x02\x03\x02\x12\x03%\x0e\x0f\n\r\n\x06\x04\x02\x03\0\x02\0\x12\
    \x03'\x04\x10\n\x0e\n\x07\x04\x02\x03\0\x02\0\x05\x12\x03'\x04\t\n\x0e\n\
    \x07\x04\x02\x03\0\x02\0\x01\x12\x03'\n\x0b\n\x0e\n\x07\x04\x02\x03\0\
    \x02\0\x03\x12\x03'\x0e\x0f\n\r\n\x06\x04\x02\x03\0\x02\x01\x12\x03(\x04\
    \x12\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x06\x12\x03(\x04\x08\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x01\x01\x12\x03(\t\r\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x01\x03\x12\x03(\x10\x11\n\r\n\x06\x04\x02\x03\0\x02\x02\x12\x03)\x04\
    \x14\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x05\x12\x03)\x04\x08\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x02\x01\x12\x03)\t\x0f\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x02\x03\x12\x03)\x12\x13\n\x0c\n\x04\x04\x02\x03\x01\x12\x04,\x021\x03\
    \n\x0c\n\x05\x04\x02\x03\x01\x01\x12\x03,\n\x0e\n\r\n\x06\x04\x02\x03\
    \x01\x02\0\x12\x03-\x04\x14\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x06\x12\
    \x03-\x04\x0c\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x01\x12\x03-\r\x0f\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\0\x03\x12\x03-\x12\x13\n\r\n\x06\x04\x02\x03\
    \x01\x02\x01\x12\x03.\x04\x13\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x06\
    \x12\x03.\x04\x07\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x01\x12\x03.\x08\
    \x0e\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x03\x12\x03.\x11\x12\n\x15\n\
    \x06\x04\x02\x03\x01\x02\x02\x12\x03/\x04\x14\"\x06\x20Expr\n\n\x0e\n\
    \x07\x04\x02\x03\x01\x02\x02\x05\x12\x03/\x04\t\n\x0e\n\x07\x04\x02\x03\
    \x01\x02\x02\x01\x12\x03/\n\x0f\n\x0e\n\x07\x04\x02\x03\x01\x02\x02\x03\
    \x12\x03/\x12\x13\n\r\n\x06\x04\x02\x03\x01\x02\x03\x12\x030\x04\x12\n\
    \x0e\n\x07\x04\x02\x03\x01\x02\x03\x06\x12\x030\x04\x07\n\x0e\n\x07\x04\
    \x02\x03\x01\x02\x03\x01\x12\x030\x08\r\n\x0e\n\x07\x04\x02\x03\x01\x02\
    \x03\x03\x12\x030\x10\x11\n\x0c\n\x04\x04\x02\x03\x02\x12\x043\x028\x03\
    \n\x0c\n\x05\x04\x02\x03\x02\x01\x12\x033\n\x10\n\x15\n\x06\x04\x02\x03\
    \x02\x02\0\x12\x034\x04\x16\"\x06\x20Expr\n\n\x0e\n\x07\x04\x02\x03\x02\
    \x02\0\x05\x12\x034\x04\t\n\x0e\n\x07\x04\x02\x03\x02\x02\0\x01\x12\x034\
    \n\x11\n\x0e\n\x07\x04\x02\x03\x02\x02\0\x03\x12\x034\x14\x15\n\r\n\x06\
    \x04\x02\x03\x02\x02\x01\x12\x035\x04\x14\n\x0e\n\x07\x04\x02\x03\x02\
    \x02\x01\x06\x12\x035\x04\x07\n\x0e\n\x07\x04\x02\x03\x02\x02\x01\x01\
    \x12\x035\x08\x0f\n\x0e\n\x07\x04\x02\x03\x02\x02\x01\x03\x12\x035\x12\
    \x13\n\x15\n\x06\x04\x02\x03\x02\x02\x02\x12\x036\x04\x16\"\x06\x20Expr\
    \n\n\x0e\n\x07\x04\x02\x03\x02\x02\x02\x05\x12\x036\x04\t\n\x0e\n\x07\
    \x04\x02\x03\x02\x02\x02\x01\x12\x036\n\x11\n\x0e\n\x07\x04\x02\x03\x02\
    \x02\x02\x03\x12\x036\x14\x15\n\r\n\x06\x04\x02\x03\x02\x02\x03\x12\x037\
    \x04\x14\n\x0e\n\x07\x04\x02\x03\x02\x02\x03\x06\x12\x037\x04\x07\n\x0e\
    \n\x07\x04\x02\x03\x02\x02\x03\x01\x12\x037\x08\x0f\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\x03\x03\x12\x037\x12\x13\n\x0c\n\x04\x04\x02\x03\x03\x12\
    \x04:\x02?\x03\n\x0c\n\x05\x04\x02\x03\x03\x01\x12\x03:\n\x12\n\x15\n\
    \x06\x04\x02\x03\x03\x02\0\x12\x03;\x04\x15\"\x06\x20Expr\n\n\x0e\n\x07\
    \x04\x02\x03\x03\x02\0\x05\x12\x03;\x04\t\n\x0e\n\x07\x04\x02\x03\x03\
    \x02\0\x01\x12\x03;\n\x10\n\x0e\n\x07\x04\x02\x03\x03\x02\0\x03\x12\x03;\
    \x13\x14\n\r\n\x06\x04\x02\x03\x03\x02\x01\x12\x03<\x04\x13\n\x0e\n\x07\
    \x04\x02\x03\x03\x02\x01\x06\x12\x03<\x04\x07\n\x0e\n\x07\x04\x02\x03\
    \x03\x02\x01\x01\x12\x03<\x08\x0e\n\x0e\n\x07\x04\x02\x03\x03\x02\x01\
    \x03\x12\x03<\x11\x12\n\x17\n\x06\x04\x02\x03\x03\x02\x02\x12\x03=\x04\
    \x1c\"\x08\x20[Expr]\n\n\x0e\n\x07\x04\x02\x03\x03\x02\x02\x04\x12\x03=\
    \x04\x0c\n\x0e\n\x07\x04\x02\x03\x03\x02\x02\x05\x12\x03=\r\x12\n\x0e\n\
    \x07\x04\x02\x03\x03\x02\x02\x01\x12\x03=\x13\x17\n\x0e\n\x07\x04\x02\
    \x03\x03\x02\x02\x03\x12\x03=\x1a\x1b\n\r\n\x06\x04\x02\x03\x03\x02\x03\
    \x12\x03>\x04\x1e\n\x0e\n\x07\x04\x02\x03\x03\x02\x03\x04\x12\x03>\x04\
    \x0c\n\x0e\n\x07\x04\x02\x03\x03\x02\x03\x06\x12\x03>\r\x10\n\x0e\n\x07\
    \x04\x02\x03\x03\x02\x03\x01\x12\x03>\x11\x19\n\x0e\n\x07\x04\x02\x03\
    \x03\x02\x03\x03\x12\x03>\x1c\x1d\n\x0c\n\x04\x04\x02\x03\x04\x12\x04A\
    \x02F\x03\n\x0c\n\x05\x04\x02\x03\x04\x01\x12\x03A\n\r\n\x15\n\x06\x04\
    \x02\x03\x04\x02\0\x12\x03B\x04\x14\"\x06\x20Expr\n\n\x0e\n\x07\x04\x02\
    \x03\x04\x02\0\x05\x12\x03B\x04\t\n\x0e\n\x07\x04\x02\x03\x04\x02\0\x01\
    \x12\x03B\n\x0f\n\x0e\n\x07\x04\x02\x03\x04\x02\0\x03\x12\x03B\x12\x13\n\
    \r\n\x06\x04\x02\x03\x04\x02\x01\x12\x03C\x04\x12\n\x0e\n\x07\x04\x02\
    \x03\x04\x02\x01\x06\x12\x03C\x04\x07\n\x0e\n\x07\x04\x02\x03\x04\x02\
    \x01\x01\x12\x03C\x08\r\n\x0e\n\x07\x04\x02\x03\x04\x02\x01\x03\x12\x03C\
    \x10\x11\n\r\n\x06\x04\x02\x03\x04\x02\x02\x12\x03D\x04\x15\n\x0e\n\x07\
    \x04\x02\x03\x04\x02\x02\x05\x12\x03D\x04\n\n\x0e\n\x07\x04\x02\x03\x04\
    \x02\x02\x01\x12\x03D\x0b\x10\n\x0e\n\x07\x04\x02\x03\x04\x02\x02\x03\
    \x12\x03D\x13\x14\n\r\n\x06\x04\x02\x03\x04\x02\x03\x12\x03E\x04\x16\n\
    \x0e\n\x07\x04\x02\x03\x04\x02\x03\x06\x12\x03E\x04\x07\n\x0e\n\x07\x04\
    \x02\x03\x04\x02\x03\x01\x12\x03E\x08\x11\n\x0e\n\x07\x04\x02\x03\x04\
    \x02\x03\x03\x12\x03E\x14\x15\n\x0c\n\x04\x04\x02\x03\x05\x12\x04H\x02M\
    \x03\n\x0c\n\x05\x04\x02\x03\x05\x01\x12\x03H\n\r\n\x15\n\x06\x04\x02\
    \x03\x05\x02\0\x12\x03I\x04\x14\"\x06\x20Expr\n\n\x0e\n\x07\x04\x02\x03\
    \x05\x02\0\x05\x12\x03I\x04\t\n\x0e\n\x07\x04\x02\x03\x05\x02\0\x01\x12\
    \x03I\n\x0f\n\x0e\n\x07\x04\x02\x03\x05\x02\0\x03\x12\x03I\x12\x13\n\r\n\
    \x06\x04\x02\x03\x05\x02\x01\x12\x03J\x04\x12\n\x0e\n\x07\x04\x02\x03\
    \x05\x02\x01\x06\x12\x03J\x04\x07\n\x0e\n\x07\x04\x02\x03\x05\x02\x01\
    \x01\x12\x03J\x08\r\n\x0e\n\x07\x04\x02\x03\x05\x02\x01\x03\x12\x03J\x10\
    \x11\n\r\n\x06\x04\x02\x03\x05\x02\x02\x12\x03K\x04\x15\n\x0e\n\x07\x04\
    \x02\x03\x05\x02\x02\x05\x12\x03K\x04\n\n\x0e\n\x07\x04\x02\x03\x05\x02\
    \x02\x01\x12\x03K\x0b\x10\n\x0e\n\x07\x04\x02\x03\x05\x02\x02\x03\x12\
    \x03K\x13\x14\n\r\n\x06\x04\x02\x03\x05\x02\x03\x12\x03L\x04\x16\n\x0e\n\
    \x07\x04\x02\x03\x05\x02\x03\x06\x12\x03L\x04\x07\n\x0e\n\x07\x04\x02\
    \x03\x05\x02\x03\x01\x12\x03L\x08\x11\n\x0e\n\x07\x04\x02\x03\x05\x02\
    \x03\x03\x12\x03L\x14\x15\n\x0c\n\x04\x04\x02\x03\x06\x12\x04O\x02R\x03\
    \n\x0c\n\x05\x04\x02\x03\x06\x01\x12\x03O\n\x13\n\x15\n\x06\x04\x02\x03\
    \x06\x02\0\x12\x03P\x04\x14\"\x06\x20Expr\n\n\x0e\n\x07\x04\x02\x03\x06\
    \x02\0\x05\x12\x03P\x04\t\n\x0e\n\x07\x04\x02\x03\x06\x02\0\x01\x12\x03P\
    \n\x0f\n\x0e\n\x07\x04\x02\x03\x06\x02\0\x03\x12\x03P\x12\x13\n\r\n\x06\
    \x04\x02\x03\x06\x02\x01\x12\x03Q\x04\x12\n\x0e\n\x07\x04\x02\x03\x06\
    \x02\x01\x06\x12\x03Q\x04\x07\n\x0e\n\x07\x04\x02\x03\x06\x02\x01\x01\
    \x12\x03Q\x08\r\n\x0e\n\x07\x04\x02\x03\x06\x02\x01\x03\x12\x03Q\x10\x11\
    \n\x0c\n\x04\x04\x02\x03\x07\x12\x04T\x02W\x03\n\x0c\n\x05\x04\x02\x03\
    \x07\x01\x12\x03T\n\x14\n\r\n\x06\x04\x02\x03\x07\x02\0\x12\x03U\x04\x14\
    \n\x0e\n\x07\x04\x02\x03\x07\x02\0\x06\x12\x03U\x04\x0c\n\x0e\n\x07\x04\
    \x02\x03\x07\x02\0\x01\x12\x03U\r\x0f\n\x0e\n\x07\x04\x02\x03\x07\x02\0\
    \x03\x12\x03U\x12\x13\n\r\n\x06\x04\x02\x03\x07\x02\x01\x12\x03V\x04\x13\
    \n\x0e\n\x07\x04\x02\x03\x07\x02\x01\x06\x12\x03V\x04\x07\n\x0e\n\x07\
    \x04\x02\x03\x07\x02\x01\x01\x12\x03V\x08\x0e\n\x0e\n\x07\x04\x02\x03\
    \x07\x02\x01\x03\x12\x03V\x11\x12\n\x0c\n\x04\x04\x02\x03\x08\x12\x04Y\
    \x02k\x03\n\x0c\n\x05\x04\x02\x03\x08\x01\x12\x03Y\n\x0f\n\x0e\n\x06\x04\
    \x02\x03\x08\x04\0\x12\x04Z\x04e\x05\n\x0e\n\x07\x04\x02\x03\x08\x04\0\
    \x01\x12\x03Z\t\x0b\n\x16\n\x08\x04\x02\x03\x08\x04\0\x02\0\x12\x03[\x06\
    \x15\"\x05\x20++n\n\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\0\x01\x12\x03[\
    \x06\x10\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\0\x02\x12\x03[\x13\x14\n\
    \x16\n\x08\x04\x02\x03\x08\x04\0\x02\x01\x12\x03\\\x06\x15\"\x05\x20--n\
    \n\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x01\x01\x12\x03\\\x06\x10\n\x10\n\
    \t\x04\x02\x03\x08\x04\0\x02\x01\x02\x12\x03\\\x13\x14\n\x16\n\x08\x04\
    \x02\x03\x08\x04\0\x02\x02\x12\x03]\x06\x16\"\x05\x20n++\n\n\x10\n\t\x04\
    \x02\x03\x08\x04\0\x02\x02\x01\x12\x03]\x06\x11\n\x10\n\t\x04\x02\x03\
    \x08\x04\0\x02\x02\x02\x12\x03]\x14\x15\n\x16\n\x08\x04\x02\x03\x08\x04\
    \0\x02\x03\x12\x03^\x06\x16\"\x05\x20n--\n\n\x10\n\t\x04\x02\x03\x08\x04\
    \0\x02\x03\x01\x12\x03^\x06\x11\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x03\
    \x02\x12\x03^\x14\x15\n\x15\n\x08\x04\x02\x03\x08\x04\0\x02\x04\x12\x03_\
    \x06\x0e\"\x04\x20&n\n\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x04\x01\x12\
    \x03_\x06\t\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x04\x02\x12\x03_\x0c\r\n\
    \x15\n\x08\x04\x02\x03\x08\x04\0\x02\x05\x12\x03`\x06\x10\"\x04\x20*n\n\
    \n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x05\x01\x12\x03`\x06\x0b\n\x10\n\t\
    \x04\x02\x03\x08\x04\0\x02\x05\x02\x12\x03`\x0e\x0f\n\x15\n\x08\x04\x02\
    \x03\x08\x04\0\x02\x06\x12\x03a\x06\x0e\"\x04\x20+n\n\n\x10\n\t\x04\x02\
    \x03\x08\x04\0\x02\x06\x01\x12\x03a\x06\t\n\x10\n\t\x04\x02\x03\x08\x04\
    \0\x02\x06\x02\x12\x03a\x0c\r\n\x15\n\x08\x04\x02\x03\x08\x04\0\x02\x07\
    \x12\x03b\x06\x0e\"\x04\x20-n\n\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x07\
    \x01\x12\x03b\x06\t\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x07\x02\x12\x03b\
    \x0c\r\n\x15\n\x08\x04\x02\x03\x08\x04\0\x02\x08\x12\x03c\x06\x12\"\x04\
    \x20~n\n\n\x10\n\t\x04\x02\x03\x08\x04\0\x02\x08\x01\x12\x03c\x06\r\n\
    \x10\n\t\x04\x02\x03\x08\x04\0\x02\x08\x02\x12\x03c\x10\x11\n\x15\n\x08\
    \x04\x02\x03\x08\x04\0\x02\t\x12\x03d\x06\x14\"\x04\x20!n\n\n\x10\n\t\
    \x04\x02\x03\x08\x04\0\x02\t\x01\x12\x03d\x06\x0f\n\x10\n\t\x04\x02\x03\
    \x08\x04\0\x02\t\x02\x12\x03d\x12\x13\n\x15\n\x06\x04\x02\x03\x08\x02\0\
    \x12\x03g\x04\x14\"\x06\x20Expr\n\n\x0e\n\x07\x04\x02\x03\x08\x02\0\x05\
    \x12\x03g\x04\t\n\x0e\n\x07\x04\x02\x03\x08\x02\0\x01\x12\x03g\n\x0f\n\
    \x0e\n\x07\x04\x02\x03\x08\x02\0\x03\x12\x03g\x12\x13\n\r\n\x06\x04\x02\
    \x03\x08\x02\x01\x12\x03h\x04\x12\n\x0e\n\x07\x04\x02\x03\x08\x02\x01\
    \x06\x12\x03h\x04\x07\n\x0e\n\x07\x04\x02\x03\x08\x02\x01\x01\x12\x03h\
    \x08\r\n\x0e\n\x07\x04\x02\x03\x08\x02\x01\x03\x12\x03h\x10\x11\n\r\n\
    \x06\x04\x02\x03\x08\x02\x02\x12\x03i\x04\x0e\n\x0e\n\x07\x04\x02\x03\
    \x08\x02\x02\x06\x12\x03i\x04\x06\n\x0e\n\x07\x04\x02\x03\x08\x02\x02\
    \x01\x12\x03i\x07\t\n\x0e\n\x07\x04\x02\x03\x08\x02\x02\x03\x12\x03i\x0c\
    \r\n\r\n\x06\x04\x02\x03\x08\x02\x03\x12\x03j\x04\x13\n\x0e\n\x07\x04\
    \x02\x03\x08\x02\x03\x06\x12\x03j\x04\x07\n\x0e\n\x07\x04\x02\x03\x08\
    \x02\x03\x01\x12\x03j\x08\x0e\n\x0e\n\x07\x04\x02\x03\x08\x02\x03\x03\
    \x12\x03j\x11\x12\n\r\n\x04\x04\x02\x03\t\x12\x05m\x02\x95\x01\x03\n\x0c\
    \n\x05\x04\x02\x03\t\x01\x12\x03m\n\x10\n\x0f\n\x06\x04\x02\x03\t\x04\0\
    \x12\x05n\x04\x8d\x01\x05\n\x0e\n\x07\x04\x02\x03\t\x04\0\x01\x12\x03n\t\
    \x0b\n\x18\n\x08\x04\x02\x03\t\x04\0\x02\0\x12\x03o\x06\x11\"\x07\x20a\
    \x20=\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\0\x01\x12\x03o\x06\x0c\n\
    \x10\n\t\x04\x02\x03\t\x04\0\x02\0\x02\x12\x03o\x0f\x10\n\x19\n\x08\x04\
    \x02\x03\t\x04\0\x02\x01\x12\x03p\x06\x15\"\x08\x20a\x20*=\x20b\n\n\x10\
    \n\t\x04\x02\x03\t\x04\0\x02\x01\x01\x12\x03p\x06\x10\n\x10\n\t\x04\x02\
    \x03\t\x04\0\x02\x01\x02\x12\x03p\x13\x14\n\x19\n\x08\x04\x02\x03\t\x04\
    \0\x02\x02\x12\x03q\x06\x15\"\x08\x20a\x20/=\x20b\n\n\x10\n\t\x04\x02\
    \x03\t\x04\0\x02\x02\x01\x12\x03q\x06\x10\n\x10\n\t\x04\x02\x03\t\x04\0\
    \x02\x02\x02\x12\x03q\x13\x14\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x03\
    \x12\x03r\x06\x15\"\x08\x20a\x20%=\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\
    \x02\x03\x01\x12\x03r\x06\x10\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x03\x02\
    \x12\x03r\x13\x14\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x04\x12\x03s\x06\
    \x15\"\x08\x20a\x20+=\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x04\x01\
    \x12\x03s\x06\x10\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x04\x02\x12\x03s\x13\
    \x14\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x05\x12\x03t\x06\x15\"\x08\x20a\
    \x20-=\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x05\x01\x12\x03t\x06\x10\
    \n\x10\n\t\x04\x02\x03\t\x04\0\x02\x05\x02\x12\x03t\x13\x14\n\x1a\n\x08\
    \x04\x02\x03\t\x04\0\x02\x06\x12\x03u\x06\x19\"\t\x20a\x20<<=\x20b\n\n\
    \x10\n\t\x04\x02\x03\t\x04\0\x02\x06\x01\x12\x03u\x06\x14\n\x10\n\t\x04\
    \x02\x03\t\x04\0\x02\x06\x02\x12\x03u\x17\x18\n\x1a\n\x08\x04\x02\x03\t\
    \x04\0\x02\x07\x12\x03v\x06\x19\"\t\x20a\x20>>=\x20b\n\n\x10\n\t\x04\x02\
    \x03\t\x04\0\x02\x07\x01\x12\x03v\x06\x14\n\x10\n\t\x04\x02\x03\t\x04\0\
    \x02\x07\x02\x12\x03v\x17\x18\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x08\
    \x12\x03w\x06\x1c\"\x08\x20a\x20&=\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\
    \x02\x08\x01\x12\x03w\x06\x17\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x08\x02\
    \x12\x03w\x1a\x1b\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\t\x12\x03x\x06\x15\
    \"\x08\x20a\x20^=\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\t\x01\x12\x03\
    x\x06\x10\n\x10\n\t\x04\x02\x03\t\x04\0\x02\t\x02\x12\x03x\x13\x14\n\x19\
    \n\x08\x04\x02\x03\t\x04\0\x02\n\x12\x03y\x06\x1c\"\x08\x20a\x20|=\x20b\
    \n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\n\x01\x12\x03y\x06\x16\n\x10\n\t\
    \x04\x02\x03\t\x04\0\x02\n\x02\x12\x03y\x19\x1b\n\x17\n\x08\x04\x02\x03\
    \t\x04\0\x02\x0b\x12\x03z\x06\x11\"\x06\x20a,\x20b\n\n\x10\n\t\x04\x02\
    \x03\t\x04\0\x02\x0b\x01\x12\x03z\x06\x0b\n\x10\n\t\x04\x02\x03\t\x04\0\
    \x02\x0b\x02\x12\x03z\x0e\x10\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x0c\
    \x12\x03{\x06\x14\"\x08\x20a\x20||\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\
    \x02\x0c\x01\x12\x03{\x06\x0e\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x0c\x02\
    \x12\x03{\x11\x13\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\r\x12\x03|\x06\x15\
    \"\x08\x20a\x20&&\x20b\n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\r\x01\x12\x03\
    |\x06\x0f\n\x10\n\t\x04\x02\x03\t\x04\0\x02\r\x02\x12\x03|\x12\x14\n\x18\
    \n\x08\x04\x02\x03\t\x04\0\x02\x0e\x12\x03}\x06\x12\"\x07\x20a\x20|\x20b\
    \n\n\x10\n\t\x04\x02\x03\t\x04\0\x02\x0e\x01\x12\x03}\x06\x0c\n\x10\n\t\
    \x04\x02\x03\t\x04\0\x02\x0e\x02\x12\x03}\x0f\x11\n\x18\n\x08\x04\x02\
    \x03\t\x04\0\x02\x0f\x12\x03~\x06\x0f\"\x07\x20a\x20^\x20b\n\n\x10\n\t\
    \x04\x02\x03\t\x04\0\x02\x0f\x01\x12\x03~\x06\t\n\x10\n\t\x04\x02\x03\t\
    \x04\0\x02\x0f\x02\x12\x03~\x0c\x0e\n\x18\n\x08\x04\x02\x03\t\x04\0\x02\
    \x10\x12\x03\x7f\x06\x13\"\x07\x20a\x20&\x20b\n\n\x10\n\t\x04\x02\x03\t\
    \x04\0\x02\x10\x01\x12\x03\x7f\x06\r\n\x10\n\t\x04\x02\x03\t\x04\0\x02\
    \x10\x02\x12\x03\x7f\x10\x12\n\x1a\n\x08\x04\x02\x03\t\x04\0\x02\x11\x12\
    \x04\x80\x01\x06\x0e\"\x08\x20a\x20==\x20b\n\n\x11\n\t\x04\x02\x03\t\x04\
    \0\x02\x11\x01\x12\x04\x80\x01\x06\x08\n\x11\n\t\x04\x02\x03\t\x04\0\x02\
    \x11\x02\x12\x04\x80\x01\x0b\r\n\x1a\n\x08\x04\x02\x03\t\x04\0\x02\x12\
    \x12\x04\x81\x01\x06\x0f\"\x08\x20a\x20!=\x20b\n\n\x11\n\t\x04\x02\x03\t\
    \x04\0\x02\x12\x01\x12\x04\x81\x01\x06\t\n\x11\n\t\x04\x02\x03\t\x04\0\
    \x02\x12\x02\x12\x04\x81\x01\x0c\x0e\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\
    \x13\x12\x04\x82\x01\x06\x10\"\x07\x20a\x20<\x20b\n\n\x11\n\t\x04\x02\
    \x03\t\x04\0\x02\x13\x01\x12\x04\x82\x01\x06\n\n\x11\n\t\x04\x02\x03\t\
    \x04\0\x02\x13\x02\x12\x04\x82\x01\r\x0f\n\x19\n\x08\x04\x02\x03\t\x04\0\
    \x02\x14\x12\x04\x83\x01\x06\x0e\"\x07\x20a\x20>\x20b\n\n\x11\n\t\x04\
    \x02\x03\t\x04\0\x02\x14\x01\x12\x04\x83\x01\x06\x08\n\x11\n\t\x04\x02\
    \x03\t\x04\0\x02\x14\x02\x12\x04\x83\x01\x0b\r\n\x1a\n\x08\x04\x02\x03\t\
    \x04\0\x02\x15\x12\x04\x84\x01\x06\x0f\"\x08\x20a\x20<=\x20b\n\n\x11\n\t\
    \x04\x02\x03\t\x04\0\x02\x15\x01\x12\x04\x84\x01\x06\t\n\x11\n\t\x04\x02\
    \x03\t\x04\0\x02\x15\x02\x12\x04\x84\x01\x0c\x0e\n\x1a\n\x08\x04\x02\x03\
    \t\x04\0\x02\x16\x12\x04\x85\x01\x06\x0f\"\x08\x20a\x20>=\x20b\n\n\x11\n\
    \t\x04\x02\x03\t\x04\0\x02\x16\x01\x12\x04\x85\x01\x06\t\n\x11\n\t\x04\
    \x02\x03\t\x04\0\x02\x16\x02\x12\x04\x85\x01\x0c\x0e\n\x1a\n\x08\x04\x02\
    \x03\t\x04\0\x02\x17\x12\x04\x86\x01\x06\x13\"\x08\x20a\x20<<\x20b\n\n\
    \x11\n\t\x04\x02\x03\t\x04\0\x02\x17\x01\x12\x04\x86\x01\x06\r\n\x11\n\t\
    \x04\x02\x03\t\x04\0\x02\x17\x02\x12\x04\x86\x01\x10\x12\n\x1a\n\x08\x04\
    \x02\x03\t\x04\0\x02\x18\x12\x04\x87\x01\x06\x13\"\x08\x20a\x20>>\x20b\n\
    \n\x11\n\t\x04\x02\x03\t\x04\0\x02\x18\x01\x12\x04\x87\x01\x06\r\n\x11\n\
    \t\x04\x02\x03\t\x04\0\x02\x18\x02\x12\x04\x87\x01\x10\x12\n\x19\n\x08\
    \x04\x02\x03\t\x04\0\x02\x19\x12\x04\x88\x01\x06\x0f\"\x07\x20a\x20+\x20\
    b\n\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x19\x01\x12\x04\x88\x01\x06\t\n\
    \x11\n\t\x04\x02\x03\t\x04\0\x02\x19\x02\x12\x04\x88\x01\x0c\x0e\n\x19\n\
    \x08\x04\x02\x03\t\x04\0\x02\x1a\x12\x04\x89\x01\x06\x0f\"\x07\x20a\x20-\
    \x20b\n\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1a\x01\x12\x04\x89\x01\x06\t\
    \n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1a\x02\x12\x04\x89\x01\x0c\x0e\n\x19\
    \n\x08\x04\x02\x03\t\x04\0\x02\x1b\x12\x04\x8a\x01\x06\x0f\"\x07\x20a\
    \x20*\x20b\n\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1b\x01\x12\x04\x8a\x01\
    \x06\t\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1b\x02\x12\x04\x8a\x01\x0c\x0e\
    \n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x1c\x12\x04\x8b\x01\x06\x0f\"\x07\
    \x20a\x20/\x20b\n\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1c\x01\x12\x04\x8b\
    \x01\x06\t\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1c\x02\x12\x04\x8b\x01\x0c\
    \x0e\n\x19\n\x08\x04\x02\x03\t\x04\0\x02\x1d\x12\x04\x8c\x01\x06\x0f\"\
    \x07\x20a\x20%\x20b\n\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1d\x01\x12\x04\
    \x8c\x01\x06\t\n\x11\n\t\x04\x02\x03\t\x04\0\x02\x1d\x02\x12\x04\x8c\x01\
    \x0c\x0e\n\x16\n\x06\x04\x02\x03\t\x02\0\x12\x04\x8f\x01\x04\x15\"\x06\
    \x20Expr\n\n\x0f\n\x07\x04\x02\x03\t\x02\0\x05\x12\x04\x8f\x01\x04\t\n\
    \x0f\n\x07\x04\x02\x03\t\x02\0\x01\x12\x04\x8f\x01\n\x10\n\x0f\n\x07\x04\
    \x02\x03\t\x02\0\x03\x12\x04\x8f\x01\x13\x14\n\x0e\n\x06\x04\x02\x03\t\
    \x02\x01\x12\x04\x90\x01\x04\x13\n\x0f\n\x07\x04\x02\x03\t\x02\x01\x06\
    \x12\x04\x90\x01\x04\x07\n\x0f\n\x07\x04\x02\x03\t\x02\x01\x01\x12\x04\
    \x90\x01\x08\x0e\n\x0f\n\x07\x04\x02\x03\t\x02\x01\x03\x12\x04\x90\x01\
    \x11\x12\n\x16\n\x06\x04\x02\x03\t\x02\x02\x12\x04\x91\x01\x04\x15\"\x06\
    \x20Expr\n\n\x0f\n\x07\x04\x02\x03\t\x02\x02\x05\x12\x04\x91\x01\x04\t\n\
    \x0f\n\x07\x04\x02\x03\t\x02\x02\x01\x12\x04\x91\x01\n\x10\n\x0f\n\x07\
    \x04\x02\x03\t\x02\x02\x03\x12\x04\x91\x01\x13\x14\n\x0e\n\x06\x04\x02\
    \x03\t\x02\x03\x12\x04\x92\x01\x04\x13\n\x0f\n\x07\x04\x02\x03\t\x02\x03\
    \x06\x12\x04\x92\x01\x04\x07\n\x0f\n\x07\x04\x02\x03\t\x02\x03\x01\x12\
    \x04\x92\x01\x08\x0e\n\x0f\n\x07\x04\x02\x03\t\x02\x03\x03\x12\x04\x92\
    \x01\x11\x12\n\x0e\n\x06\x04\x02\x03\t\x02\x04\x12\x04\x93\x01\x04\x0e\n\
    \x0f\n\x07\x04\x02\x03\t\x02\x04\x06\x12\x04\x93\x01\x04\x06\n\x0f\n\x07\
    \x04\x02\x03\t\x02\x04\x01\x12\x04\x93\x01\x07\t\n\x0f\n\x07\x04\x02\x03\
    \t\x02\x04\x03\x12\x04\x93\x01\x0c\r\n\x0e\n\x06\x04\x02\x03\t\x02\x05\
    \x12\x04\x94\x01\x04\x13\n\x0f\n\x07\x04\x02\x03\t\x02\x05\x06\x12\x04\
    \x94\x01\x04\x07\n\x0f\n\x07\x04\x02\x03\t\x02\x05\x01\x12\x04\x94\x01\
    \x08\x0e\n\x0f\n\x07\x04\x02\x03\t\x02\x05\x03\x12\x04\x94\x01\x11\x12\n\
    \x0e\n\x04\x04\x02\x03\n\x12\x06\x97\x01\x02\x9e\x01\x03\n\r\n\x05\x04\
    \x02\x03\n\x01\x12\x04\x97\x01\n\x11\n\x16\n\x06\x04\x02\x03\n\x02\0\x12\
    \x04\x98\x01\x04\x17\"\x06\x20Expr\n\n\x0f\n\x07\x04\x02\x03\n\x02\0\x05\
    \x12\x04\x98\x01\x04\t\n\x0f\n\x07\x04\x02\x03\n\x02\0\x01\x12\x04\x98\
    \x01\n\x12\n\x0f\n\x07\x04\x02\x03\n\x02\0\x03\x12\x04\x98\x01\x15\x16\n\
    \x0e\n\x06\x04\x02\x03\n\x02\x01\x12\x04\x99\x01\x04\x15\n\x0f\n\x07\x04\
    \x02\x03\n\x02\x01\x06\x12\x04\x99\x01\x04\x07\n\x0f\n\x07\x04\x02\x03\n\
    \x02\x01\x01\x12\x04\x99\x01\x08\x10\n\x0f\n\x07\x04\x02\x03\n\x02\x01\
    \x03\x12\x04\x99\x01\x13\x14\n\x16\n\x06\x04\x02\x03\n\x02\x02\x12\x04\
    \x9a\x01\x04\x17\"\x06\x20Expr\n\n\x0f\n\x07\x04\x02\x03\n\x02\x02\x05\
    \x12\x04\x9a\x01\x04\t\n\x0f\n\x07\x04\x02\x03\n\x02\x02\x01\x12\x04\x9a\
    \x01\n\x12\n\x0f\n\x07\x04\x02\x03\n\x02\x02\x03\x12\x04\x9a\x01\x15\x16\
    \n\x0e\n\x06\x04\x02\x03\n\x02\x03\x12\x04\x9b\x01\x04\x15\n\x0f\n\x07\
    \x04\x02\x03\n\x02\x03\x06\x12\x04\x9b\x01\x04\x07\n\x0f\n\x07\x04\x02\
    \x03\n\x02\x03\x01\x12\x04\x9b\x01\x08\x10\n\x0f\n\x07\x04\x02\x03\n\x02\
    \x03\x03\x12\x04\x9b\x01\x13\x14\n\x16\n\x06\x04\x02\x03\n\x02\x04\x12\
    \x04\x9c\x01\x04\x17\"\x06\x20Expr\n\n\x0f\n\x07\x04\x02\x03\n\x02\x04\
    \x05\x12\x04\x9c\x01\x04\t\n\x0f\n\x07\x04\x02\x03\n\x02\x04\x01\x12\x04\
    \x9c\x01\n\x12\n\x0f\n\x07\x04\x02\x03\n\x02\x04\x03\x12\x04\x9c\x01\x15\
    \x16\n\x0e\n\x06\x04\x02\x03\n\x02\x05\x12\x04\x9d\x01\x04\x15\n\x0f\n\
    \x07\x04\x02\x03\n\x02\x05\x06\x12\x04\x9d\x01\x04\x07\n\x0f\n\x07\x04\
    \x02\x03\n\x02\x05\x01\x12\x04\x9d\x01\x08\x10\n\x0f\n\x07\x04\x02\x03\n\
    \x02\x05\x03\x12\x04\x9d\x01\x13\x14\n\x0e\n\x04\x04\x02\x08\0\x12\x06\
    \xa0\x01\x02\xb5\x01\x03\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\xa0\x01\x08\
    \t\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xa1\x01\x04\x12\n\r\n\x05\x04\x02\
    \x02\0\x05\x12\x04\xa1\x01\x04\n\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xa1\
    \x01\x0b\r\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xa1\x01\x10\x11\n\x0c\n\
    \x04\x04\x02\x02\x01\x12\x04\xa2\x01\x04\x18\n\r\n\x05\x04\x02\x02\x01\
    \x06\x12\x04\xa2\x01\x04\x0b\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xa2\
    \x01\x0c\x13\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xa2\x01\x16\x17\n\x0c\
    \n\x04\x04\x02\x02\x02\x12\x04\xa3\x01\x04\x14\n\r\n\x05\x04\x02\x02\x02\
    \x05\x12\x04\xa3\x01\x04\t\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xa3\x01\
    \n\x0f\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xa3\x01\x12\x13\n\x0c\n\x04\
    \x04\x02\x02\x03\x12\x04\xa4\x01\x04\x16\n\r\n\x05\x04\x02\x02\x03\x05\
    \x12\x04\xa4\x01\x04\n\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xa4\x01\x0b\
    \x11\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xa4\x01\x14\x15\n_\n\x04\x04\
    \x02\x02\x04\x12\x04\xa6\x01\x04\x14\x1aG\x20???\x20long_double\x20=\x20\
    5;\x20//\x20it's\x20fine\x20to\x20treat\x20'long\x20double'\x20as\x20'do\
    uble'.\n\"\x08\x201\x20byte\n\n\r\n\x05\x04\x02\x02\x04\x05\x12\x04\xa6\
    \x01\x04\n\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xa6\x01\x0b\x0f\n\r\n\
    \x05\x04\x02\x02\x04\x03\x12\x04\xa6\x01\x12\x13\n\x17\n\x04\x04\x02\x02\
    \x05\x12\x04\xa7\x01\x04\x19\"\t\x202\x20bytes\n\n\r\n\x05\x04\x02\x02\
    \x05\x05\x12\x04\xa7\x01\x04\n\n\r\n\x05\x04\x02\x02\x05\x01\x12\x04\xa7\
    \x01\x0b\x14\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xa7\x01\x17\x18\n\x0c\
    \n\x04\x04\x02\x02\x06\x12\x04\xa8\x01\x04\x16\n\r\n\x05\x04\x02\x02\x06\
    \x05\x12\x04\xa8\x01\x04\n\n\r\n\x05\x04\x02\x02\x06\x01\x12\x04\xa8\x01\
    \x0b\x11\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\xa8\x01\x14\x15\n\x0c\n\
    \x04\x04\x02\x02\x07\x12\x04\xa9\x01\x04\x1b\n\r\n\x05\x04\x02\x02\x07\
    \x05\x12\x04\xa9\x01\x04\n\n\r\n\x05\x04\x02\x02\x07\x01\x12\x04\xa9\x01\
    \x0b\x16\n\r\n\x05\x04\x02\x02\x07\x03\x12\x04\xa9\x01\x19\x1a\n\x0c\n\
    \x04\x04\x02\x02\x08\x12\x04\xaa\x01\x04\x13\n\r\n\x05\x04\x02\x02\x08\
    \x06\x12\x04\xaa\x01\x04\x08\n\r\n\x05\x04\x02\x02\x08\x01\x12\x04\xaa\
    \x01\t\r\n\r\n\x05\x04\x02\x02\x08\x03\x12\x04\xaa\x01\x10\x12\n\x0c\n\
    \x04\x04\x02\x02\t\x12\x04\xab\x01\x04\x18\n\r\n\x05\x04\x02\x02\t\x06\
    \x12\x04\xab\x01\x04\n\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\xab\x01\x0b\
    \x12\n\r\n\x05\x04\x02\x02\t\x03\x12\x04\xab\x01\x15\x17\n\x0c\n\x04\x04\
    \x02\x02\n\x12\x04\xac\x01\x04\x1c\n\r\n\x05\x04\x02\x02\n\x06\x12\x04\
    \xac\x01\x04\x0c\n\r\n\x05\x04\x02\x02\n\x01\x12\x04\xac\x01\r\x16\n\r\n\
    \x05\x04\x02\x02\n\x03\x12\x04\xac\x01\x19\x1b\n\x0c\n\x04\x04\x02\x02\
    \x0b\x12\x04\xad\x01\x04\x11\n\r\n\x05\x04\x02\x02\x0b\x06\x12\x04\xad\
    \x01\x04\x07\n\r\n\x05\x04\x02\x02\x0b\x01\x12\x04\xad\x01\x08\x0b\n\r\n\
    \x05\x04\x02\x02\x0b\x03\x12\x04\xad\x01\x0e\x10\n\x0c\n\x04\x04\x02\x02\
    \x0c\x12\x04\xae\x01\x04\x11\n\r\n\x05\x04\x02\x02\x0c\x06\x12\x04\xae\
    \x01\x04\x07\n\r\n\x05\x04\x02\x02\x0c\x01\x12\x04\xae\x01\x08\x0b\n\r\n\
    \x05\x04\x02\x02\x0c\x03\x12\x04\xae\x01\x0e\x10\n\x0c\n\x04\x04\x02\x02\
    \r\x12\x04\xaf\x01\x04\x1e\n\r\n\x05\x04\x02\x02\r\x06\x12\x04\xaf\x01\
    \x04\r\n\r\n\x05\x04\x02\x02\r\x01\x12\x04\xaf\x01\x0e\x18\n\r\n\x05\x04\
    \x02\x02\r\x03\x12\x04\xaf\x01\x1b\x1d\n\x0c\n\x04\x04\x02\x02\x0e\x12\
    \x04\xb0\x01\x04\x1e\n\r\n\x05\x04\x02\x02\x0e\x06\x12\x04\xb0\x01\x04\
    \x0e\n\r\n\x05\x04\x02\x02\x0e\x01\x12\x04\xb0\x01\x0f\x18\n\r\n\x05\x04\
    \x02\x02\x0e\x03\x12\x04\xb0\x01\x1b\x1d\n\x0c\n\x04\x04\x02\x02\x0f\x12\
    \x04\xb2\x01\x04\x15\n\r\n\x05\x04\x02\x02\x0f\x06\x12\x04\xb2\x01\x04\t\
    \n\r\n\x05\x04\x02\x02\x0f\x01\x12\x04\xb2\x01\n\x0f\n\r\n\x05\x04\x02\
    \x02\x0f\x03\x12\x04\xb2\x01\x12\x14\n\x0c\n\x04\x04\x02\x02\x10\x12\x04\
    \xb3\x01\x04\x17\n\r\n\x05\x04\x02\x02\x10\x06\x12\x04\xb3\x01\x04\n\n\r\
    \n\x05\x04\x02\x02\x10\x01\x12\x04\xb3\x01\x0b\x11\n\r\n\x05\x04\x02\x02\
    \x10\x03\x12\x04\xb3\x01\x14\x16\n\x0c\n\x04\x04\x02\x02\x11\x12\x04\xb4\
    \x01\x04\x19\n\r\n\x05\x04\x02\x02\x11\x06\x12\x04\xb4\x01\x04\x0b\n\r\n\
    \x05\x04\x02\x02\x11\x01\x12\x04\xb4\x01\x0c\x13\n\r\n\x05\x04\x02\x02\
    \x11\x03\x12\x04\xb4\x01\x16\x18\n\x0c\n\x02\x04\x03\x12\x06\xb8\x01\0\
    \xed\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xb8\x01\x08\x15\n\x0c\n\x04\
    \x04\x03\x03\0\x12\x04\xb9\x01\x02\x11\n\r\n\x05\x04\x03\x03\0\x01\x12\
    \x04\xb9\x01\n\x0e\n\x0c\n\x04\x04\x03\x03\x01\x12\x04\xba\x01\x02\x11\n\
    \r\n\x05\x04\x03\x03\x01\x01\x12\x04\xba\x01\n\x0e\n\x0c\n\x04\x04\x03\
    \x03\x02\x12\x04\xbb\x01\x02\x12\n\r\n\x05\x04\x03\x03\x02\x01\x12\x04\
    \xbb\x01\n\x0f\n\x0c\n\x04\x04\x03\x03\x03\x12\x04\xbc\x01\x02\x10\n\r\n\
    \x05\x04\x03\x03\x03\x01\x12\x04\xbc\x01\n\r\n\x0c\n\x04\x04\x03\x03\x04\
    \x12\x04\xbd\x01\x02\x11\n\r\n\x05\x04\x03\x03\x04\x01\x12\x04\xbd\x01\n\
    \x0e\n\x0c\n\x04\x04\x03\x03\x05\x12\x04\xbe\x01\x02\x12\n\r\n\x05\x04\
    \x03\x03\x05\x01\x12\x04\xbe\x01\n\x0f\n\x0c\n\x04\x04\x03\x03\x06\x12\
    \x04\xbf\x01\x02\x13\n\r\n\x05\x04\x03\x03\x06\x01\x12\x04\xbf\x01\n\x10\
    \n\x0c\n\x04\x04\x03\x03\x07\x12\x04\xc0\x01\x02\x13\n\r\n\x05\x04\x03\
    \x03\x07\x01\x12\x04\xc0\x01\n\x10\n\x0c\n\x04\x04\x03\x03\x08\x12\x04\
    \xc1\x01\x02\x15\n\r\n\x05\x04\x03\x03\x08\x01\x12\x04\xc1\x01\n\x12\n\
    \x0e\n\x04\x04\x03\x03\t\x12\x06\xc3\x01\x02\xc8\x01\x03\n\r\n\x05\x04\
    \x03\x03\t\x01\x12\x04\xc3\x01\n\x10\n\x1a\n\x06\x04\x03\x03\t\x02\0\x12\
    \x04\xc4\x01\x04\x14\"\n\x20optional\n\n\x0f\n\x07\x04\x03\x03\t\x02\0\
    \x05\x12\x04\xc4\x01\x04\n\n\x0f\n\x07\x04\x03\x03\t\x02\0\x01\x12\x04\
    \xc4\x01\x0b\x0f\n\x0f\n\x07\x04\x03\x03\t\x02\0\x03\x12\x04\xc4\x01\x12\
    \x13\n\x0e\n\x06\x04\x03\x03\t\x02\x01\x12\x04\xc5\x01\x04\x15\n\x0f\n\
    \x07\x04\x03\x03\t\x02\x01\x06\x12\x04\xc5\x01\x04\x07\n\x0f\n\x07\x04\
    \x03\x03\t\x02\x01\x01\x12\x04\xc5\x01\x08\x10\n\x0f\n\x07\x04\x03\x03\t\
    \x02\x01\x03\x12\x04\xc5\x01\x13\x14\n\x1a\n\x06\x04\x03\x03\t\x02\x02\
    \x12\x04\xc6\x01\x04*\"\n\x20optional\n\n\x0f\n\x07\x04\x03\x03\t\x02\
    \x02\x04\x12\x04\xc6\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\t\x02\x02\x06\
    \x12\x04\xc6\x01\r\x1e\n\x0f\n\x07\x04\x03\x03\t\x02\x02\x01\x12\x04\xc6\
    \x01\x1f%\n\x0f\n\x07\x04\x03\x03\t\x02\x02\x03\x12\x04\xc6\x01()\n\x0e\
    \n\x06\x04\x03\x03\t\x02\x03\x12\x04\xc7\x01\x04\x1f\n\x0f\n\x07\x04\x03\
    \x03\t\x02\x03\x04\x12\x04\xc7\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\t\x02\
    \x03\x06\x12\x04\xc7\x01\r\x10\n\x0f\n\x07\x04\x03\x03\t\x02\x03\x01\x12\
    \x04\xc7\x01\x11\x1a\n\x0f\n\x07\x04\x03\x03\t\x02\x03\x03\x12\x04\xc7\
    \x01\x1d\x1e\n\x0e\n\x04\x04\x03\x03\n\x12\x06\xca\x01\x02\xcf\x01\x03\n\
    \r\n\x05\x04\x03\x03\n\x01\x12\x04\xca\x01\n\x0f\n\x1a\n\x06\x04\x03\x03\
    \n\x02\0\x12\x04\xcb\x01\x04\x14\"\n\x20optional\n\n\x0f\n\x07\x04\x03\
    \x03\n\x02\0\x05\x12\x04\xcb\x01\x04\n\n\x0f\n\x07\x04\x03\x03\n\x02\0\
    \x01\x12\x04\xcb\x01\x0b\x0f\n\x0f\n\x07\x04\x03\x03\n\x02\0\x03\x12\x04\
    \xcb\x01\x12\x13\n\x0e\n\x06\x04\x03\x03\n\x02\x01\x12\x04\xcc\x01\x04\
    \x15\n\x0f\n\x07\x04\x03\x03\n\x02\x01\x06\x12\x04\xcc\x01\x04\x07\n\x0f\
    \n\x07\x04\x03\x03\n\x02\x01\x01\x12\x04\xcc\x01\x08\x10\n\x0f\n\x07\x04\
    \x03\x03\n\x02\x01\x03\x12\x04\xcc\x01\x13\x14\n\x1a\n\x06\x04\x03\x03\n\
    \x02\x02\x12\x04\xcd\x01\x04*\"\n\x20optional\n\n\x0f\n\x07\x04\x03\x03\
    \n\x02\x02\x04\x12\x04\xcd\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\n\x02\x02\
    \x06\x12\x04\xcd\x01\r\x1e\n\x0f\n\x07\x04\x03\x03\n\x02\x02\x01\x12\x04\
    \xcd\x01\x1f%\n\x0f\n\x07\x04\x03\x03\n\x02\x02\x03\x12\x04\xcd\x01()\n\
    \x0e\n\x06\x04\x03\x03\n\x02\x03\x12\x04\xce\x01\x04\x1f\n\x0f\n\x07\x04\
    \x03\x03\n\x02\x03\x04\x12\x04\xce\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\n\
    \x02\x03\x06\x12\x04\xce\x01\r\x10\n\x0f\n\x07\x04\x03\x03\n\x02\x03\x01\
    \x12\x04\xce\x01\x11\x1a\n\x0f\n\x07\x04\x03\x03\n\x02\x03\x03\x12\x04\
    \xce\x01\x1d\x1e\n\x0e\n\x04\x04\x03\x03\x0b\x12\x06\xd1\x01\x02\xdc\x01\
    \x03\n\r\n\x05\x04\x03\x03\x0b\x01\x12\x04\xd1\x01\n\x0e\n\x10\n\x06\x04\
    \x03\x03\x0b\x03\0\x12\x06\xd2\x01\x04\xd7\x01\x05\n\x0f\n\x07\x04\x03\
    \x03\x0b\x03\0\x01\x12\x04\xd2\x01\x0c\x10\n\x10\n\x08\x04\x03\x03\x0b\
    \x03\0\x02\0\x12\x04\xd3\x01\x06\x16\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\
    \0\x05\x12\x04\xd3\x01\x06\x0c\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\0\x01\
    \x12\x04\xd3\x01\r\x11\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\0\x03\x12\x04\
    \xd3\x01\x14\x15\n\x10\n\x08\x04\x03\x03\x0b\x03\0\x02\x01\x12\x04\xd4\
    \x01\x06\x17\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x01\x06\x12\x04\xd4\x01\
    \x06\t\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x01\x01\x12\x04\xd4\x01\n\x12\
    \n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x01\x03\x12\x04\xd4\x01\x15\x16\n\"\
    \n\x08\x04\x03\x03\x0b\x03\0\x02\x02\x12\x04\xd5\x01\x06\x16\"\x10\x20op\
    tional;\x20Expr\n\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x02\x05\x12\x04\
    \xd5\x01\x06\x0b\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x02\x01\x12\x04\xd5\
    \x01\x0c\x11\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x02\x03\x12\x04\xd5\x01\
    \x14\x15\n\x10\n\x08\x04\x03\x03\x0b\x03\0\x02\x03\x12\x04\xd6\x01\x06\
    \x18\n\x11\n\t\x04\x03\x03\x0b\x03\0\x02\x03\x06\x12\x04\xd6\x01\x06\t\n\
    \x11\n\t\x04\x03\x03\x0b\x03\0\x02\x03\x01\x12\x04\xd6\x01\n\x13\n\x11\n\
    \t\x04\x03\x03\x0b\x03\0\x02\x03\x03\x12\x04\xd6\x01\x16\x17\n\x1a\n\x06\
    \x04\x03\x03\x0b\x02\0\x12\x04\xd9\x01\x04\x14\"\n\x20optional\n\n\x0f\n\
    \x07\x04\x03\x03\x0b\x02\0\x05\x12\x04\xd9\x01\x04\n\n\x0f\n\x07\x04\x03\
    \x03\x0b\x02\0\x01\x12\x04\xd9\x01\x0b\x0f\n\x0f\n\x07\x04\x03\x03\x0b\
    \x02\0\x03\x12\x04\xd9\x01\x12\x13\n\x0e\n\x06\x04\x03\x03\x0b\x02\x01\
    \x12\x04\xda\x01\x04\x15\n\x0f\n\x07\x04\x03\x03\x0b\x02\x01\x06\x12\x04\
    \xda\x01\x04\x07\n\x0f\n\x07\x04\x03\x03\x0b\x02\x01\x01\x12\x04\xda\x01\
    \x08\x10\n\x0f\n\x07\x04\x03\x03\x0b\x02\x01\x03\x12\x04\xda\x01\x13\x14\
    \n\x1a\n\x06\x04\x03\x03\x0b\x02\x02\x12\x04\xdb\x01\x04\x1d\"\n\x20opti\
    onal\n\n\x0f\n\x07\x04\x03\x03\x0b\x02\x02\x04\x12\x04\xdb\x01\x04\x0c\n\
    \x0f\n\x07\x04\x03\x03\x0b\x02\x02\x06\x12\x04\xdb\x01\r\x11\n\x0f\n\x07\
    \x04\x03\x03\x0b\x02\x02\x01\x12\x04\xdb\x01\x12\x18\n\x0f\n\x07\x04\x03\
    \x03\x0b\x02\x02\x03\x12\x04\xdb\x01\x1b\x1c\n\x0e\n\x04\x04\x03\x08\0\
    \x12\x06\xde\x01\x02\xec\x01\x03\n\r\n\x05\x04\x03\x08\0\x01\x12\x04\xde\
    \x01\x08\t\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xdf\x01\x04\x12\n\r\n\x05\
    \x04\x03\x02\0\x06\x12\x04\xdf\x01\x04\x08\n\r\n\x05\x04\x03\x02\0\x01\
    \x12\x04\xdf\x01\t\r\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xdf\x01\x10\x11\
    \n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xe0\x01\x04\x12\n\r\n\x05\x04\x03\
    \x02\x01\x06\x12\x04\xe0\x01\x04\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\
    \x04\xe0\x01\t\r\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xe0\x01\x10\x11\n\
    \x0c\n\x04\x04\x03\x02\x02\x12\x04\xe1\x01\x04\x14\n\r\n\x05\x04\x03\x02\
    \x02\x06\x12\x04\xe1\x01\x04\t\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xe1\
    \x01\n\x0f\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xe1\x01\x12\x13\n\x0c\n\
    \x04\x04\x03\x02\x03\x12\x04\xe2\x01\x04\x10\n\r\n\x05\x04\x03\x02\x03\
    \x06\x12\x04\xe2\x01\x04\x07\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xe2\
    \x01\x08\x0b\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xe2\x01\x0e\x0f\n\x0c\
    \n\x04\x04\x03\x02\x04\x12\x04\xe3\x01\x04\x12\n\r\n\x05\x04\x03\x02\x04\
    \x06\x12\x04\xe3\x01\x04\x08\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xe3\
    \x01\t\r\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xe3\x01\x10\x11\n\x0c\n\
    \x04\x04\x03\x02\x05\x12\x04\xe4\x01\x04\x14\n\r\n\x05\x04\x03\x02\x05\
    \x06\x12\x04\xe4\x01\x04\t\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\xe4\x01\
    \n\x0f\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\xe4\x01\x12\x13\n\x0c\n\x04\
    \x04\x03\x02\x06\x12\x04\xe5\x01\x04\x16\n\r\n\x05\x04\x03\x02\x06\x06\
    \x12\x04\xe5\x01\x04\n\n\r\n\x05\x04\x03\x02\x06\x01\x12\x04\xe5\x01\x0b\
    \x11\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xe5\x01\x14\x15\n\x0c\n\x04\
    \x04\x03\x02\x07\x12\x04\xe6\x01\x04\x16\n\r\n\x05\x04\x03\x02\x07\x06\
    \x12\x04\xe6\x01\x04\n\n\r\n\x05\x04\x03\x02\x07\x01\x12\x04\xe6\x01\x0b\
    \x11\n\r\n\x05\x04\x03\x02\x07\x03\x12\x04\xe6\x01\x14\x15\n\x0c\n\x04\
    \x04\x03\x02\x08\x12\x04\xe7\x01\x04\x1a\n\r\n\x05\x04\x03\x02\x08\x06\
    \x12\x04\xe7\x01\x04\x0c\n\r\n\x05\x04\x03\x02\x08\x01\x12\x04\xe7\x01\r\
    \x15\n\r\n\x05\x04\x03\x02\x08\x03\x12\x04\xe7\x01\x18\x19\n\x0c\n\x04\
    \x04\x03\x02\t\x12\x04\xe8\x01\x04\x17\n\r\n\x05\x04\x03\x02\t\x06\x12\
    \x04\xe8\x01\x04\n\n\r\n\x05\x04\x03\x02\t\x01\x12\x04\xe8\x01\x0b\x11\n\
    \r\n\x05\x04\x03\x02\t\x03\x12\x04\xe8\x01\x14\x16\n\x0c\n\x04\x04\x03\
    \x02\n\x12\x04\xe9\x01\x04\x15\n\r\n\x05\x04\x03\x02\n\x06\x12\x04\xe9\
    \x01\x04\t\n\r\n\x05\x04\x03\x02\n\x01\x12\x04\xe9\x01\n\x0f\n\r\n\x05\
    \x04\x03\x02\n\x03\x12\x04\xe9\x01\x12\x14\n\x0c\n\x04\x04\x03\x02\x0b\
    \x12\x04\xea\x01\x04\x13\n\r\n\x05\x04\x03\x02\x0b\x06\x12\x04\xea\x01\
    \x04\x08\n\r\n\x05\x04\x03\x02\x0b\x01\x12\x04\xea\x01\t\r\n\r\n\x05\x04\
    \x03\x02\x0b\x03\x12\x04\xea\x01\x10\x12\n\x0c\n\x04\x04\x03\x02\x0c\x12\
    \x04\xeb\x01\x04\x1d\n\r\n\x05\x04\x03\x02\x0c\x05\x12\x04\xeb\x01\x04\n\
    \n\r\n\x05\x04\x03\x02\x0c\x01\x12\x04\xeb\x01\x0b\x17\n\r\n\x05\x04\x03\
    \x02\x0c\x03\x12\x04\xeb\x01\x1a\x1c\n\x0c\n\x02\x05\0\x12\x06\xef\x01\0\
    \xf2\x01\x01\n\x0b\n\x03\x05\0\x01\x12\x04\xef\x01\x05\x12\n\x0c\n\x04\
    \x05\0\x02\0\x12\x04\xf0\x01\x02\x0c\n\r\n\x05\x05\0\x02\0\x01\x12\x04\
    \xf0\x01\x02\x07\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xf0\x01\n\x0b\n\x0c\n\
    \x04\x05\0\x02\x01\x12\x04\xf1\x01\x02\x0f\n\r\n\x05\x05\0\x02\x01\x01\
    \x12\x04\xf1\x01\x02\n\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xf1\x01\r\x0e\
    \n\x0c\n\x02\x04\x04\x12\x06\xf4\x01\0\x86\x02\x01\n\x0b\n\x03\x04\x04\
    \x01\x12\x04\xf4\x01\x08\x19\n9\n\x04\x04\x04\x03\0\x12\x06\xf5\x01\x02\
    \xfb\x01\x03\")\x20either\x20type\x20specifier\x20or\x20type\x20qualifie\
    r\n\n\r\n\x05\x04\x04\x03\0\x01\x12\x04\xf5\x01\n\x0e\n\x10\n\x06\x04\
    \x04\x03\0\x08\0\x12\x06\xf6\x01\x04\xf9\x01\x05\n\x0f\n\x07\x04\x04\x03\
    \0\x08\0\x01\x12\x04\xf6\x01\n\x0e\n\x0e\n\x06\x04\x04\x03\0\x02\0\x12\
    \x04\xf7\x01\x06\x1b\n\x0f\n\x07\x04\x04\x03\0\x02\0\x06\x12\x04\xf7\x01\
    \x06\x13\n\x0f\n\x07\x04\x04\x03\0\x02\0\x01\x12\x04\xf7\x01\x14\x16\n\
    \x0f\n\x07\x04\x04\x03\0\x02\0\x03\x12\x04\xf7\x01\x19\x1a\n\x0e\n\x06\
    \x04\x04\x03\0\x02\x01\x12\x04\xf8\x01\x06\x1b\n\x0f\n\x07\x04\x04\x03\0\
    \x02\x01\x06\x12\x04\xf8\x01\x06\x13\n\x0f\n\x07\x04\x04\x03\0\x02\x01\
    \x01\x12\x04\xf8\x01\x14\x16\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x03\x12\
    \x04\xf8\x01\x19\x1a\n\x0e\n\x06\x04\x04\x03\0\x02\x02\x12\x04\xfa\x01\
    \x04\x10\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x06\x12\x04\xfa\x01\x04\x07\n\
    \x0f\n\x07\x04\x04\x03\0\x02\x02\x01\x12\x04\xfa\x01\x08\x0b\n\x0f\n\x07\
    \x04\x04\x03\0\x02\x02\x03\x12\x04\xfa\x01\x0e\x0f\n\x0e\n\x04\x04\x04\
    \x03\x01\x12\x06\xfd\x01\x02\x82\x02\x03\n\r\n\x05\x04\x04\x03\x01\x01\
    \x12\x04\xfd\x01\n\x0e\n\x1a\n\x06\x04\x04\x03\x01\x02\0\x12\x04\xfe\x01\
    \x04\x15\"\n\x20optional\n\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x06\x12\x04\
    \xfe\x01\x04\x0e\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x01\x12\x04\xfe\x01\
    \x0f\x10\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x03\x12\x04\xfe\x01\x13\x14\n\
    \x0e\n\x06\x04\x04\x03\x01\x02\x01\x12\x04\xff\x01\x04\x12\n\x0f\n\x07\
    \x04\x04\x03\x01\x02\x01\x06\x12\x04\xff\x01\x04\x07\n\x0f\n\x07\x04\x04\
    \x03\x01\x02\x01\x01\x12\x04\xff\x01\x08\r\n\x0f\n\x07\x04\x04\x03\x01\
    \x02\x01\x03\x12\x04\xff\x01\x10\x11\n\x20\n\x06\x04\x04\x03\x01\x02\x02\
    \x12\x04\x80\x02\x04\x10\"\x10\x20optional;\x20Expr\n\n\x0f\n\x07\x04\
    \x04\x03\x01\x02\x02\x05\x12\x04\x80\x02\x04\t\n\x0f\n\x07\x04\x04\x03\
    \x01\x02\x02\x01\x12\x04\x80\x02\n\x0b\n\x0f\n\x07\x04\x04\x03\x01\x02\
    \x02\x03\x12\x04\x80\x02\x0e\x0f\n\x0e\n\x06\x04\x04\x03\x01\x02\x03\x12\
    \x04\x81\x02\x04\x12\n\x0f\n\x07\x04\x04\x03\x01\x02\x03\x06\x12\x04\x81\
    \x02\x04\x07\n\x0f\n\x07\x04\x04\x03\x01\x02\x03\x01\x12\x04\x81\x02\x08\
    \r\n\x0f\n\x07\x04\x04\x03\x01\x02\x03\x03\x12\x04\x81\x02\x10\x11\n\x0c\
    \n\x04\x04\x04\x02\0\x12\x04\x84\x02\x02\x1b\n\r\n\x05\x04\x04\x02\0\x04\
    \x12\x04\x84\x02\x02\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x84\x02\x0b\
    \x0f\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x84\x02\x10\x16\n\r\n\x05\x04\
    \x04\x02\0\x03\x12\x04\x84\x02\x19\x1a\n\x0c\n\x04\x04\x04\x02\x01\x12\
    \x04\x85\x02\x02\x17\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\x85\x02\x02\n\
    \n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\x85\x02\x0b\x0f\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\x85\x02\x10\x12\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\x85\x02\x15\x16\n\x0c\n\x02\x04\x05\x12\x06\x88\x02\0\x8d\x02\x01\n\
    \x0b\n\x03\x04\x05\x01\x12\x04\x88\x02\x08\x12\n!\n\x04\x04\x05\x02\0\
    \x12\x04\x89\x02\x02\x14\"\x13\x20optional;\x20Pointer\n\n\r\n\x05\x04\
    \x05\x02\0\x05\x12\x04\x89\x02\x02\x07\n\r\n\x05\x04\x05\x02\0\x01\x12\
    \x04\x89\x02\x08\x0f\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x89\x02\x12\x13\
    \n\x0c\n\x04\x04\x05\x02\x01\x12\x04\x8a\x02\x02\x12\n\r\n\x05\x04\x05\
    \x02\x01\x06\x12\x04\x8a\x02\x02\x05\n\r\n\x05\x04\x05\x02\x01\x01\x12\
    \x04\x8a\x02\x06\r\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x8a\x02\x10\x11\
    \n\x20\n\x04\x04\x05\x02\x02\x12\x04\x8b\x02\x02\x13\"\x12\x20DirectDecl\
    arator\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x8b\x02\x02\x07\n\r\n\x05\
    \x04\x05\x02\x02\x01\x12\x04\x8b\x02\x08\x0e\n\r\n\x05\x04\x05\x02\x02\
    \x03\x12\x04\x8b\x02\x11\x12\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\x8c\x02\
    \x02\x11\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\x8c\x02\x02\x05\n\r\n\x05\
    \x04\x05\x02\x03\x01\x12\x04\x8c\x02\x06\x0c\n\r\n\x05\x04\x05\x02\x03\
    \x03\x12\x04\x8c\x02\x0f\x10\n\x0c\n\x02\x04\x06\x12\x06\x8f\x02\0\xb4\
    \x02\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x8f\x02\x08\x18\n\x0e\n\x04\x04\
    \x06\x03\0\x12\x06\x90\x02\x02\x93\x02\x03\n\r\n\x05\x04\x06\x03\0\x01\
    \x12\x04\x90\x02\n\x0c\n\x0e\n\x06\x04\x06\x03\0\x02\0\x12\x04\x91\x02\
    \x04\x12\n\x0f\n\x07\x04\x06\x03\0\x02\0\x05\x12\x04\x91\x02\x04\n\n\x0f\
    \n\x07\x04\x06\x03\0\x02\0\x01\x12\x04\x91\x02\x0b\r\n\x0f\n\x07\x04\x06\
    \x03\0\x02\0\x03\x12\x04\x91\x02\x10\x11\n\x0e\n\x06\x04\x06\x03\0\x02\
    \x01\x12\x04\x92\x02\x04\x10\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x06\x12\
    \x04\x92\x02\x04\x07\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x01\x12\x04\x92\
    \x02\x08\x0b\n\x0f\n\x07\x04\x06\x03\0\x02\x01\x03\x12\x04\x92\x02\x0e\
    \x0f\n\x0e\n\x04\x04\x06\x03\x01\x12\x06\x94\x02\x02\x97\x02\x03\n\r\n\
    \x05\x04\x06\x03\x01\x01\x12\x04\x94\x02\n\x14\n\x0e\n\x06\x04\x06\x03\
    \x01\x02\0\x12\x04\x95\x02\x04\"\n\x0f\n\x07\x04\x06\x03\x01\x02\0\x06\
    \x12\x04\x95\x02\x04\x1b\n\x0f\n\x07\x04\x06\x03\x01\x02\0\x01\x12\x04\
    \x95\x02\x1c\x1d\n\x0f\n\x07\x04\x06\x03\x01\x02\0\x03\x12\x04\x95\x02\
    \x20!\n\x0e\n\x06\x04\x06\x03\x01\x02\x01\x12\x04\x96\x02\x04\x10\n\x0f\
    \n\x07\x04\x06\x03\x01\x02\x01\x06\x12\x04\x96\x02\x04\x07\n\x0f\n\x07\
    \x04\x06\x03\x01\x02\x01\x01\x12\x04\x96\x02\x08\x0b\n\x0f\n\x07\x04\x06\
    \x03\x01\x02\x01\x03\x12\x04\x96\x02\x0e\x0f\n\x0e\n\x04\x04\x06\x03\x02\
    \x12\x06\x98\x02\x02\x9d\x02\x03\n\r\n\x05\x04\x06\x03\x02\x01\x12\x04\
    \x98\x02\n\x0f\n\"\n\x06\x04\x06\x03\x02\x02\0\x12\x04\x99\x02\x04\x15\"\
    \x12\x20DirectDeclarator\n\n\x0f\n\x07\x04\x06\x03\x02\x02\0\x05\x12\x04\
    \x99\x02\x04\t\n\x0f\n\x07\x04\x06\x03\x02\x02\0\x01\x12\x04\x99\x02\n\
    \x10\n\x0f\n\x07\x04\x06\x03\x02\x02\0\x03\x12\x04\x99\x02\x13\x14\n\x0e\
    \n\x06\x04\x06\x03\x02\x02\x01\x12\x04\x9a\x02\x04\x13\n\x0f\n\x07\x04\
    \x06\x03\x02\x02\x01\x06\x12\x04\x9a\x02\x04\x07\n\x0f\n\x07\x04\x06\x03\
    \x02\x02\x01\x01\x12\x04\x9a\x02\x08\x0e\n\x0f\n\x07\x04\x06\x03\x02\x02\
    \x01\x03\x12\x04\x9a\x02\x11\x12\n#\n\x06\x04\x06\x03\x02\x02\x02\x12\
    \x04\x9b\x02\x04\x17\"\x13\x20optional;\x20Pointer\n\n\x0f\n\x07\x04\x06\
    \x03\x02\x02\x02\x05\x12\x04\x9b\x02\x04\t\n\x0f\n\x07\x04\x06\x03\x02\
    \x02\x02\x01\x12\x04\x9b\x02\n\x12\n\x0f\n\x07\x04\x06\x03\x02\x02\x02\
    \x03\x12\x04\x9b\x02\x15\x16\n\x0e\n\x06\x04\x06\x03\x02\x02\x03\x12\x04\
    \x9c\x02\x04\x15\n\x0f\n\x07\x04\x06\x03\x02\x02\x03\x06\x12\x04\x9c\x02\
    \x04\x07\n\x0f\n\x07\x04\x06\x03\x02\x02\x03\x01\x12\x04\x9c\x02\x08\x10\
    \n\x0f\n\x07\x04\x06\x03\x02\x02\x03\x03\x12\x04\x9c\x02\x13\x14\n\x0e\n\
    \x04\x04\x06\x03\x03\x12\x06\x9e\x02\x02\xa5\x02\x03\n\r\n\x05\x04\x06\
    \x03\x03\x01\x12\x04\x9e\x02\n\x12\n\"\n\x06\x04\x06\x03\x03\x02\0\x12\
    \x04\x9f\x02\x04\x15\"\x12\x20DirectDeclarator\n\n\x0f\n\x07\x04\x06\x03\
    \x03\x02\0\x05\x12\x04\x9f\x02\x04\t\n\x0f\n\x07\x04\x06\x03\x03\x02\0\
    \x01\x12\x04\x9f\x02\n\x10\n\x0f\n\x07\x04\x06\x03\x03\x02\0\x03\x12\x04\
    \x9f\x02\x13\x14\n\x0e\n\x06\x04\x06\x03\x03\x02\x01\x12\x04\xa0\x02\x04\
    \x13\n\x0f\n\x07\x04\x06\x03\x03\x02\x01\x06\x12\x04\xa0\x02\x04\x07\n\
    \x0f\n\x07\x04\x06\x03\x03\x02\x01\x01\x12\x04\xa0\x02\x08\x0e\n\x0f\n\
    \x07\x04\x06\x03\x03\x02\x01\x03\x12\x04\xa0\x02\x11\x12\n\x0e\n\x06\x04\
    \x06\x03\x03\x02\x02\x12\x04\xa1\x02\x04&\n\x0f\n\x07\x04\x06\x03\x03\
    \x02\x02\x04\x12\x04\xa1\x02\x04\x0c\n\x0f\n\x07\x04\x06\x03\x03\x02\x02\
    \x06\x12\x04\xa1\x02\r\x1d\n\x0f\n\x07\x04\x06\x03\x03\x02\x02\x01\x12\
    \x04\xa1\x02\x1e!\n\x0f\n\x07\x04\x06\x03\x03\x02\x02\x03\x12\x04\xa1\
    \x02$%\n\x0e\n\x06\x04\x06\x03\x03\x02\x03\x12\x04\xa2\x02\x04\x1d\n\x0f\
    \n\x07\x04\x06\x03\x03\x02\x03\x04\x12\x04\xa2\x02\x04\x0c\n\x0f\n\x07\
    \x04\x06\x03\x03\x02\x03\x06\x12\x04\xa2\x02\r\x10\n\x0f\n\x07\x04\x06\
    \x03\x03\x02\x03\x01\x12\x04\xa2\x02\x11\x18\n\x0f\n\x07\x04\x06\x03\x03\
    \x02\x03\x03\x12\x04\xa2\x02\x1b\x1c\n\x0e\n\x06\x04\x06\x03\x03\x02\x04\
    \x12\x04\xa3\x02\x04\x1a\n\x0f\n\x07\x04\x06\x03\x03\x02\x04\x05\x12\x04\
    \xa3\x02\x04\x08\n\x0f\n\x07\x04\x06\x03\x03\x02\x04\x01\x12\x04\xa3\x02\
    \t\x15\n\x0f\n\x07\x04\x06\x03\x03\x02\x04\x03\x12\x04\xa3\x02\x18\x19\n\
    \x0e\n\x06\x04\x06\x03\x03\x02\x05\x12\x04\xa4\x02\x04\x19\n\x0f\n\x07\
    \x04\x06\x03\x03\x02\x05\x06\x12\x04\xa4\x02\x04\x07\n\x0f\n\x07\x04\x06\
    \x03\x03\x02\x05\x01\x12\x04\xa4\x02\x08\x14\n\x0f\n\x07\x04\x06\x03\x03\
    \x02\x05\x03\x12\x04\xa4\x02\x17\x18\n\x0e\n\x04\x04\x06\x03\x04\x12\x06\
    \xa6\x02\x02\xab\x02\x03\n\r\n\x05\x04\x06\x03\x04\x01\x12\x04\xa6\x02\n\
    \x11\n\"\n\x06\x04\x06\x03\x04\x02\0\x12\x04\xa7\x02\x04\x15\"\x12\x20Di\
    rectDeclarator\n\n\x0f\n\x07\x04\x06\x03\x04\x02\0\x05\x12\x04\xa7\x02\
    \x04\t\n\x0f\n\x07\x04\x06\x03\x04\x02\0\x01\x12\x04\xa7\x02\n\x10\n\x0f\
    \n\x07\x04\x06\x03\x04\x02\0\x03\x12\x04\xa7\x02\x13\x14\n\x0e\n\x06\x04\
    \x06\x03\x04\x02\x01\x12\x04\xa8\x02\x04\x13\n\x0f\n\x07\x04\x06\x03\x04\
    \x02\x01\x06\x12\x04\xa8\x02\x04\x07\n\x0f\n\x07\x04\x06\x03\x04\x02\x01\
    \x01\x12\x04\xa8\x02\x08\x0e\n\x0f\n\x07\x04\x06\x03\x04\x02\x01\x03\x12\
    \x04\xa8\x02\x11\x12\n\x0e\n\x06\x04\x06\x03\x04\x02\x02\x12\x04\xa9\x02\
    \x04\x1c\n\x0f\n\x07\x04\x06\x03\x04\x02\x02\x04\x12\x04\xa9\x02\x04\x0c\
    \n\x0f\n\x07\x04\x06\x03\x04\x02\x02\x05\x12\x04\xa9\x02\r\x13\n\x0f\n\
    \x07\x04\x06\x03\x04\x02\x02\x01\x12\x04\xa9\x02\x14\x17\n\x0f\n\x07\x04\
    \x06\x03\x04\x02\x02\x03\x12\x04\xa9\x02\x1a\x1b\n\x0e\n\x06\x04\x06\x03\
    \x04\x02\x03\x12\x04\xaa\x02\x04\x1d\n\x0f\n\x07\x04\x06\x03\x04\x02\x03\
    \x04\x12\x04\xaa\x02\x04\x0c\n\x0f\n\x07\x04\x06\x03\x04\x02\x03\x06\x12\
    \x04\xaa\x02\r\x10\n\x0f\n\x07\x04\x06\x03\x04\x02\x03\x01\x12\x04\xaa\
    \x02\x11\x18\n\x0f\n\x07\x04\x06\x03\x04\x02\x03\x03\x12\x04\xaa\x02\x1b\
    \x1c\n\x0e\n\x04\x04\x06\x08\0\x12\x06\xad\x02\x02\xb3\x02\x03\n\r\n\x05\
    \x04\x06\x08\0\x01\x12\x04\xad\x02\x08\n\n\x0c\n\x04\x04\x06\x02\0\x12\
    \x04\xae\x02\x04\x0e\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xae\x02\x04\x06\
    \n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xae\x02\x07\t\n\r\n\x05\x04\x06\x02\
    \0\x03\x12\x04\xae\x02\x0c\r\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xaf\x02\
    \x04\x15\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xaf\x02\x04\x0e\n\r\n\x05\
    \x04\x06\x02\x01\x01\x12\x04\xaf\x02\x0f\x10\n\r\n\x05\x04\x06\x02\x01\
    \x03\x12\x04\xaf\x02\x13\x14\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xb0\x02\
    \x04\x14\n\r\n\x05\x04\x06\x02\x02\x06\x12\x04\xb0\x02\x04\t\n\r\n\x05\
    \x04\x06\x02\x02\x01\x12\x04\xb0\x02\n\x0f\n\r\n\x05\x04\x06\x02\x02\x03\
    \x12\x04\xb0\x02\x12\x13\n\x0c\n\x04\x04\x06\x02\x03\x12\x04\xb1\x02\x04\
    \x14\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\xb1\x02\x04\x0c\n\r\n\x05\x04\
    \x06\x02\x03\x01\x12\x04\xb1\x02\r\x0f\n\r\n\x05\x04\x06\x02\x03\x03\x12\
    \x04\xb1\x02\x12\x13\n\x0c\n\x04\x04\x06\x02\x04\x12\x04\xb2\x02\x04\x19\
    \n\r\n\x05\x04\x06\x02\x04\x06\x12\x04\xb2\x02\x04\x0b\n\r\n\x05\x04\x06\
    \x02\x04\x01\x12\x04\xb2\x02\x0c\x14\n\r\n\x05\x04\x06\x02\x04\x03\x12\
    \x04\xb2\x02\x17\x18\n\x0c\n\x02\x04\x07\x12\x06\xb6\x02\0\xbb\x02\x01\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xb6\x02\x08\x1a\n!\n\x04\x04\x07\x02\0\
    \x12\x04\xb7\x02\x02\x14\"\x13\x20optional;\x20Pointer\n\n\r\n\x05\x04\
    \x07\x02\0\x05\x12\x04\xb7\x02\x02\x07\n\r\n\x05\x04\x07\x02\0\x01\x12\
    \x04\xb7\x02\x08\x0f\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb7\x02\x12\x13\
    \n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xb8\x02\x02\x12\n\r\n\x05\x04\x07\
    \x02\x01\x06\x12\x04\xb8\x02\x02\x05\n\r\n\x05\x04\x07\x02\x01\x01\x12\
    \x04\xb8\x02\x06\r\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xb8\x02\x10\x11\
    \n2\n\x04\x04\x07\x02\x02\x12\x04\xb9\x02\x02\x14\"$\x20optional;\x20Dir\
    ectAbstractDeclarator\n\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xb9\x02\
    \x02\x07\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xb9\x02\x08\x0f\n\r\n\x05\
    \x04\x07\x02\x02\x03\x12\x04\xb9\x02\x12\x13\n\x0c\n\x04\x04\x07\x02\x03\
    \x12\x04\xba\x02\x02\x12\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\xba\x02\
    \x02\x05\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xba\x02\x06\r\n\r\n\x05\
    \x04\x07\x02\x03\x03\x12\x04\xba\x02\x10\x11\n\x0c\n\x02\x04\x08\x12\x06\
    \xbd\x02\0\xd6\x02\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xbd\x02\x08\x20\n\
    \x0e\n\x04\x04\x08\x03\0\x12\x06\xbe\x02\x02\xc1\x02\x03\n\r\n\x05\x04\
    \x08\x03\0\x01\x12\x04\xbe\x02\n\x10\n\x0e\n\x06\x04\x08\x03\0\x02\0\x12\
    \x04\xbf\x02\x04\x1e\n\x0f\n\x07\x04\x08\x03\0\x02\0\x06\x12\x04\xbf\x02\
    \x04\x16\n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\xbf\x02\x17\x19\n\
    \x0f\n\x07\x04\x08\x03\0\x02\0\x03\x12\x04\xbf\x02\x1c\x1d\n\x0e\n\x06\
    \x04\x08\x03\0\x02\x01\x12\x04\xc0\x02\x04\x13\n\x0f\n\x07\x04\x08\x03\0\
    \x02\x01\x06\x12\x04\xc0\x02\x04\x07\n\x0f\n\x07\x04\x08\x03\0\x02\x01\
    \x01\x12\x04\xc0\x02\x08\x0e\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\
    \x04\xc0\x02\x11\x12\n\x0e\n\x04\x04\x08\x03\x01\x12\x06\xc2\x02\x02\xc7\
    \x02\x03\n\r\n\x05\x04\x08\x03\x01\x01\x12\x04\xc2\x02\n\x0f\n4\n\x06\
    \x04\x08\x03\x01\x02\0\x12\x04\xc3\x02\x04\x16\"$\x20optional;\x20Direct\
    AbstractDeclarator\n\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x05\x12\x04\xc3\
    \x02\x04\t\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x01\x12\x04\xc3\x02\n\x11\n\
    \x0f\n\x07\x04\x08\x03\x01\x02\0\x03\x12\x04\xc3\x02\x14\x15\n\x0e\n\x06\
    \x04\x08\x03\x01\x02\x01\x12\x04\xc4\x02\x04\x14\n\x0f\n\x07\x04\x08\x03\
    \x01\x02\x01\x06\x12\x04\xc4\x02\x04\x07\n\x0f\n\x07\x04\x08\x03\x01\x02\
    \x01\x01\x12\x04\xc4\x02\x08\x0f\n\x0f\n\x07\x04\x08\x03\x01\x02\x01\x03\
    \x12\x04\xc4\x02\x12\x13\n\x20\n\x06\x04\x08\x03\x01\x02\x02\x12\x04\xc5\
    \x02\x04\x17\"\x10\x20optional;\x20Expr\n\n\x0f\n\x07\x04\x08\x03\x01\
    \x02\x02\x05\x12\x04\xc5\x02\x04\t\n\x0f\n\x07\x04\x08\x03\x01\x02\x02\
    \x01\x12\x04\xc5\x02\n\x12\n\x0f\n\x07\x04\x08\x03\x01\x02\x02\x03\x12\
    \x04\xc5\x02\x15\x16\n\x0e\n\x06\x04\x08\x03\x01\x02\x03\x12\x04\xc6\x02\
    \x04\x15\n\x0f\n\x07\x04\x08\x03\x01\x02\x03\x06\x12\x04\xc6\x02\x04\x07\
    \n\x0f\n\x07\x04\x08\x03\x01\x02\x03\x01\x12\x04\xc6\x02\x08\x10\n\x0f\n\
    \x07\x04\x08\x03\x01\x02\x03\x03\x12\x04\xc6\x02\x13\x14\n\x0e\n\x04\x04\
    \x08\x03\x02\x12\x06\xc8\x02\x02\xcf\x02\x03\n\r\n\x05\x04\x08\x03\x02\
    \x01\x12\x04\xc8\x02\n\x0e\n4\n\x06\x04\x08\x03\x02\x02\0\x12\x04\xc9\
    \x02\x04\x16\"$\x20optional;\x20DirectAbstractDeclarator\n\n\x0f\n\x07\
    \x04\x08\x03\x02\x02\0\x05\x12\x04\xc9\x02\x04\t\n\x0f\n\x07\x04\x08\x03\
    \x02\x02\0\x01\x12\x04\xc9\x02\n\x11\n\x0f\n\x07\x04\x08\x03\x02\x02\0\
    \x03\x12\x04\xc9\x02\x14\x15\n\x0e\n\x06\x04\x08\x03\x02\x02\x01\x12\x04\
    \xca\x02\x04\x14\n\x0f\n\x07\x04\x08\x03\x02\x02\x01\x06\x12\x04\xca\x02\
    \x04\x07\n\x0f\n\x07\x04\x08\x03\x02\x02\x01\x01\x12\x04\xca\x02\x08\x0f\
    \n\x0f\n\x07\x04\x08\x03\x02\x02\x01\x03\x12\x04\xca\x02\x12\x13\n\x1a\n\
    \x06\x04\x08\x03\x02\x02\x02\x12\x04\xcb\x02\x04&\"\n\x20optional\n\n\
    \x0f\n\x07\x04\x08\x03\x02\x02\x02\x04\x12\x04\xcb\x02\x04\x0c\n\x0f\n\
    \x07\x04\x08\x03\x02\x02\x02\x06\x12\x04\xcb\x02\r\x1d\n\x0f\n\x07\x04\
    \x08\x03\x02\x02\x02\x01\x12\x04\xcb\x02\x1e!\n\x0f\n\x07\x04\x08\x03\
    \x02\x02\x02\x03\x12\x04\xcb\x02$%\n\x0e\n\x06\x04\x08\x03\x02\x02\x03\
    \x12\x04\xcc\x02\x04\x1d\n\x0f\n\x07\x04\x08\x03\x02\x02\x03\x04\x12\x04\
    \xcc\x02\x04\x0c\n\x0f\n\x07\x04\x08\x03\x02\x02\x03\x06\x12\x04\xcc\x02\
    \r\x10\n\x0f\n\x07\x04\x08\x03\x02\x02\x03\x01\x12\x04\xcc\x02\x11\x18\n\
    \x0f\n\x07\x04\x08\x03\x02\x02\x03\x03\x12\x04\xcc\x02\x1b\x1c\n\x0e\n\
    \x06\x04\x08\x03\x02\x02\x04\x12\x04\xcd\x02\x04\x1a\n\x0f\n\x07\x04\x08\
    \x03\x02\x02\x04\x05\x12\x04\xcd\x02\x04\x08\n\x0f\n\x07\x04\x08\x03\x02\
    \x02\x04\x01\x12\x04\xcd\x02\t\x15\n\x0f\n\x07\x04\x08\x03\x02\x02\x04\
    \x03\x12\x04\xcd\x02\x18\x19\n\x0e\n\x06\x04\x08\x03\x02\x02\x05\x12\x04\
    \xce\x02\x04\x19\n\x0f\n\x07\x04\x08\x03\x02\x02\x05\x06\x12\x04\xce\x02\
    \x04\x07\n\x0f\n\x07\x04\x08\x03\x02\x02\x05\x01\x12\x04\xce\x02\x08\x14\
    \n\x0f\n\x07\x04\x08\x03\x02\x02\x05\x03\x12\x04\xce\x02\x17\x18\n\x0e\n\
    \x04\x04\x08\x08\0\x12\x06\xd1\x02\x02\xd5\x02\x03\n\r\n\x05\x04\x08\x08\
    \0\x01\x12\x04\xd1\x02\x08\x0b\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xd2\x02\
    \x04\x16\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xd2\x02\x04\n\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xd2\x02\x0b\x11\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xd2\x02\x14\x15\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xd3\x02\x04\x14\
    \n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xd3\x02\x04\t\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\xd3\x02\n\x0f\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\
    \xd3\x02\x12\x13\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\xd4\x02\x04\x12\n\r\
    \n\x05\x04\x08\x02\x02\x06\x12\x04\xd4\x02\x04\x08\n\r\n\x05\x04\x08\x02\
    \x02\x01\x12\x04\xd4\x02\t\r\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xd4\
    \x02\x10\x11\n\x0c\n\x02\x04\t\x12\x06\xd8\x02\0\xef\x02\x01\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xd8\x02\x08\x18\n\x0e\n\x04\x04\t\x03\0\x12\x06\xd9\
    \x02\x02\xde\x02\x03\n\r\n\x05\x04\t\x03\0\x01\x12\x04\xd9\x02\n\x0f\n\
    \x0e\n\x06\x04\t\x03\0\x02\0\x12\x04\xda\x02\x04*\n\x0f\n\x07\x04\t\x03\
    \0\x02\0\x04\x12\x04\xda\x02\x04\x0c\n\x0f\n\x07\x04\t\x03\0\x02\0\x06\
    \x12\x04\xda\x02\r!\n\x0f\n\x07\x04\t\x03\0\x02\0\x01\x12\x04\xda\x02\"%\
    \n\x0f\n\x07\x04\t\x03\0\x02\0\x03\x12\x04\xda\x02()\n\x0e\n\x06\x04\t\
    \x03\0\x02\x01\x12\x04\xdb\x02\x04\x1d\n\x0f\n\x07\x04\t\x03\0\x02\x01\
    \x04\x12\x04\xdb\x02\x04\x0c\n\x0f\n\x07\x04\t\x03\0\x02\x01\x06\x12\x04\
    \xdb\x02\r\x10\n\x0f\n\x07\x04\t\x03\0\x02\x01\x01\x12\x04\xdb\x02\x11\
    \x18\n\x0f\n\x07\x04\t\x03\0\x02\x01\x03\x12\x04\xdb\x02\x1b\x1c\n\x0e\n\
    \x06\x04\t\x03\0\x02\x02\x12\x04\xdc\x02\x04\x15\n\x0f\n\x07\x04\t\x03\0\
    \x02\x02\x06\x12\x04\xdc\x02\x04\x0e\n\x0f\n\x07\x04\t\x03\0\x02\x02\x01\
    \x12\x04\xdc\x02\x0f\x10\n\x0f\n\x07\x04\t\x03\0\x02\x02\x03\x12\x04\xdc\
    \x02\x13\x14\n\x0e\n\x06\x04\t\x03\0\x02\x03\x12\x04\xdd\x02\x04\x12\n\
    \x0f\n\x07\x04\t\x03\0\x02\x03\x06\x12\x04\xdd\x02\x04\x07\n\x0f\n\x07\
    \x04\t\x03\0\x02\x03\x01\x12\x04\xdd\x02\x08\r\n\x0f\n\x07\x04\t\x03\0\
    \x02\x03\x03\x12\x04\xdd\x02\x10\x11\n\x0e\n\x04\x04\t\x03\x01\x12\x06\
    \xdf\x02\x02\xe4\x02\x03\n\r\n\x05\x04\t\x03\x01\x01\x12\x04\xdf\x02\n\
    \x12\n\x0e\n\x06\x04\t\x03\x01\x02\0\x12\x04\xe0\x02\x04*\n\x0f\n\x07\
    \x04\t\x03\x01\x02\0\x04\x12\x04\xe0\x02\x04\x0c\n\x0f\n\x07\x04\t\x03\
    \x01\x02\0\x06\x12\x04\xe0\x02\r!\n\x0f\n\x07\x04\t\x03\x01\x02\0\x01\
    \x12\x04\xe0\x02\"%\n\x0f\n\x07\x04\t\x03\x01\x02\0\x03\x12\x04\xe0\x02(\
    )\n\x0e\n\x06\x04\t\x03\x01\x02\x01\x12\x04\xe1\x02\x04\x1d\n\x0f\n\x07\
    \x04\t\x03\x01\x02\x01\x04\x12\x04\xe1\x02\x04\x0c\n\x0f\n\x07\x04\t\x03\
    \x01\x02\x01\x06\x12\x04\xe1\x02\r\x10\n\x0f\n\x07\x04\t\x03\x01\x02\x01\
    \x01\x12\x04\xe1\x02\x11\x18\n\x0f\n\x07\x04\t\x03\x01\x02\x01\x03\x12\
    \x04\xe1\x02\x1b\x1c\n\x0e\n\x06\x04\t\x03\x01\x02\x02\x12\x04\xe2\x02\
    \x04\x1e\n\x0f\n\x07\x04\t\x03\x01\x02\x02\x06\x12\x04\xe2\x02\x04\x16\n\
    \x0f\n\x07\x04\t\x03\x01\x02\x02\x01\x12\x04\xe2\x02\x17\x19\n\x0f\n\x07\
    \x04\t\x03\x01\x02\x02\x03\x12\x04\xe2\x02\x1c\x1d\n\x0e\n\x06\x04\t\x03\
    \x01\x02\x03\x12\x04\xe3\x02\x04\x13\n\x0f\n\x07\x04\t\x03\x01\x02\x03\
    \x06\x12\x04\xe3\x02\x04\x07\n\x0f\n\x07\x04\t\x03\x01\x02\x03\x01\x12\
    \x04\xe3\x02\x08\x0e\n\x0f\n\x07\x04\t\x03\x01\x02\x03\x03\x12\x04\xe3\
    \x02\x11\x12\n\x0e\n\x04\x04\t\x03\x02\x12\x06\xe5\x02\x02\xe8\x02\x03\n\
    \r\n\x05\x04\t\x03\x02\x01\x12\x04\xe5\x02\n\x18\n\x0e\n\x06\x04\t\x03\
    \x02\x02\0\x12\x04\xe6\x02\x04*\n\x0f\n\x07\x04\t\x03\x02\x02\0\x04\x12\
    \x04\xe6\x02\x04\x0c\n\x0f\n\x07\x04\t\x03\x02\x02\0\x06\x12\x04\xe6\x02\
    \r!\n\x0f\n\x07\x04\t\x03\x02\x02\0\x01\x12\x04\xe6\x02\"%\n\x0f\n\x07\
    \x04\t\x03\x02\x02\0\x03\x12\x04\xe6\x02()\n\x0e\n\x06\x04\t\x03\x02\x02\
    \x01\x12\x04\xe7\x02\x04\x1d\n\x0f\n\x07\x04\t\x03\x02\x02\x01\x04\x12\
    \x04\xe7\x02\x04\x0c\n\x0f\n\x07\x04\t\x03\x02\x02\x01\x06\x12\x04\xe7\
    \x02\r\x10\n\x0f\n\x07\x04\t\x03\x02\x02\x01\x01\x12\x04\xe7\x02\x11\x18\
    \n\x0f\n\x07\x04\t\x03\x02\x02\x01\x03\x12\x04\xe7\x02\x1b\x1c\n\x0e\n\
    \x04\x04\t\x08\0\x12\x06\xea\x02\x02\xee\x02\x03\n\r\n\x05\x04\t\x08\0\
    \x01\x12\x04\xea\x02\x08\n\n\x0c\n\x04\x04\t\x02\0\x12\x04\xeb\x02\x04\
    \x13\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xeb\x02\x04\t\n\r\n\x05\x04\t\x02\
    \0\x01\x12\x04\xeb\x02\n\x0e\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xeb\x02\
    \x11\x12\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xec\x02\x04\x1b\n\r\n\x05\x04\
    \t\x02\x01\x06\x12\x04\xec\x02\x04\x0c\n\r\n\x05\x04\t\x02\x01\x01\x12\
    \x04\xec\x02\r\x16\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xec\x02\x19\x1a\n\
    \x0c\n\x04\x04\t\x02\x02\x12\x04\xed\x02\x04(\n\r\n\x05\x04\t\x02\x02\
    \x06\x12\x04\xed\x02\x04\x12\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xed\x02\
    \x13#\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xed\x02&'\n\x0c\n\x02\x04\n\
    \x12\x06\xf1\x02\0\xf8\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xf1\x02\x08\
    \x1c\n\x0e\n\x04\x04\n\x08\0\x12\x06\xf2\x02\x02\xf6\x02\x03\n\r\n\x05\
    \x04\n\x08\0\x01\x12\x04\xf2\x02\x08\x0c\n\x0c\n\x04\x04\n\x02\0\x12\x04\
    \xf3\x02\x04\"\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xf3\x02\x04\x19\n\r\n\
    \x05\x04\n\x02\0\x01\x12\x04\xf3\x02\x1a\x1d\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\xf3\x02\x20!\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xf4\x02\x04\x19\
    \n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xf4\x02\x04\x11\n\r\n\x05\x04\n\x02\
    \x01\x01\x12\x04\xf4\x02\x12\x14\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xf4\
    \x02\x17\x18\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xf5\x02\x04\x19\n\r\n\x05\
    \x04\n\x02\x02\x06\x12\x04\xf5\x02\x04\x11\n\r\n\x05\x04\n\x02\x02\x01\
    \x12\x04\xf5\x02\x12\x14\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xf5\x02\x17\
    \x18\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xf7\x02\x02\x0e\n\r\n\x05\x04\n\
    \x02\x03\x06\x12\x04\xf7\x02\x02\x05\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\
    \xf7\x02\x06\t\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xf7\x02\x0c\r\n\x0c\n\
    \x02\x05\x01\x12\x06\xfa\x02\0\x80\x03\x01\n\x0b\n\x03\x05\x01\x01\x12\
    \x04\xfa\x02\x05\x1a\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xfb\x02\x02\x0e\n\
    \r\n\x05\x05\x01\x02\0\x01\x12\x04\xfb\x02\x02\t\n\r\n\x05\x05\x01\x02\0\
    \x02\x12\x04\xfb\x02\x0c\r\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\xfc\x02\
    \x02\r\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xfc\x02\x02\x08\n\r\n\x05\
    \x05\x01\x02\x01\x02\x12\x04\xfc\x02\x0b\x0c\n\x0c\n\x04\x05\x01\x02\x02\
    \x12\x04\xfd\x02\x02\r\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xfd\x02\x02\
    \x08\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xfd\x02\x0b\x0c\n\x0c\n\x04\
    \x05\x01\x02\x03\x12\x04\xfe\x02\x02\x0b\n\r\n\x05\x05\x01\x02\x03\x01\
    \x12\x04\xfe\x02\x02\x06\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\xfe\x02\t\
    \n\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xff\x02\x02\x0f\n\r\n\x05\x05\x01\
    \x02\x04\x01\x12\x04\xff\x02\x02\n\n\r\n\x05\x05\x01\x02\x04\x02\x12\x04\
    \xff\x02\r\x0e\n\x0c\n\x02\x04\x0b\x12\x06\x82\x03\0\x87\x03\x01\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\x82\x03\x08\x0f\n\x0c\n\x04\x04\x0b\x02\0\x12\
    \x04\x83\x03\x02\x20\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x83\x03\x02\n\n\
    \r\n\x05\x04\x0b\x02\0\x06\x12\x04\x83\x03\x0b\x18\n\r\n\x05\x04\x0b\x02\
    \0\x01\x12\x04\x83\x03\x19\x1b\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x83\
    \x03\x1e\x1f\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x84\x03\x02\x1a\n\r\n\
    \x05\x04\x0b\x02\x01\x04\x12\x04\x84\x03\x02\n\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\x84\x03\x0b\x0e\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x84\
    \x03\x0f\x15\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x84\x03\x18\x19\n!\n\
    \x04\x04\x0b\x02\x02\x12\x04\x85\x03\x02\x14\"\x13\x20optional;\x20Point\
    er\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x85\x03\x02\x07\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\x85\x03\x08\x0f\n\r\n\x05\x04\x0b\x02\x02\x03\
    \x12\x04\x85\x03\x12\x13\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\x86\x03\x02\
    \x12\n\r\n\x05\x04\x0b\x02\x03\x06\x12\x04\x86\x03\x02\x05\n\r\n\x05\x04\
    \x0b\x02\x03\x01\x12\x04\x86\x03\x06\r\n\r\n\x05\x04\x0b\x02\x03\x03\x12\
    \x04\x86\x03\x10\x11\n\x0c\n\x02\x04\x0c\x12\x06\x89\x03\0\x97\x03\x01\n\
    \x0b\n\x03\x04\x0c\x01\x12\x04\x89\x03\x08\x13\n\x0e\n\x04\x04\x0c\x03\0\
    \x12\x06\x8a\x03\x02\x8d\x03\x03\n\r\n\x05\x04\x0c\x03\0\x01\x12\x04\x8a\
    \x03\n\x0e\n\x16\n\x06\x04\x0c\x03\0\x02\0\x12\x04\x8b\x03\x04\x10\"\x06\
    \x20Expr\n\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x04\x8b\x03\x04\t\n\
    \x0f\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x04\x8b\x03\n\x0b\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\0\x03\x12\x04\x8b\x03\x0e\x0f\n\x0e\n\x06\x04\x0c\x03\0\
    \x02\x01\x12\x04\x8c\x03\x04\x12\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x06\
    \x12\x04\x8c\x03\x04\x07\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x01\x12\x04\
    \x8c\x03\x08\r\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x03\x12\x04\x8c\x03\x10\
    \x11\n\x0e\n\x04\x04\x0c\x03\x01\x12\x06\x8e\x03\x02\x91\x03\x03\n\r\n\
    \x05\x04\x0c\x03\x01\x01\x12\x04\x8e\x03\n\x10\n\x1d\n\x06\x04\x0c\x03\
    \x01\x02\0\x12\x04\x8f\x03\x04\x1d\"\r\x20Initializer\n\n\x0f\n\x07\x04\
    \x0c\x03\x01\x02\0\x04\x12\x04\x8f\x03\x04\x0c\n\x0f\n\x07\x04\x0c\x03\
    \x01\x02\0\x05\x12\x04\x8f\x03\r\x12\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\
    \x01\x12\x04\x8f\x03\x13\x18\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x03\x12\
    \x04\x8f\x03\x1b\x1c\n\x0e\n\x06\x04\x0c\x03\x01\x02\x01\x12\x04\x90\x03\
    \x04\x1f\n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\x04\x12\x04\x90\x03\x04\x0c\
    \n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\x06\x12\x04\x90\x03\r\x10\n\x0f\n\
    \x07\x04\x0c\x03\x01\x02\x01\x01\x12\x04\x90\x03\x11\x1a\n\x0f\n\x07\x04\
    \x0c\x03\x01\x02\x01\x03\x12\x04\x90\x03\x1d\x1e\n\x0e\n\x04\x04\x0c\x08\
    \0\x12\x06\x93\x03\x02\x96\x03\x03\n\r\n\x05\x04\x0c\x08\0\x01\x12\x04\
    \x93\x03\x08\x0c\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x94\x03\x04\x12\n\r\n\
    \x05\x04\x0c\x02\0\x06\x12\x04\x94\x03\x04\x08\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\x94\x03\t\r\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x94\x03\x10\
    \x11\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x95\x03\x04\x16\n\r\n\x05\x04\
    \x0c\x02\x01\x06\x12\x04\x95\x03\x04\n\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\x95\x03\x0b\x11\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x95\x03\x14\
    \x15\n\x0c\n\x02\x04\r\x12\x06\x99\x03\0\xa4\x03\x01\n\x0b\n\x03\x04\r\
    \x01\x12\x04\x99\x03\x08\x13\n\x0e\n\x04\x04\r\x03\0\x12\x06\x9a\x03\x02\
    \x9f\x03\x03\n\r\n\x05\x04\r\x03\0\x01\x12\x04\x9a\x03\n\x0c\n\x0e\n\x06\
    \x04\r\x03\0\x02\0\x12\x04\x9b\x03\x04\x15\n\x0f\n\x07\x04\r\x03\0\x02\0\
    \x06\x12\x04\x9b\x03\x04\x0e\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\x04\
    \x9b\x03\x0f\x10\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\x9b\x03\x13\
    \x14\n\x0e\n\x06\x04\r\x03\0\x02\x01\x12\x04\x9c\x03\x04\x12\n\x0f\n\x07\
    \x04\r\x03\0\x02\x01\x06\x12\x04\x9c\x03\x04\x07\n\x0f\n\x07\x04\r\x03\0\
    \x02\x01\x01\x12\x04\x9c\x03\x08\r\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\
    \x12\x04\x9c\x03\x10\x11\n'\n\x06\x04\r\x03\0\x02\x02\x12\x04\x9d\x03\
    \x04\x17\"\x17\x20optional;\x20Initializer\n\n\x0f\n\x07\x04\r\x03\0\x02\
    \x02\x05\x12\x04\x9d\x03\x04\t\n\x0f\n\x07\x04\r\x03\0\x02\x02\x01\x12\
    \x04\x9d\x03\n\x12\n\x0f\n\x07\x04\r\x03\0\x02\x02\x03\x12\x04\x9d\x03\
    \x15\x16\n\x0e\n\x06\x04\r\x03\0\x02\x03\x12\x04\x9e\x03\x04\x15\n\x0f\n\
    \x07\x04\r\x03\0\x02\x03\x06\x12\x04\x9e\x03\x04\x07\n\x0f\n\x07\x04\r\
    \x03\0\x02\x03\x01\x12\x04\x9e\x03\x08\x10\n\x0f\n\x07\x04\r\x03\0\x02\
    \x03\x03\x12\x04\x9e\x03\x13\x14\n\x0c\n\x04\x04\r\x02\0\x12\x04\xa1\x03\
    \x02(\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xa1\x03\x02\n\n\r\n\x05\x04\r\
    \x02\0\x06\x12\x04\xa1\x03\x0b\x1f\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa1\
    \x03\x20#\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa1\x03&'\n\x0c\n\x04\x04\r\
    \x02\x01\x12\x04\xa2\x03\x02\x1b\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xa2\
    \x03\x02\n\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xa2\x03\x0b\x0e\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\xa2\x03\x0f\x16\n\r\n\x05\x04\r\x02\x01\x03\
    \x12\x04\xa2\x03\x19\x1a\n\x18\n\x04\x04\r\x02\x02\x12\x04\xa3\x03\x02\
    \x16\"\n\x20optional\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xa3\x03\x02\n\
    \n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xa3\x03\x0b\r\n\r\n\x05\x04\r\x02\
    \x02\x01\x12\x04\xa3\x03\x0e\x11\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xa3\
    \x03\x14\x15\n\x0c\n\x02\x04\x0e\x12\x06\xa6\x03\0\xaf\x03\x01\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\xa6\x03\x08\x13\n\x0c\n\x04\x04\x0e\x02\0\x12\
    \x04\xa7\x03\x02(\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xa7\x03\x02\n\n\r\
    \n\x05\x04\x0e\x02\0\x06\x12\x04\xa7\x03\x0b\x1f\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\xa7\x03\x20#\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xa7\x03&'\
    \n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xa8\x03\x02\x1b\n\r\n\x05\x04\x0e\
    \x02\x01\x04\x12\x04\xa8\x03\x02\n\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\
    \xa8\x03\x0b\x0e\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xa8\x03\x0f\x16\n\
    \r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa8\x03\x19\x1a\n\x0c\n\x04\x04\x0e\
    \x02\x02\x12\x04\xa9\x03\x02\x13\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\
    \xa9\x03\x02\x0c\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa9\x03\r\x0e\n\r\
    \n\x05\x04\x0e\x02\x02\x03\x12\x04\xa9\x03\x11\x12\n\x0c\n\x04\x04\x0e\
    \x02\x03\x12\x04\xaa\x03\x02\x10\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\
    \xaa\x03\x02\x05\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xaa\x03\x06\x0b\n\
    \r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xaa\x03\x0e\x0f\n\x18\n\x04\x04\x0e\
    \x02\x04\x12\x04\xab\x03\x02\x1f\"\n\x20optional\n\n\r\n\x05\x04\x0e\x02\
    \x04\x04\x12\x04\xab\x03\x02\n\n\r\n\x05\x04\x0e\x02\x04\x06\x12\x04\xab\
    \x03\x0b\x16\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xab\x03\x17\x1a\n\r\n\
    \x05\x04\x0e\x02\x04\x03\x12\x04\xab\x03\x1d\x1e\n\x0c\n\x04\x04\x0e\x02\
    \x05\x12\x04\xac\x03\x02\x1b\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xac\
    \x03\x02\n\n\r\n\x05\x04\x0e\x02\x05\x06\x12\x04\xac\x03\x0b\x0e\n\r\n\
    \x05\x04\x0e\x02\x05\x01\x12\x04\xac\x03\x0f\x16\n\r\n\x05\x04\x0e\x02\
    \x05\x03\x12\x04\xac\x03\x19\x1a\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\xad\
    \x03\x02\x1e\n\r\n\x05\x04\x0e\x02\x06\x06\x12\x04\xad\x03\x02\x14\n\r\n\
    \x05\x04\x0e\x02\x06\x01\x12\x04\xad\x03\x15\x19\n\r\n\x05\x04\x0e\x02\
    \x06\x03\x12\x04\xad\x03\x1c\x1d\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xae\
    \x03\x02\x13\n\r\n\x05\x04\x0e\x02\x07\x06\x12\x04\xae\x03\x02\x05\n\r\n\
    \x05\x04\x0e\x02\x07\x01\x12\x04\xae\x03\x06\x0e\n\r\n\x05\x04\x0e\x02\
    \x07\x03\x12\x04\xae\x03\x11\x12\n\x0c\n\x02\x04\x0f\x12\x06\xb1\x03\0\
    \x91\x04\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb1\x03\x08\x11\n\x0e\n\x04\
    \x04\x0f\x03\0\x12\x06\xb2\x03\x02\xb7\x03\x03\n\r\n\x05\x04\x0f\x03\0\
    \x01\x12\x04\xb2\x03\n\x12\n\x0e\n\x06\x04\x0f\x03\0\x02\0\x12\x04\xb3\
    \x03\x04!\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x04\x12\x04\xb3\x03\x04\x0c\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\0\x06\x12\x04\xb3\x03\r\x18\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\0\x01\x12\x04\xb3\x03\x19\x1c\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\0\x03\x12\x04\xb3\x03\x1f\x20\n\x0e\n\x06\x04\x0f\x03\0\x02\x01\x12\
    \x04\xb4\x03\x04\x1d\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x04\x12\x04\xb4\
    \x03\x04\x0c\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x06\x12\x04\xb4\x03\r\x10\
    \n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\x04\xb4\x03\x11\x18\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\xb4\x03\x1b\x1c\n\x1b\n\x06\x04\
    \x0f\x03\0\x02\x02\x12\x04\xb5\x03\x04\"\"\x0b\x20Statement\n\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\x02\x04\x12\x04\xb5\x03\x04\x0c\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x02\x05\x12\x04\xb5\x03\r\x12\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x02\x01\x12\x04\xb5\x03\x13\x1d\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\
    \x03\x12\x04\xb5\x03\x20!\n\x0e\n\x06\x04\x0f\x03\0\x02\x03\x12\x04\xb6\
    \x03\x04\x1f\n\x0f\n\x07\x04\x0f\x03\0\x02\x03\x04\x12\x04\xb6\x03\x04\
    \x0c\n\x0f\n\x07\x04\x0f\x03\0\x02\x03\x06\x12\x04\xb6\x03\r\x10\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\x03\x01\x12\x04\xb6\x03\x11\x1a\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x03\x03\x12\x04\xb6\x03\x1d\x1e\n\x0e\n\x04\x04\x0f\x03\
    \x01\x12\x06\xb8\x03\x02\xcf\x03\x03\n\r\n\x05\x04\x0f\x03\x01\x01\x12\
    \x04\xb8\x03\n\x11\n\x10\n\x06\x04\x0f\x03\x01\x03\0\x12\x06\xb9\x03\x04\
    \xbe\x03\x05\n\x0f\n\x07\x04\x0f\x03\x01\x03\0\x01\x12\x04\xb9\x03\x0c\
    \x0e\n\x10\n\x08\x04\x0f\x03\x01\x03\0\x02\0\x12\x04\xba\x03\x06\x14\n\
    \x11\n\t\x04\x0f\x03\x01\x03\0\x02\0\x05\x12\x04\xba\x03\x06\x0c\n\x11\n\
    \t\x04\x0f\x03\x01\x03\0\x02\0\x01\x12\x04\xba\x03\r\x0f\n\x11\n\t\x04\
    \x0f\x03\x01\x03\0\x02\0\x03\x12\x04\xba\x03\x12\x13\n\x10\n\x08\x04\x0f\
    \x03\x01\x03\0\x02\x01\x12\x04\xbb\x03\x06\x15\n\x11\n\t\x04\x0f\x03\x01\
    \x03\0\x02\x01\x06\x12\x04\xbb\x03\x06\t\n\x11\n\t\x04\x0f\x03\x01\x03\0\
    \x02\x01\x01\x12\x04\xbb\x03\n\x10\n\x11\n\t\x04\x0f\x03\x01\x03\0\x02\
    \x01\x03\x12\x04\xbb\x03\x13\x14\n\x1d\n\x08\x04\x0f\x03\x01\x03\0\x02\
    \x02\x12\x04\xbc\x03\x06\x19\"\x0b\x20Statement\n\n\x11\n\t\x04\x0f\x03\
    \x01\x03\0\x02\x02\x05\x12\x04\xbc\x03\x06\x0b\n\x11\n\t\x04\x0f\x03\x01\
    \x03\0\x02\x02\x01\x12\x04\xbc\x03\x0c\x14\n\x11\n\t\x04\x0f\x03\x01\x03\
    \0\x02\x02\x03\x12\x04\xbc\x03\x17\x18\n\x10\n\x08\x04\x0f\x03\x01\x03\0\
    \x02\x03\x12\x04\xbd\x03\x06\x17\n\x11\n\t\x04\x0f\x03\x01\x03\0\x02\x03\
    \x06\x12\x04\xbd\x03\x06\t\n\x11\n\t\x04\x0f\x03\x01\x03\0\x02\x03\x01\
    \x12\x04\xbd\x03\n\x12\n\x11\n\t\x04\x0f\x03\x01\x03\0\x02\x03\x03\x12\
    \x04\xbd\x03\x15\x16\n\x10\n\x06\x04\x0f\x03\x01\x03\x01\x12\x06\xbf\x03\
    \x04\xc4\x03\x05\n\x0f\n\x07\x04\x0f\x03\x01\x03\x01\x01\x12\x04\xbf\x03\
    \x0c\x10\n\x18\n\x08\x04\x0f\x03\x01\x03\x01\x02\0\x12\x04\xc0\x03\x06\
    \x16\"\x06\x20Expr\n\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\0\x05\x12\x04\
    \xc0\x03\x06\x0b\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\0\x01\x12\x04\xc0\
    \x03\x0c\x11\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\0\x03\x12\x04\xc0\x03\
    \x14\x15\n\x10\n\x08\x04\x0f\x03\x01\x03\x01\x02\x01\x12\x04\xc1\x03\x06\
    \x14\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x01\x06\x12\x04\xc1\x03\x06\t\
    \n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x01\x01\x12\x04\xc1\x03\n\x0f\n\
    \x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x01\x03\x12\x04\xc1\x03\x12\x13\n\
    \x1d\n\x08\x04\x0f\x03\x01\x03\x01\x02\x02\x12\x04\xc2\x03\x06\x19\"\x0b\
    \x20Statement\n\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x02\x05\x12\x04\
    \xc2\x03\x06\x0b\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x02\x01\x12\x04\
    \xc2\x03\x0c\x14\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x02\x03\x12\x04\
    \xc2\x03\x17\x18\n\x10\n\x08\x04\x0f\x03\x01\x03\x01\x02\x03\x12\x04\xc3\
    \x03\x06\x17\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x03\x06\x12\x04\xc3\
    \x03\x06\t\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x03\x01\x12\x04\xc3\x03\
    \n\x12\n\x11\n\t\x04\x0f\x03\x01\x03\x01\x02\x03\x03\x12\x04\xc3\x03\x15\
    \x16\n\x10\n\x06\x04\x0f\x03\x01\x03\x02\x12\x06\xc5\x03\x04\xc8\x03\x05\
    \n\x0f\n\x07\x04\x0f\x03\x01\x03\x02\x01\x12\x04\xc5\x03\x0c\x13\n\x1d\n\
    \x08\x04\x0f\x03\x01\x03\x02\x02\0\x12\x04\xc6\x03\x06\x19\"\x0b\x20Stat\
    ement\n\n\x11\n\t\x04\x0f\x03\x01\x03\x02\x02\0\x05\x12\x04\xc6\x03\x06\
    \x0b\n\x11\n\t\x04\x0f\x03\x01\x03\x02\x02\0\x01\x12\x04\xc6\x03\x0c\x14\
    \n\x11\n\t\x04\x0f\x03\x01\x03\x02\x02\0\x03\x12\x04\xc6\x03\x17\x18\n\
    \x10\n\x08\x04\x0f\x03\x01\x03\x02\x02\x01\x12\x04\xc7\x03\x06\x17\n\x11\
    \n\t\x04\x0f\x03\x01\x03\x02\x02\x01\x06\x12\x04\xc7\x03\x06\t\n\x11\n\t\
    \x04\x0f\x03\x01\x03\x02\x02\x01\x01\x12\x04\xc7\x03\n\x12\n\x11\n\t\x04\
    \x0f\x03\x01\x03\x02\x02\x01\x03\x12\x04\xc7\x03\x15\x16\n\x10\n\x06\x04\
    \x0f\x03\x01\x08\0\x12\x06\xca\x03\x04\xce\x03\x05\n\x0f\n\x07\x04\x0f\
    \x03\x01\x08\0\x01\x12\x04\xca\x03\n\x0b\n\x0e\n\x06\x04\x0f\x03\x01\x02\
    \0\x12\x04\xcb\x03\x06\x10\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x06\x12\x04\
    \xcb\x03\x06\x08\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x01\x12\x04\xcb\x03\t\
    \x0b\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x03\x12\x04\xcb\x03\x0e\x0f\n\x0e\
    \n\x06\x04\x0f\x03\x01\x02\x01\x12\x04\xcc\x03\x06\x16\n\x0f\n\x07\x04\
    \x0f\x03\x01\x02\x01\x06\x12\x04\xcc\x03\x06\n\n\x0f\n\x07\x04\x0f\x03\
    \x01\x02\x01\x01\x12\x04\xcc\x03\x0b\x11\n\x0f\n\x07\x04\x0f\x03\x01\x02\
    \x01\x03\x12\x04\xcc\x03\x14\x15\n\x0e\n\x06\x04\x0f\x03\x01\x02\x02\x12\
    \x04\xcd\x03\x06\x1c\n\x0f\n\x07\x04\x0f\x03\x01\x02\x02\x06\x12\x04\xcd\
    \x03\x06\r\n\x0f\n\x07\x04\x0f\x03\x01\x02\x02\x01\x12\x04\xcd\x03\x0e\
    \x17\n\x0f\n\x07\x04\x0f\x03\x01\x02\x02\x03\x12\x04\xcd\x03\x1a\x1b\n\
    \x0e\n\x04\x04\x0f\x03\x02\x12\x06\xd0\x03\x02\xd3\x03\x03\n\r\n\x05\x04\
    \x0f\x03\x02\x01\x12\x04\xd0\x03\n\x0e\n\x20\n\x06\x04\x0f\x03\x02\x02\0\
    \x12\x04\xd1\x03\x04\x14\"\x10\x20optional;\x20Expr\n\n\x0f\n\x07\x04\
    \x0f\x03\x02\x02\0\x05\x12\x04\xd1\x03\x04\t\n\x0f\n\x07\x04\x0f\x03\x02\
    \x02\0\x01\x12\x04\xd1\x03\n\x0f\n\x0f\n\x07\x04\x0f\x03\x02\x02\0\x03\
    \x12\x04\xd1\x03\x12\x13\n\x0e\n\x06\x04\x0f\x03\x02\x02\x01\x12\x04\xd2\
    \x03\x04\x12\n\x0f\n\x07\x04\x0f\x03\x02\x02\x01\x06\x12\x04\xd2\x03\x04\
    \x07\n\x0f\n\x07\x04\x0f\x03\x02\x02\x01\x01\x12\x04\xd2\x03\x08\r\n\x0f\
    \n\x07\x04\x0f\x03\x02\x02\x01\x03\x12\x04\xd2\x03\x10\x11\n\x0e\n\x04\
    \x04\x0f\x03\x03\x12\x06\xd4\x03\x02\xdb\x03\x03\n\r\n\x05\x04\x0f\x03\
    \x03\x01\x12\x04\xd4\x03\n\x0c\n\x16\n\x06\x04\x0f\x03\x03\x02\0\x12\x04\
    \xd5\x03\x04\x17\"\x06\x20Expr\n\n\x0f\n\x07\x04\x0f\x03\x03\x02\0\x05\
    \x12\x04\xd5\x03\x04\t\n\x0f\n\x07\x04\x0f\x03\x03\x02\0\x01\x12\x04\xd5\
    \x03\n\x12\n\x0f\n\x07\x04\x0f\x03\x03\x02\0\x03\x12\x04\xd5\x03\x15\x16\
    \n\x0e\n\x06\x04\x0f\x03\x03\x02\x01\x12\x04\xd6\x03\x04\x15\n\x0f\n\x07\
    \x04\x0f\x03\x03\x02\x01\x06\x12\x04\xd6\x03\x04\x07\n\x0f\n\x07\x04\x0f\
    \x03\x03\x02\x01\x01\x12\x04\xd6\x03\x08\x10\n\x0f\n\x07\x04\x0f\x03\x03\
    \x02\x01\x03\x12\x04\xd6\x03\x13\x14\n\x1b\n\x06\x04\x0f\x03\x03\x02\x02\
    \x12\x04\xd7\x03\x04\x17\"\x0b\x20Statement\n\n\x0f\n\x07\x04\x0f\x03\
    \x03\x02\x02\x05\x12\x04\xd7\x03\x04\t\n\x0f\n\x07\x04\x0f\x03\x03\x02\
    \x02\x01\x12\x04\xd7\x03\n\x12\n\x0f\n\x07\x04\x0f\x03\x03\x02\x02\x03\
    \x12\x04\xd7\x03\x15\x16\n\x0e\n\x06\x04\x0f\x03\x03\x02\x03\x12\x04\xd8\
    \x03\x04\x15\n\x0f\n\x07\x04\x0f\x03\x03\x02\x03\x06\x12\x04\xd8\x03\x04\
    \x07\n\x0f\n\x07\x04\x0f\x03\x03\x02\x03\x01\x12\x04\xd8\x03\x08\x10\n\
    \x0f\n\x07\x04\x0f\x03\x03\x02\x03\x03\x12\x04\xd8\x03\x13\x14\n%\n\x06\
    \x04\x0f\x03\x03\x02\x04\x12\x04\xd9\x03\x04\x17\"\x15\x20optional;\x20S\
    tatement\n\n\x0f\n\x07\x04\x0f\x03\x03\x02\x04\x05\x12\x04\xd9\x03\x04\t\
    \n\x0f\n\x07\x04\x0f\x03\x03\x02\x04\x01\x12\x04\xd9\x03\n\x12\n\x0f\n\
    \x07\x04\x0f\x03\x03\x02\x04\x03\x12\x04\xd9\x03\x15\x16\n\x0e\n\x06\x04\
    \x0f\x03\x03\x02\x05\x12\x04\xda\x03\x04\x15\n\x0f\n\x07\x04\x0f\x03\x03\
    \x02\x05\x06\x12\x04\xda\x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x03\x02\x05\
    \x01\x12\x04\xda\x03\x08\x10\n\x0f\n\x07\x04\x0f\x03\x03\x02\x05\x03\x12\
    \x04\xda\x03\x13\x14\n\x0e\n\x04\x04\x0f\x03\x04\x12\x06\xdc\x03\x02\xe1\
    \x03\x03\n\r\n\x05\x04\x0f\x03\x04\x01\x12\x04\xdc\x03\n\x10\n\x16\n\x06\
    \x04\x0f\x03\x04\x02\0\x12\x04\xdd\x03\x04\x14\"\x06\x20Expr\n\n\x0f\n\
    \x07\x04\x0f\x03\x04\x02\0\x05\x12\x04\xdd\x03\x04\t\n\x0f\n\x07\x04\x0f\
    \x03\x04\x02\0\x01\x12\x04\xdd\x03\n\x0f\n\x0f\n\x07\x04\x0f\x03\x04\x02\
    \0\x03\x12\x04\xdd\x03\x12\x13\n\x0e\n\x06\x04\x0f\x03\x04\x02\x01\x12\
    \x04\xde\x03\x04\x12\n\x0f\n\x07\x04\x0f\x03\x04\x02\x01\x06\x12\x04\xde\
    \x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x04\x02\x01\x01\x12\x04\xde\x03\x08\
    \r\n\x0f\n\x07\x04\x0f\x03\x04\x02\x01\x03\x12\x04\xde\x03\x10\x11\n\x1b\
    \n\x06\x04\x0f\x03\x04\x02\x02\x12\x04\xdf\x03\x04\x17\"\x0b\x20Statemen\
    t\n\n\x0f\n\x07\x04\x0f\x03\x04\x02\x02\x05\x12\x04\xdf\x03\x04\t\n\x0f\
    \n\x07\x04\x0f\x03\x04\x02\x02\x01\x12\x04\xdf\x03\n\x12\n\x0f\n\x07\x04\
    \x0f\x03\x04\x02\x02\x03\x12\x04\xdf\x03\x15\x16\n\x0e\n\x06\x04\x0f\x03\
    \x04\x02\x03\x12\x04\xe0\x03\x04\x15\n\x0f\n\x07\x04\x0f\x03\x04\x02\x03\
    \x06\x12\x04\xe0\x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x04\x02\x03\x01\x12\
    \x04\xe0\x03\x08\x10\n\x0f\n\x07\x04\x0f\x03\x04\x02\x03\x03\x12\x04\xe0\
    \x03\x13\x14\n\x0e\n\x04\x04\x0f\x03\x05\x12\x06\xe2\x03\x02\xe7\x03\x03\
    \n\r\n\x05\x04\x0f\x03\x05\x01\x12\x04\xe2\x03\n\x0f\n\x16\n\x06\x04\x0f\
    \x03\x05\x02\0\x12\x04\xe3\x03\x04\x14\"\x06\x20Expr\n\n\x0f\n\x07\x04\
    \x0f\x03\x05\x02\0\x05\x12\x04\xe3\x03\x04\t\n\x0f\n\x07\x04\x0f\x03\x05\
    \x02\0\x01\x12\x04\xe3\x03\n\x0f\n\x0f\n\x07\x04\x0f\x03\x05\x02\0\x03\
    \x12\x04\xe3\x03\x12\x13\n\x0e\n\x06\x04\x0f\x03\x05\x02\x01\x12\x04\xe4\
    \x03\x04\x12\n\x0f\n\x07\x04\x0f\x03\x05\x02\x01\x06\x12\x04\xe4\x03\x04\
    \x07\n\x0f\n\x07\x04\x0f\x03\x05\x02\x01\x01\x12\x04\xe4\x03\x08\r\n\x0f\
    \n\x07\x04\x0f\x03\x05\x02\x01\x03\x12\x04\xe4\x03\x10\x11\n\x1b\n\x06\
    \x04\x0f\x03\x05\x02\x02\x12\x04\xe5\x03\x04\x17\"\x0b\x20Statement\n\n\
    \x0f\n\x07\x04\x0f\x03\x05\x02\x02\x05\x12\x04\xe5\x03\x04\t\n\x0f\n\x07\
    \x04\x0f\x03\x05\x02\x02\x01\x12\x04\xe5\x03\n\x12\n\x0f\n\x07\x04\x0f\
    \x03\x05\x02\x02\x03\x12\x04\xe5\x03\x15\x16\n\x0e\n\x06\x04\x0f\x03\x05\
    \x02\x03\x12\x04\xe6\x03\x04\x15\n\x0f\n\x07\x04\x0f\x03\x05\x02\x03\x06\
    \x12\x04\xe6\x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x05\x02\x03\x01\x12\x04\
    \xe6\x03\x08\x10\n\x0f\n\x07\x04\x0f\x03\x05\x02\x03\x03\x12\x04\xe6\x03\
    \x13\x14\n\x0e\n\x04\x04\x0f\x03\x06\x12\x06\xe8\x03\x02\xed\x03\x03\n\r\
    \n\x05\x04\x0f\x03\x06\x01\x12\x04\xe8\x03\n\x11\n\x1b\n\x06\x04\x0f\x03\
    \x06\x02\0\x12\x04\xe9\x03\x04\x17\"\x0b\x20Statement\n\n\x0f\n\x07\x04\
    \x0f\x03\x06\x02\0\x05\x12\x04\xe9\x03\x04\t\n\x0f\n\x07\x04\x0f\x03\x06\
    \x02\0\x01\x12\x04\xe9\x03\n\x12\n\x0f\n\x07\x04\x0f\x03\x06\x02\0\x03\
    \x12\x04\xe9\x03\x15\x16\n\x0e\n\x06\x04\x0f\x03\x06\x02\x01\x12\x04\xea\
    \x03\x04\x15\n\x0f\n\x07\x04\x0f\x03\x06\x02\x01\x06\x12\x04\xea\x03\x04\
    \x07\n\x0f\n\x07\x04\x0f\x03\x06\x02\x01\x01\x12\x04\xea\x03\x08\x10\n\
    \x0f\n\x07\x04\x0f\x03\x06\x02\x01\x03\x12\x04\xea\x03\x13\x14\n\x16\n\
    \x06\x04\x0f\x03\x06\x02\x02\x12\x04\xeb\x03\x04\x14\"\x06\x20Expr\n\n\
    \x0f\n\x07\x04\x0f\x03\x06\x02\x02\x05\x12\x04\xeb\x03\x04\t\n\x0f\n\x07\
    \x04\x0f\x03\x06\x02\x02\x01\x12\x04\xeb\x03\n\x0f\n\x0f\n\x07\x04\x0f\
    \x03\x06\x02\x02\x03\x12\x04\xeb\x03\x12\x13\n\x0e\n\x06\x04\x0f\x03\x06\
    \x02\x03\x12\x04\xec\x03\x04\x12\n\x0f\n\x07\x04\x0f\x03\x06\x02\x03\x06\
    \x12\x04\xec\x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x06\x02\x03\x01\x12\x04\
    \xec\x03\x08\r\n\x0f\n\x07\x04\x0f\x03\x06\x02\x03\x03\x12\x04\xec\x03\
    \x10\x11\n\x0e\n\x04\x04\x0f\x03\x07\x12\x06\xee\x03\x02\xf7\x03\x03\n\r\
    \n\x05\x04\x0f\x03\x07\x01\x12\x04\xee\x03\n\r\n\x20\n\x06\x04\x0f\x03\
    \x07\x02\0\x12\x04\xef\x03\x04\x15\"\x10\x20optional;\x20Expr\n\n\x0f\n\
    \x07\x04\x0f\x03\x07\x02\0\x05\x12\x04\xef\x03\x04\t\n\x0f\n\x07\x04\x0f\
    \x03\x07\x02\0\x01\x12\x04\xef\x03\n\x10\n\x0f\n\x07\x04\x0f\x03\x07\x02\
    \0\x03\x12\x04\xef\x03\x13\x14\n\x0e\n\x06\x04\x0f\x03\x07\x02\x01\x12\
    \x04\xf0\x03\x04\x13\n\x0f\n\x07\x04\x0f\x03\x07\x02\x01\x06\x12\x04\xf0\
    \x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x07\x02\x01\x01\x12\x04\xf0\x03\x08\
    \x0e\n\x0f\n\x07\x04\x0f\x03\x07\x02\x01\x03\x12\x04\xf0\x03\x11\x12\n\
    \x20\n\x06\x04\x0f\x03\x07\x02\x02\x12\x04\xf1\x03\x04\x15\"\x10\x20opti\
    onal;\x20Expr\n\n\x0f\n\x07\x04\x0f\x03\x07\x02\x02\x05\x12\x04\xf1\x03\
    \x04\t\n\x0f\n\x07\x04\x0f\x03\x07\x02\x02\x01\x12\x04\xf1\x03\n\x10\n\
    \x0f\n\x07\x04\x0f\x03\x07\x02\x02\x03\x12\x04\xf1\x03\x13\x14\n\x0e\n\
    \x06\x04\x0f\x03\x07\x02\x03\x12\x04\xf2\x03\x04\x13\n\x0f\n\x07\x04\x0f\
    \x03\x07\x02\x03\x06\x12\x04\xf2\x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x07\
    \x02\x03\x01\x12\x04\xf2\x03\x08\x0e\n\x0f\n\x07\x04\x0f\x03\x07\x02\x03\
    \x03\x12\x04\xf2\x03\x11\x12\n\x20\n\x06\x04\x0f\x03\x07\x02\x04\x12\x04\
    \xf3\x03\x04\x15\"\x10\x20optional;\x20Expr\n\n\x0f\n\x07\x04\x0f\x03\
    \x07\x02\x04\x05\x12\x04\xf3\x03\x04\t\n\x0f\n\x07\x04\x0f\x03\x07\x02\
    \x04\x01\x12\x04\xf3\x03\n\x10\n\x0f\n\x07\x04\x0f\x03\x07\x02\x04\x03\
    \x12\x04\xf3\x03\x13\x14\n\x0e\n\x06\x04\x0f\x03\x07\x02\x05\x12\x04\xf4\
    \x03\x04\x13\n\x0f\n\x07\x04\x0f\x03\x07\x02\x05\x06\x12\x04\xf4\x03\x04\
    \x07\n\x0f\n\x07\x04\x0f\x03\x07\x02\x05\x01\x12\x04\xf4\x03\x08\x0e\n\
    \x0f\n\x07\x04\x0f\x03\x07\x02\x05\x03\x12\x04\xf4\x03\x11\x12\n\x1b\n\
    \x06\x04\x0f\x03\x07\x02\x06\x12\x04\xf5\x03\x04\x17\"\x0b\x20Statement\
    \n\n\x0f\n\x07\x04\x0f\x03\x07\x02\x06\x05\x12\x04\xf5\x03\x04\t\n\x0f\n\
    \x07\x04\x0f\x03\x07\x02\x06\x01\x12\x04\xf5\x03\n\x12\n\x0f\n\x07\x04\
    \x0f\x03\x07\x02\x06\x03\x12\x04\xf5\x03\x15\x16\n\x0e\n\x06\x04\x0f\x03\
    \x07\x02\x07\x12\x04\xf6\x03\x04\x15\n\x0f\n\x07\x04\x0f\x03\x07\x02\x07\
    \x06\x12\x04\xf6\x03\x04\x07\n\x0f\n\x07\x04\x0f\x03\x07\x02\x07\x01\x12\
    \x04\xf6\x03\x08\x10\n\x0f\n\x07\x04\x0f\x03\x07\x02\x07\x03\x12\x04\xf6\
    \x03\x13\x14\n\x0e\n\x04\x04\x0f\x03\x08\x12\x06\xf8\x03\x02\xfb\x03\x03\
    \n\r\n\x05\x04\x0f\x03\x08\x01\x12\x04\xf8\x03\n\x0e\n\x0e\n\x06\x04\x0f\
    \x03\x08\x02\0\x12\x04\xf9\x03\x04\x12\n\x0f\n\x07\x04\x0f\x03\x08\x02\0\
    \x05\x12\x04\xf9\x03\x04\n\n\x0f\n\x07\x04\x0f\x03\x08\x02\0\x01\x12\x04\
    \xf9\x03\x0b\r\n\x0f\n\x07\x04\x0f\x03\x08\x02\0\x03\x12\x04\xf9\x03\x10\
    \x11\n\x0e\n\x06\x04\x0f\x03\x08\x02\x01\x12\x04\xfa\x03\x04\x13\n\x0f\n\
    \x07\x04\x0f\x03\x08\x02\x01\x06\x12\x04\xfa\x03\x04\x07\n\x0f\n\x07\x04\
    \x0f\x03\x08\x02\x01\x01\x12\x04\xfa\x03\x08\x0e\n\x0f\n\x07\x04\x0f\x03\
    \x08\x02\x01\x03\x12\x04\xfa\x03\x11\x12\n\x0c\n\x04\x04\x0f\x03\t\x12\
    \x04\xfc\x03\x02\x15\n\r\n\x05\x04\x0f\x03\t\x01\x12\x04\xfc\x03\n\x12\n\
    \x0c\n\x04\x04\x0f\x03\n\x12\x04\xfd\x03\x02\x12\n\r\n\x05\x04\x0f\x03\n\
    \x01\x12\x04\xfd\x03\n\x0f\n\x0e\n\x04\x04\x0f\x03\x0b\x12\x06\xfe\x03\
    \x02\x81\x04\x03\n\r\n\x05\x04\x0f\x03\x0b\x01\x12\x04\xfe\x03\n\x10\n\
    \x20\n\x06\x04\x0f\x03\x0b\x02\0\x12\x04\xff\x03\x04\x14\"\x10\x20option\
    al;\x20Expr\n\n\x0f\n\x07\x04\x0f\x03\x0b\x02\0\x05\x12\x04\xff\x03\x04\
    \t\n\x0f\n\x07\x04\x0f\x03\x0b\x02\0\x01\x12\x04\xff\x03\n\x0f\n\x0f\n\
    \x07\x04\x0f\x03\x0b\x02\0\x03\x12\x04\xff\x03\x12\x13\n\x0e\n\x06\x04\
    \x0f\x03\x0b\x02\x01\x12\x04\x80\x04\x04\x12\n\x0f\n\x07\x04\x0f\x03\x0b\
    \x02\x01\x06\x12\x04\x80\x04\x04\x07\n\x0f\n\x07\x04\x0f\x03\x0b\x02\x01\
    \x01\x12\x04\x80\x04\x08\r\n\x0f\n\x07\x04\x0f\x03\x0b\x02\x01\x03\x12\
    \x04\x80\x04\x10\x11\n\x0e\n\x04\x04\x0f\x08\0\x12\x06\x83\x04\x02\x90\
    \x04\x03\n\r\n\x05\x04\x0f\x08\0\x01\x12\x04\x83\x04\x08\x0c\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\x84\x04\x04\x1a\n\r\n\x05\x04\x0f\x02\0\x06\x12\
    \x04\x84\x04\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x84\x04\r\x15\n\
    \r\n\x05\x04\x0f\x02\0\x03\x12\x04\x84\x04\x18\x19\n\x0c\n\x04\x04\x0f\
    \x02\x01\x12\x04\x85\x04\x04\x18\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\
    \x85\x04\x04\x0b\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x85\x04\x0c\x13\n\
    \r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x85\x04\x16\x17\n\x0c\n\x04\x04\x0f\
    \x02\x02\x12\x04\x86\x04\x04\x12\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\
    \x86\x04\x04\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x86\x04\t\r\n\r\n\
    \x05\x04\x0f\x02\x02\x03\x12\x04\x86\x04\x10\x11\n\x0c\n\x04\x04\x0f\x02\
    \x03\x12\x04\x87\x04\x04\x10\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\x87\
    \x04\x04\x06\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x87\x04\x07\x0b\n\r\n\
    \x05\x04\x0f\x02\x03\x03\x12\x04\x87\x04\x0e\x0f\n\x0c\n\x04\x04\x0f\x02\
    \x04\x12\x04\x88\x04\x04\x18\n\r\n\x05\x04\x0f\x02\x04\x06\x12\x04\x88\
    \x04\x04\n\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\x88\x04\x0b\x13\n\r\n\
    \x05\x04\x0f\x02\x04\x03\x12\x04\x88\x04\x16\x17\n\x0c\n\x04\x04\x0f\x02\
    \x05\x12\x04\x89\x04\x04\x16\n\r\n\x05\x04\x0f\x02\x05\x06\x12\x04\x89\
    \x04\x04\t\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x89\x04\n\x11\n\r\n\x05\
    \x04\x0f\x02\x05\x03\x12\x04\x89\x04\x14\x15\n\x0c\n\x04\x04\x0f\x02\x06\
    \x12\x04\x8a\x04\x04\x1b\n\r\n\x05\x04\x0f\x02\x06\x06\x12\x04\x8a\x04\
    \x04\x0b\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\x8a\x04\x0c\x16\n\r\n\x05\
    \x04\x0f\x02\x06\x03\x12\x04\x8a\x04\x19\x1a\n\x0c\n\x04\x04\x0f\x02\x07\
    \x12\x04\x8b\x04\x04\x12\n\r\n\x05\x04\x0f\x02\x07\x06\x12\x04\x8b\x04\
    \x04\x07\n\r\n\x05\x04\x0f\x02\x07\x01\x12\x04\x8b\x04\x08\r\n\r\n\x05\
    \x04\x0f\x02\x07\x03\x12\x04\x8b\x04\x10\x11\n\x0c\n\x04\x04\x0f\x02\x08\
    \x12\x04\x8c\x04\x04\x14\n\r\n\x05\x04\x0f\x02\x08\x06\x12\x04\x8c\x04\
    \x04\x08\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\x8c\x04\t\x0f\n\r\n\x05\
    \x04\x0f\x02\x08\x03\x12\x04\x8c\x04\x12\x13\n\x0c\n\x04\x04\x0f\x02\t\
    \x12\x04\x8d\x04\x04\x1d\n\r\n\x05\x04\x0f\x02\t\x06\x12\x04\x8d\x04\x04\
    \x0c\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\x8d\x04\r\x17\n\r\n\x05\x04\x0f\
    \x02\t\x03\x12\x04\x8d\x04\x1a\x1c\n\x0c\n\x04\x04\x0f\x02\n\x12\x04\x8e\
    \x04\x04\x17\n\r\n\x05\x04\x0f\x02\n\x06\x12\x04\x8e\x04\x04\t\n\r\n\x05\
    \x04\x0f\x02\n\x01\x12\x04\x8e\x04\n\x11\n\r\n\x05\x04\x0f\x02\n\x03\x12\
    \x04\x8e\x04\x14\x16\n\x0c\n\x04\x04\x0f\x02\x0b\x12\x04\x8f\x04\x04\x19\
    \n\r\n\x05\x04\x0f\x02\x0b\x06\x12\x04\x8f\x04\x04\n\n\r\n\x05\x04\x0f\
    \x02\x0b\x01\x12\x04\x8f\x04\x0b\x13\n\r\n\x05\x04\x0f\x02\x0b\x03\x12\
    \x04\x8f\x04\x16\x18\n\x0c\n\x02\x04\x10\x12\x06\x93\x04\0\x9e\x04\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\x93\x04\x08\x10\n9\n\x04\x04\x10\x03\0\
    \x12\x06\x94\x04\x02\x9a\x04\x03\")\x20either\x20type\x20specifier\x20or\
    \x20type\x20qualifier\n\n\r\n\x05\x04\x10\x03\0\x01\x12\x04\x94\x04\n\
    \x0e\n\x10\n\x06\x04\x10\x03\0\x08\0\x12\x06\x95\x04\x04\x98\x04\x05\n\
    \x0f\n\x07\x04\x10\x03\0\x08\0\x01\x12\x04\x95\x04\n\x0e\n\x0e\n\x06\x04\
    \x10\x03\0\x02\0\x12\x04\x96\x04\x06\x1b\n\x0f\n\x07\x04\x10\x03\0\x02\0\
    \x06\x12\x04\x96\x04\x06\x13\n\x0f\n\x07\x04\x10\x03\0\x02\0\x01\x12\x04\
    \x96\x04\x14\x16\n\x0f\n\x07\x04\x10\x03\0\x02\0\x03\x12\x04\x96\x04\x19\
    \x1a\n\x0e\n\x06\x04\x10\x03\0\x02\x01\x12\x04\x97\x04\x06\x1b\n\x0f\n\
    \x07\x04\x10\x03\0\x02\x01\x06\x12\x04\x97\x04\x06\x13\n\x0f\n\x07\x04\
    \x10\x03\0\x02\x01\x01\x12\x04\x97\x04\x14\x16\n\x0f\n\x07\x04\x10\x03\0\
    \x02\x01\x03\x12\x04\x97\x04\x19\x1a\n\x0e\n\x06\x04\x10\x03\0\x02\x02\
    \x12\x04\x99\x04\x04\x10\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x06\x12\x04\
    \x99\x04\x04\x07\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x01\x12\x04\x99\x04\
    \x08\x0b\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x03\x12\x04\x99\x04\x0e\x0f\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\x9b\x04\x02\x1b\n\r\n\x05\x04\x10\x02\0\
    \x04\x12\x04\x9b\x04\x02\n\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\x9b\x04\
    \x0b\x0f\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x9b\x04\x10\x16\n\r\n\x05\
    \x04\x10\x02\0\x03\x12\x04\x9b\x04\x19\x1a\n\x18\n\x04\x04\x10\x02\x01\
    \x12\x04\x9c\x04\x02\x1c\"\n\x20optional\n\n\r\n\x05\x04\x10\x02\x01\x06\
    \x12\x04\x9c\x04\x02\x14\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x9c\x04\
    \x15\x17\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9c\x04\x1a\x1b\n\x0c\n\
    \x04\x04\x10\x02\x02\x12\x04\x9d\x04\x02\x11\n\r\n\x05\x04\x10\x02\x02\
    \x06\x12\x04\x9d\x04\x02\x05\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\x9d\
    \x04\x06\x0c\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x9d\x04\x0f\x10\n\x0c\
    \n\x02\x04\x11\x12\x06\xa0\x04\0\xaf\x04\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xa0\x04\x08\x0b\n\x0e\n\x04\x04\x11\x03\0\x12\x06\xa1\x04\x02\xab\
    \x04\x03\n\r\n\x05\x04\x11\x03\0\x01\x12\x04\xa1\x04\n\x0f\n\x17\n\x06\
    \x04\x11\x03\0\x02\0\x12\x04\xa3\x04\x04\x19\x1a\x07\x20begin\n\n\x0f\n\
    \x07\x04\x11\x03\0\x02\0\x05\x12\x04\xa3\x04\x04\t\n\x0f\n\x07\x04\x11\
    \x03\0\x02\0\x01\x12\x04\xa3\x04\n\x14\n\x0f\n\x07\x04\x11\x03\0\x02\0\
    \x03\x12\x04\xa3\x04\x17\x18\n\x0e\n\x06\x04\x11\x03\0\x02\x01\x12\x04\
    \xa4\x04\x04\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\x04\xa4\x04\
    \x04\t\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\xa4\x04\n\x13\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x01\x03\x12\x04\xa4\x04\x16\x17\n\x20\n\x06\x04\
    \x11\x03\0\x02\x02\x12\x04\xa7\x04\x04\x17\x1a\x10\x20end\x20(optional)\
    \n\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x05\x12\x04\xa7\x04\x04\t\n\x0f\n\
    \x07\x04\x11\x03\0\x02\x02\x01\x12\x04\xa7\x04\n\x12\n\x0f\n\x07\x04\x11\
    \x03\0\x02\x02\x03\x12\x04\xa7\x04\x15\x16\n\x0e\n\x06\x04\x11\x03\0\x02\
    \x03\x12\x04\xa8\x04\x04\x16\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x05\x12\
    \x04\xa8\x04\x04\t\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x01\x12\x04\xa8\x04\
    \n\x11\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x03\x12\x04\xa8\x04\x14\x15\n\
    \x0e\n\x06\x04\x11\x03\0\x02\x04\x12\x04\xaa\x04\x04\x19\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x04\x05\x12\x04\xaa\x04\x04\n\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x04\x01\x12\x04\xaa\x04\x0b\x14\n\x0f\n\x07\x04\x11\x03\0\x02\x04\
    \x03\x12\x04\xaa\x04\x17\x18\n!\n\x04\x04\x11\x02\0\x12\x04\xae\x04\x02\
    \x1c\x1a\x13\x20[leaf,\x20...,\x20root]\n\n\r\n\x05\x04\x11\x02\0\x04\
    \x12\x04\xae\x04\x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xae\x04\x0b\
    \x10\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xae\x04\x11\x17\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xae\x04\x1a\x1bb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
