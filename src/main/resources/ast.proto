syntax = "proto3";

package c4.ast.proto;

// type TranslationUnit = Seq[L[ExternalDecl]]
message TranslationUnit {
  repeated ExternalDecl eds = 1;
  repeated Loc ed_locs = 2;

  // recursive data structures are impossible in protobuf. they will be unnested
  // and referrd to by indices.
  // valid indices start at 1 instead of 0.
  repeated Expr exprs = 3;
  repeated DirectDeclarator direct_declarators = 4;
  repeated DirectAbstractDeclarator direct_abstract_declarators = 5;
  repeated Pointer pointers = 6;
  repeated Initializer initializers = 7;
  repeated Statement statements = 8;
}

// type ExternalDecl = Either[L[FunctionDef], L[Declaration]]
message ExternalDecl {
  oneof ed {
    FunctionDef fd = 1;
    Declaration dl = 2;
  }
  Loc loc = 3;
}

message Expr {

  // one message for 8 literal types
  message Integer {
    enum Size {
      INT8 = 0;
      INT16 = 1;
      INT32 = 2;
      INT64 = 3;
    }
    int64 n = 1;
    Size size = 2;
    bool signed = 3;
  }

  message Cast {
    TypeName tp = 1;
    Loc tp_loc = 2;
    int32 e_idx = 3; // Expr
    Loc e_loc = 4;
  }

  message ArrSub {
    int32 arr_idx = 1; // Expr
    Loc arr_loc = 2;
    int32 sub_idx = 3; // Expr
    Loc sub_loc = 4;
  }

  message FuncCall {
    int32 fn_idx = 1; // Expr
    Loc fn_loc = 2;
    repeated int32 args = 3; // [Expr]
    repeated Loc arg_locs = 4;
  }

  message Dot {
    int32 e_idx = 1; // Expr
    Loc e_loc = 2;
    string field = 3;
    Loc field_loc = 4;
  }

  message Ptr {
    int32 e_idx = 1; // Expr
    Loc e_loc = 2;
    string field = 3;
    Loc field_loc = 4;
  }

  message SizeofVal {
    int32 e_idx = 1; // Expr
    Loc e_loc = 2;
  }

  message SizeofType {
    TypeName tp = 1;
    Loc tp_loc = 2;
  }

  message Unary {
    enum Op {
      PREFIX_INC = 0; // ++n
      PREFIX_DEC = 1; // --n
      POSTFIX_INC = 2; // n++
      POSTFIX_DEC = 3; // n--
      REF = 4; // &n
      DEREF = 5; // *n
      POS = 6; // +n
      NEG = 7; // -n
      BIT_NOT = 8; // ~n
      LOGIC_NOT = 9; // !n
    }

    int32 e_idx = 1; // Expr
    Loc e_loc = 2;
    Op op = 3;
    Loc op_loc = 4;
  }

  message Binary {
    enum Op {
      ASSIGN = 0; // a = b
      MUL_ASSIGN = 1; // a *= b
      DIV_ASSIGN = 2; // a /= b
      MOD_ASSIGN = 3; // a %= b
      ADD_ASSIGN = 4; // a += b
      SUB_ASSIGN = 5; // a -= b
      L_SHIFT_ASSIGN = 6; // a <<= b
      R_SHIFT_ASSIGN = 7; // a >>= b
      BINARY_AND_ASSIGN = 8; // a &= b
      XOR_ASSIGN = 9; // a ^= b
      BINARY_OR_ASSIGN = 10; // a |= b
      COMMA = 11; // a, b
      LOGIC_OR = 12; // a || b
      LOGIC_AND = 13; // a && b
      BIT_OR = 14; // a | b
      XOR = 15; // a ^ b
      BIT_AND = 16; // a & b
      EQ = 17; // a == b
      NEQ = 18; // a != b
      LESS = 19; // a < b
      GT = 20; // a > b
      LEQ = 21; // a <= b
      GEQ = 22; // a >= b
      L_SHIFT = 23; // a << b
      R_SHIFT = 24; // a >> b
      ADD = 25; // a + b
      SUB = 26; // a - b
      MUL = 27; // a * b
      DIV = 28; // a / b
      MOD = 29; // a % b
    }

    int32 e1_idx = 1; // Expr
    Loc e1_loc = 2;
    int32 e2_idx = 3; // Expr
    Loc e2_loc = 4;
    Op op = 5;
    Loc op_loc = 6;
  }

  message Ternary {
    int32 cond_idx = 1; // Expr
    Loc cond_loc = 2;
    int32 then_idx = 3; // Expr
    Loc then_loc = 4;
    int32 else_idx = 5; // Expr
    Loc else_loc = 6;
  }

  oneof e {
    string id = 1;
    Integer integer = 2;
    float float = 3;
    double double = 4;
    // ??? long_double = 5; // it's fine to treat 'long double' as 'double'.
    uint32 char = 6; // 1 byte
    uint32 wide_char = 7; // 2 bytes
    string string = 8;
    string wide_string = 9;
    Cast cast = 10;
    ArrSub arr_sub = 11;
    FuncCall func_call = 12;
    Dot dot = 13;
    Ptr ptr = 14;
    SizeofVal sizeof_val = 15;
    SizeofType sizeof_tp = 16;

    Unary unary = 17;
    Binary binary = 18;
    Ternary ternary = 19;
  }
}

message TypeSpecifier {
  message Void {}
  message Char {}
  message Short {}
  message Int {}
  message Long {}
  message Float {}
  message Double {}
  message Signed {}
  message Unsigned {}

  message Struct {
    string name = 1; // optional
    Loc name_loc = 2;
    repeated StructDeclaration bodies = 3; // optional
    repeated Loc body_locs = 4;
  }

  message Union {
    string name = 1; // optional
    Loc name_loc = 2;
    repeated StructDeclaration bodies = 3; // optional
    repeated Loc body_locs = 4;
  }

  message Enum {
    message Body {
      string name = 1;
      Loc name_loc = 2;
      int32 value = 3; // optional; Expr
      Loc value_loc = 4;
    }

    string name = 1; // optional
    Loc name_loc = 2;
    repeated Body bodies = 3; // optional
  }

  oneof s {
    Void void = 1;
    Char char = 2;
    Short short = 3;
    Int int = 4;
    Long long = 5;
    Float float = 6;
    Double double = 7;
    Signed signed = 8;
    Unsigned unsigned = 9;
    Struct struct = 10;
    Union union = 11;
    Enum enum = 12;
    string typedef_name = 13;
  }
}

enum TypeQualifier {
  CONST = 0;
  VOLATILE = 1;
}

message StructDeclaration {
  message SpQl { // either type specifier or type qualifier
    oneof elem {
      TypeSpecifier sp = 1;
      TypeQualifier ql = 2;
    }
    Loc loc = 3;
  }

  message Decl {
    Declarator d = 1; // optional
    Loc d_loc = 2;
    int32 e = 3; // optional; Expr
    Loc e_loc = 4;
  }

  repeated SpQl sp_qls = 1;
  repeated Decl ds = 2;
}

message Declarator {
  int32 ptr_idx = 1; // optional; Pointer
  Loc ptr_loc = 2;
  int32 dd_idx = 3; // DirectDeclarator
  Loc dd_loc = 4;
}

message DirectDeclarator {
  message Id {
    string id = 1;
    Loc loc = 2;
  }
  message Declarator {
    c4.ast.proto.Declarator d = 1;
    Loc loc = 2;
  }
  message Array {
    int32 dd_idx = 1; // DirectDeclarator
    Loc dd_loc = 2;
    int32 size_idx = 3; // optional; Pointer
    Loc size_loc = 4;
  }
  message FuncType {
    int32 dd_idx = 1; // DirectDeclarator
    Loc dd_loc = 2;
    repeated ParamDeclaration pds = 3;
    repeated Loc pd_locs = 4;
    bool has_ellipsis = 5;
    Loc ellipsis_loc = 6;
  }
  message IdsList {
    int32 dd_idx = 1; // DirectDeclarator
    Loc dd_loc = 2;
    repeated string ids = 3;
    repeated Loc id_locs = 4;
  }

  oneof dd {
    Id id = 1;
    Declarator d = 2;
    Array array = 3;
    FuncType ft = 4;
    IdsList ids_list = 5;
  }
}

message AbstractDeclarator {
  int32 ptr_idx = 1; // optional; Pointer
  Loc ptr_loc = 2;
  int32 dad_idx = 3; // optional; DirectAbstractDeclarator
  Loc dad_loc = 4;
}

message DirectAbstractDeclarator {
  message Simple {
    AbstractDeclarator ad = 1;
    Loc ad_loc = 2;
  }
  message Array {
    int32 dad_idx = 1; // optional; DirectAbstractDeclarator
    Loc dad_loc = 2;
    int32 size_idx = 3; // optional; Expr
    Loc size_loc = 4;
  }
  message Func {
    int32 dad_idx = 1; // optional; DirectAbstractDeclarator
    Loc dad_loc = 2;
    repeated ParamDeclaration pds = 3; // optional
    repeated Loc pd_locs = 4;
    bool has_ellipsis = 5;
    Loc ellipsis_loc = 6;
  }

  oneof dad {
    Simple simple = 1;
    Array array = 2;
    Func func = 3;
  }
}

message ParamDeclaration {
  message Named {
    repeated DeclarationSpecifier dss = 1;
    repeated Loc ds_locs = 2;
    Declarator d = 3;
    Loc d_loc = 4;
  }
  message TypeOnly {
    repeated DeclarationSpecifier dss = 1;
    repeated Loc ds_locs = 2;
    AbstractDeclarator ad = 3;
    Loc ad_loc = 4;
  }
  message TypeOnlySimple {
    repeated DeclarationSpecifier dss = 1;
    repeated Loc ds_locs = 2;
  }

  oneof pd {
    Named name = 1;
    TypeOnly type_only = 2;
    TypeOnlySimple type_only_simple = 3;
  }
}

message DeclarationSpecifier {
  oneof elem {
    StorageClassSpecifier scs = 1;
    TypeSpecifier ts = 2;
    TypeQualifier tq = 3;
  }
  Loc loc = 4;
}

enum StorageClassSpecifier {
  TYPEDEF = 0;
  EXTERN = 1;
  STATIC = 2;
  AUTO = 3;
  REGISTER = 4;
}

message Pointer {
  repeated TypeQualifier qs = 1;
  repeated Loc q_locs = 2;
  int32 ptr_idx = 3; // optional; Pointer
  Loc ptr_loc = 4;
}

message Initializer {
  message Expr {
    int32 e = 1; // Expr
    Loc e_loc = 2;
  }
  message Struct {
    repeated int32 inits = 1; // Initializer
    repeated Loc init_locs = 2;
  }

  oneof init {
    Expr expr = 1;
    Struct struct = 2;
  }
}

message Declaration {
  message Id {
    Declarator d = 1;
    Loc d_loc = 2;
    int32 init_idx = 3; // optional; Initializer
    Loc init_loc = 4;
  }

  repeated DeclarationSpecifier dss = 1;
  repeated Loc ds_locs = 2;
  repeated Id ids = 3; // optional
}

message FunctionDef {
  repeated DeclarationSpecifier dss = 1;
  repeated Loc ds_locs = 2;
  Declarator d = 3;
  Loc d_loc = 4;
  repeated Declaration dls = 5; // optional
  repeated Loc dl_locs = 6;
  Statement.Compound body = 7;
  Loc body_loc = 8;
}

message Statement {
  message Compound {
    repeated Declaration dls = 1;
    repeated Loc dl_locs = 2;
    repeated int32 stmt_idxes = 3; // Statement
    repeated Loc stmt_locs = 4;
  }
  message Labeled {
    message Id {
      string id = 1;
      Loc id_loc = 2;
      int32 stmt_idx = 3; // Statement
      Loc stmt_loc = 4;
    }
    message Case {
      int32 e_idx = 1; // Expr
      Loc e_loc = 2;
      int32 stmt_idx = 3; // Statement
      Loc stmt_loc = 4;
    }
    message Default {
      int32 stmt_idx = 1; // Statement
      Loc stmt_loc = 2;
    }

    oneof l {
      Id id = 1;
      Case case_s = 2;
      Default default_s = 3;
    }
  }
  message Expr {
    int32 e_idx = 1; // optional; Expr
    Loc e_loc = 2;
  }
  message If {
    int32 cond_idx = 1; // Expr
    Loc cond_loc = 2;
    int32 then_idx = 3; // Statement
    Loc then_loc = 4;
    int32 else_idx = 5; // optional; Statement
    Loc else_loc = 6;
  }
  message Switch {
    int32 e_idx = 1; // Expr
    Loc e_loc = 2;
    int32 body_idx = 3; // Statement
    Loc body_loc = 4;
  }
  message While {
    int32 e_idx = 1; // Expr
    Loc e_loc = 2;
    int32 body_idx = 3; // Statement
    Loc body_loc = 4;
  }
  message DoWhile {
    int32 body_idx = 1; // Statement
    Loc body_loc = 2;
    int32 e_idx = 3; // Expr
    Loc e_loc = 4;
  }
  message For {
    int32 e1_idx = 1; // optional; Expr
    Loc e1_loc = 2;
    int32 e2_idx = 3; // optional; Expr
    Loc e2_loc = 4;
    int32 e3_idx = 5; // optional; Expr
    Loc e3_loc = 6;
    int32 body_idx = 7; // Statement
    Loc body_loc = 8;
  }
  message Goto {
    string id = 1;
    Loc id_loc = 2;
  }
  message Continue {}
  message Break {}
  message Return {
    int32 e_idx = 1; // optional; Expr
    Loc e_loc = 2;
  }

  oneof stmt {
    Compound compound = 1;
    Labeled labeled = 2;
    Expr expr = 3;
    If if_s = 4;
    Switch switch_s = 5;
    While while_s = 6;
    DoWhile do_while_s = 7;
    For for_s = 8;
    Goto goto_s = 9;
    Continue continue_s = 10;
    Break break_s = 11;
    Return return_s = 12;
  }
}

message TypeName {
  message SpQl { // either type specifier or type qualifier
    oneof elem {
      TypeSpecifier sp = 1;
      TypeQualifier ql = 2;
    }
    Loc loc = 3;
  }
  repeated SpQl sp_qls = 1;
  AbstractDeclarator ad = 2; // optional
  Loc ad_loc = 3;
}

message Loc {
  message Range {
    // begin
    int32 line_begin = 1;
    int32 col_begin = 2;

    // end (optional)
    int32 line_end = 3;
    int32 col_end = 4;

    string file_name = 5;
  }

  // [leaf, ..., root]
  repeated Range levels = 1;
}
