/*
  To generator parser, use:

  java -jar src/main/resources/java-cup-11b.jar \
       -parser CupParser -symbols CupSymbols -destdir src/main/java/c4/ast/ \
       src/main/resources/parser.cup
*/
package c4.ast;

import java.math.BigInteger;

import scala.collection.Seq;
import scala.Tuple2;
import scala.util.Either;
import scala.Option;

import java_cup.runtime.*;

import c4.io.*;
import c4.util.*;

parser code {:
  public C4Scanner getC4Scanner() {
    return (C4Scanner) getScanner();
  }

  @Override public void syntax_error(Symbol cur_token) {
    String tokenRepr = "<unknown>";
    if (0 <= cur_token.sym) {
      tokenRepr = CupSymbols.terminalNames[cur_token.sym];
    }
    tokenRepr += ", " + cur_token.value;

    System.err.println("Syntax error at " + tokenRepr);
    report_expected_token_ids();
  }

  private static <T> Option<T> some(T t) {
    return JavaUtils.some(t);
  }

  private static <T> Option<T> none() {
    return JavaUtils.none();
  }

  private static <T, P> Tuple2<T, P> pair(T t, P p) {
    return JavaUtils.pair(t, p);
  }

  private static <A, B> Either<A, B> left(A a) {
    return JavaUtils.left(a);
  }

  private static <A, B> Either<A, B> right(B b) {
    return JavaUtils.right(b);
  }

  private static <A, B> A fst(Tuple2<A, B> x) {
    return JavaUtils.fst(x);
  }

  private static <A, B> B snd(Tuple2<A, B> x) {
    return JavaUtils.snd(x);
  }

  private static <T> Seq<T> seq() {
    return JavaUtils.seq();
  }

  private static <T> T head(Seq<T> xs) {
    return JavaUtils.head(xs);
  }

  private static <T> T last(Seq<T> xs) {
    return JavaUtils.last(xs);
  }
:}

init with {: /* no need to initialize */ :};
scan with {: return getScanner().next_token(); :};

// literals
terminal Located<TokId>         ID              ;
terminal Located<TokInteger>    INTEGER_LIT     ;
terminal Located<TokFloat>      FLOAT_LIT       ;
terminal Located<TokDouble>     DOUBLE_LIT      ;
terminal Located<TokLongDouble> LONG_DOUBLE_LIT ;
terminal Located<TokChar>       CHAR_LIT        ;
terminal Located<TokWideChar>   WIDE_CHAR_LIT   ;
terminal Located<TokStr>        STR_LIT         ;
terminal Located<TokWideStr>    WIDE_STR_LIT    ;

// context-sensitive typedef name
terminal Located<TokId>         TYPEDEF_NAME    ;

// keywords
terminal Loc    AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE,
                ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER,
                RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF,
                UNION, UNSIGNED, VOID, VOLATILE, WHILE;

// op/sym       [       ]       (       )       {       }
terminal Loc    LSBRKT, RSBRKT, LPAREN, RPAREN, LBRACE, RBRACE,
//              .    ,      ;          ...       ->   ++   --   &      *
                DOT, COMMA, SEMICOLON, ELLIPSIS, PTR, INC, DEC, B_AND, STAR,
//              +    -    ~      !      /    %    <<      >>      <   >
                ADD, SUB, TILDE, L_NOT, DIV, MOD, LSHIFT, RSHIFT, LE, GT,
//              <=   >=   ==  !=   ^    |     &&     ||    ?      :
                LEQ, GEQ, EQ, NEQ, XOR, B_OR, L_AND, L_OR, QMARK, COLON,
//              =       *=          /=          %=          +=
                ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN,
//              -=          <<=            >>=            &=
                SUB_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN, B_AND_ASSIGN,
//              ^=          |=
                XOR_ASSIGN, B_OR_ASSIGN;

non terminal Located<TypeName> type_name;

non terminal Seq<Located<Stmt>> statement_list;
non terminal     Located<Stmt>  statement;
non terminal     Located<Stmt>  labeled_statement;
non terminal     Located<Stmt>  selection_statement;
non terminal     Located<Stmt>  iteration_statement;
non terminal     Located<Stmt>  jump_statement;

non terminal Located<ExprStmt>     expression_statement;
non terminal Located<CompoundStmt> compound_statement;

non terminal Seq<Located<Either<Located<FunctionDef>, Located<Declaration>>>>
    translation_unit;
non terminal     Located<Either<Located<FunctionDef>, Located<Declaration>>>
    external_declaration;

non terminal Located<FunctionDef> function_definition;

non terminal Seq<Located<Declaration>> declaration_list;
non terminal     Located<Declaration>  declaration;

non terminal Seq<Tuple2<Located<Declarator>, Option<Located<Initializer>>>>
    init_declarator_list;
non terminal     Tuple2<Located<Declarator>, Option<Located<Initializer>>>
    init_declarator;

non terminal Seq<Located<Initializer>> initializer_list;
non terminal     Located<Initializer>  initializer;

non terminal Located<Pointer> pointer;

non terminal Seq<Located<TokId>> identifier_list;

non terminal Seq<Located<DeclarationSpecifier>> declaration_specifiers;
non terminal Located<StorageClassSpecifier>
    storage_class_specifier;

non terminal Located<Declarator> declarator;

non terminal Located<DirectDeclarator> direct_declarator;

non terminal Located<AbstractDeclarator> abstract_declarator;

non terminal Located<DirectAbstractDeclarator> direct_abstract_declarator;

non terminal Tuple2<Seq<Located<ParamDeclaration>>, Option<Loc>>
    parameter_type_list;
non terminal        Seq<Located<ParamDeclaration>>
    parameter_list;
non terminal            Located<ParamDeclaration>
    parameter_declaration;

non terminal Seq<Tuple2<Located<TokId>, Option<Located<Expr>>>> enumerator_list;
non terminal     Tuple2<Located<TokId>, Option<Located<Expr>>>  enumerator;

non terminal Seq<Located<StructDeclaration>> struct_declaration_list;
non terminal     Located<StructDeclaration>  struct_declaration;

non terminal Seq<Tuple2<Option<Located<Declarator>>, Option<Located<Expr>>>>
    struct_declarator_list;
non terminal     Tuple2<Option<Located<Declarator>>, Option<Located<Expr>>>
    struct_declarator;

non terminal Seq<Located<TypeQualifier>>
    type_qualifier_list;
non terminal Seq<Located<Either<TypeSpecifier, TypeQualifier>>>
    specifier_qualifier_list;
non terminal Located<TypeSpecifier> type_specifier,
    enum_specifier, struct_or_union_specifier;
non terminal Located<TypeQualifier> type_qualifier;

non terminal Located<Expr> expression,
    constant_expression, assignment_expression, conditional_expression,
    logical_or_expression, logical_and_expression, inclusive_or_expression,
    exclusive_or_expression, and_expression, equality_expression,
    relational_expression, shift_expression, additive_expression,
    multiplicative_expression, assignment_operator, unary_expression,
    postfix_expression, argument_expression_list, cast_expression,
    primary_expression;

precedence nonassoc ELSE;

start with translation_unit;

translation_unit // Seq[L[Either[L[FunctionDef], L[Declaration]]]]
    ::= translation_unit:xs external_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                     external_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

external_declaration // L[Either[L[FunctionDef], L[Declaration]]]
    ::= function_definition:x
        {: RESULT = Located.of(x.loc(), left(x)); :}
      | declaration:y
        {: RESULT = Located.of(y.loc(), right(y)); :}
      ;

function_definition // Located<FunctionDef>
    ::= declaration_specifiers:dss declarator:d declaration_list:dl
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(head(dss).loc(), body.loc(),
            new FunctionDef(dss, d, some(dl), body)); :}
      | declaration_specifiers:dss declarator:d
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(head(dss).loc(), body.loc(),
            new FunctionDef(dss, d, none(), body)); :}
      |                            declarator:d declaration_list:dl
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(d.loc(), body.loc(),
            new FunctionDef(JavaUtils.seq(), d, some(dl), body)); :}
      |                            declarator:d
        {: getC4Scanner().enterScope(); :}
        compound_statement:body
        {: getC4Scanner().exitScope();
           RESULT = Located.of(d.loc(), body.loc(),
            new FunctionDef(JavaUtils.seq(), d, none(), body)); :}
      ;

// when declaration_specifiers contains "typedef", all IDs
// appeared in init_declarator_list are added to the typedef names set.
declaration // Located<Declaration>
    ::= declaration_specifiers:dss init_declarator_list:ids SEMICOLON:l
        {: JavaUtils.checkTypedef(dss, ids, getC4Scanner());
           RESULT = Located.of(head(dss).loc(), l,
            new Declaration(dss, some(ids))); :}
      | declaration_specifiers:dss                          SEMICOLON:l
        {: RESULT = Located.of(head(dss).loc(), l, new Declaration(dss, none())); :}
      ;

declaration_specifiers // Seq[L[DeclarationSpecifier]]
    ::= storage_class_specifier:x declaration_specifiers:xs
        {: RESULT = JavaUtils.prepend(
            Located.of(x.loc(), last(xs).loc(),
                new DeclarationSpecifierStorageClass(x)),
            xs); :}
      | storage_class_specifier:x
        {: RESULT = JavaUtils.seq(
            Located.of(x.loc(),
                new DeclarationSpecifierStorageClass(x))); :}
      | type_specifier:x declaration_specifiers:xs
        {: RESULT = JavaUtils.prepend(
            Located.of(x.loc(), last(xs).loc(),
                new DeclarationSpecifierTypeSpecifier(x)),
            xs); :}
      | type_specifier:x
        {: RESULT = JavaUtils.seq(
            Located.of(x.loc(),
                new DeclarationSpecifierTypeSpecifier(x))); :}
      | type_qualifier:x declaration_specifiers:xs
        {: RESULT = JavaUtils.prepend(
            Located.of(x.loc(), last(xs).loc(),
                new DeclarationSpecifierTypeQualifier(x)),
            xs); :}
      | type_qualifier:x
        {: RESULT = JavaUtils.seq(
            Located.of(x.loc(),
                new DeclarationSpecifierTypeQualifier(x))); :}
      ;

init_declarator_list // Seq[(L[Declarator], Option[L[Initializer]])]
    ::=                               init_declarator:x
        {: RESULT = JavaUtils.seq(x); :}
      | init_declarator_list:xs COMMA init_declarator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

init_declarator // Tuple2<Located<Declarator>, Option<Located<Initializer>>>
    ::= declarator:d
        {: RESULT = pair(d, none()); :}
      | declarator:d ASSIGN initializer:i
        {: RESULT = pair(d, some(i)); :}
      ;

declarator // Located<Declarator>
    ::= pointer:ptr direct_declarator:dd
        {: RESULT = Located.of(ptr.loc(), dd.loc(),
            new Declarator(some(ptr), dd)); :}
      |             direct_declarator:dd
        {: RESULT = Located.of(dd.loc(), new Declarator(none(), dd)); :}
      ;

direct_declarator // Located<DirectDeclarator>
    ::= ID:id
        {: RESULT = new Located(id.loc(), new DirectDeclaratorId(id)); :}
      | LPAREN:l1 declarator:d RPAREN:l2
        {: RESULT = Located.of(l1, l2, new DirectDeclaratorDeclarator(d)); :}
      | direct_declarator:dd LSBRKT constant_expression:e RSBRKT:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorArray(dd, some(e))); :}
      | direct_declarator:dd LSBRKT                       RSBRKT:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorArray(dd, none())); :}
      | direct_declarator:dd LPAREN parameter_type_list:tl RPAREN:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorFuncTypes(dd, fst(tl), snd(tl))); :}
      | direct_declarator:dd LPAREN identifier_list:il RPAREN:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorIdsList(dd, il)); :}
      | direct_declarator:dd LPAREN                 RPAREN:loc
        {: RESULT = Located.of(dd.loc(), loc,
            new DirectDeclaratorIdsList(dd, JavaUtils.seq())); :}
      ;

pointer // Located<Pointer>
    ::= STAR:loc type_qualifier_list:qs pointer:ptr
        {: RESULT = Located.of(loc,      ptr.loc(), new Pointer(qs, some(ptr))); :}
      | STAR:loc type_qualifier_list:qs
        {: RESULT = Located.of(loc, head(qs).loc(), new Pointer(qs, none())); :}
      | STAR:loc                        pointer:ptr
        {: RESULT = Located.of(loc, ptr.loc(),
            new Pointer(JavaUtils.seq(), some(ptr))); :}
      | STAR:loc
        {: RESULT = Located.of(loc, new Pointer(JavaUtils.seq(), none())); :}
      ;

type_qualifier_list // Seq<Located<TypeQualifier>>
    ::= type_qualifier_list:xs type_qualifier:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                        type_qualifier:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

parameter_type_list // (Seq[Located[ParamDeclaration]], Option[Loc])
    ::= parameter_list:xs
        {: RESULT = pair(xs, none()); :}
      | parameter_list:xs COMMA ELLIPSIS:loc
        {: RESULT = pair(xs, some(loc)); :}
      ;

parameter_list // Seq[Located[ParamDeclaration]]
    ::=                         parameter_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | parameter_list:xs COMMA parameter_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

parameter_declaration // Located[ParamDeclaration]
    ::= declaration_specifiers:dss declarator:d
        {: RESULT = Located.of(head(dss).loc(), d.loc(),
            new ParamDeclarationNamed(dss, d)); :}
      | declaration_specifiers:dss abstract_declarator:ad
        {: RESULT = Located.of(head(dss).loc(), ad.loc(),
            new ParamDeclarationTypeOnly(dss, ad)); :}
      | declaration_specifiers:dss
        {: RESULT = Located.of(head(dss).loc(),
            new ParamDeclarationTypeOnlySimple(dss)); :}
      ;

identifier_list // Seq<Located<TokId>>
    ::= identifier_list:xs COMMA ID:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                          ID:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

compound_statement // Located<CompoundStmt>
    ::= LBRACE:l1 declaration_list:x statement_list:y RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(    x,     y)); :}
      | LBRACE:l1 declaration_list:x                  RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(    x, seq())); :}
      | LBRACE:l1                    statement_list:y RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(seq(),     y)); :}
      | LBRACE:l1                                     RBRACE:l2
        {: RESULT = Located.of(l1, l2, new CompoundStmt(seq(), seq())); :}
      ;

declaration_list // Seq<Located<Declaration>>
    ::=                     declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | declaration_list:xs declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

statement_list // Seq<Located<Stmt>>
    ::=                   statement:x
        {: RESULT = JavaUtils.seq(x); :}
      | statement_list:xs statement:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

storage_class_specifier // Located<StorageClassSpecifier>
    ::= TYPEDEF:loc  {: RESULT = Located.of(loc,  c4.ast.Typedef$.MODULE$); :}
      | EXTERN:loc   {: RESULT = Located.of(loc,   c4.ast.Extern$.MODULE$); :}
      | STATIC:loc   {: RESULT = Located.of(loc,   c4.ast.Static$.MODULE$); :}
      | AUTO:loc     {: RESULT = Located.of(loc,     c4.ast.Auto$.MODULE$); :}
      | REGISTER:loc {: RESULT = Located.of(loc, c4.ast.Register$.MODULE$); :}
      ;

type_specifier // Located<TypeSpecifier>
    ::= VOID:loc     {: RESULT = new Located(loc,     c4.ast.Void$.MODULE$); :}
      | CHAR:loc     {: RESULT = new Located(loc,     c4.ast.Char$.MODULE$); :}
      | SHORT:loc    {: RESULT = new Located(loc,    c4.ast.Short$.MODULE$); :}
      | INT:loc      {: RESULT = new Located(loc,      c4.ast.Int$.MODULE$); :}
      | LONG:loc     {: RESULT = new Located(loc,     c4.ast.Long$.MODULE$); :}
      | FLOAT:loc    {: RESULT = new Located(loc,    c4.ast.Float$.MODULE$); :}
      | DOUBLE:loc   {: RESULT = new Located(loc,   c4.ast.Double$.MODULE$); :}
      | SIGNED:loc   {: RESULT = new Located(loc,   c4.ast.Signed$.MODULE$); :}
      | UNSIGNED:loc {: RESULT = new Located(loc, c4.ast.Unsigned$.MODULE$); :}
      | struct_or_union_specifier:x     {: RESULT = x; :}
      | enum_specifier:x                {: RESULT = x; :}
      | TYPEDEF_NAME:x
        {: RESULT = new Located(x.loc(), new TypedefName(x.value())); :}
      ;

struct_or_union_specifier // Located<TypeSpecifier>
    ::= STRUCT:loc1 ID:id LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new StructSpecifier(some(id), some(body))); :}
      | STRUCT:loc1       LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new StructSpecifier(  none(), some(body))); :}
      | STRUCT:loc1 ID:id
        {: RESULT = Located$.MODULE$.of(loc1, id.loc(),
            new StructSpecifier(some(id),     none())); :}
      | UNION:loc1  ID:id LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new UnionSpecifier(some(id), some(body))); :}
      | UNION:loc1        LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new UnionSpecifier(  none(), some(body))); :}
      | UNION:loc1  ID:id
        {: RESULT = Located$.MODULE$.of(loc1, id.loc(),
            new UnionSpecifier(some(id),     none())); :}
      ;

struct_declaration_list // Seq[L[StructDeclaration]]
    ::=                            struct_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | struct_declaration_list:xs struct_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

struct_declaration // L[StructDeclaration]
    ::= specifier_qualifier_list:a struct_declarator_list:b SEMICOLON:c
        {: RESULT = StructDeclaration$.MODULE$.ofLoc(a, b, c); :}
      ;

specifier_qualifier_list // Seq<Located<Either<TypeSpecifier, TypeQualifier>>>
    ::= type_specifier:x specifier_qualifier_list:xs
        {:
          RESULT = JavaUtils.prepend(
            new Located(x.loc(), left(x.value())),
            xs);
        :}
      | type_specifier:x
        {: RESULT = JavaUtils.seq(new Located(x.loc(), left(x.value()))); :}
      | type_qualifier:x specifier_qualifier_list:xs
        {:
          RESULT = JavaUtils.prepend(
            new Located(x.loc(), right(x.value())),
            xs);
        :}
      | type_qualifier:x
        {: RESULT = JavaUtils.seq(new Located(x.loc(), right(x.value()))); :}
      ;

struct_declarator_list // Seq[(Option[L[Declarator]], Option[L[Expr]])]
    ::= struct_declarator_list:xs COMMA struct_declarator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                                 struct_declarator:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

struct_declarator // (Option[Located[Declarator]], Option[Located[Expr]])
    ::= declarator:x
        {: RESULT = pair(some(x), none()); :}
      | declarator:x COLON constant_expression:e
        {: RESULT = pair(some(x), some(e)); :}
      |              COLON constant_expression:e
        {: RESULT = pair(none(), some(e)); :}
      ;

enum_specifier // Located[TypeSpecifier]
    ::= ENUM:loc1 ID:id LBRACE enumerator_list:body RBRACE:loc2
        {:
          RESULT = new Located(
            LocRange.of(loc1, loc2),
            new EnumSpecifier(some(id), some(body)));
        :}
      | ENUM:loc1       LBRACE enumerator_list:body RBRACE:loc2
        {:
          RESULT = new Located(
            LocRange.of(loc1, loc2),
            new EnumSpecifier(none(), some(body)));
        :}
      | ENUM:loc  ID:id
        {:
          RESULT = new Located(
            LocRange.of(loc, id.loc()),
            new EnumSpecifier(some(id), none()));
        :}
      ;

enumerator_list // Seq[(Located[TokId], Option[Located[Expr]])]
    ::=                          enumerator:x
        {: RESULT = JavaUtils.seq(x); :}
      | enumerator_list:xs COMMA enumerator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

enumerator // (Located[TokId], Option[Located[Expr]])
    ::= ID:id
        {: RESULT = pair(id, none()); :}
      | ID:id ASSIGN constant_expression:e
        {: RESULT = pair(id, some(e)); :}
      ;

type_qualifier // Located<TypeQualifier>
    ::= CONST:loc    {: RESULT = new Located(loc,    c4.ast.Const$.MODULE$); :}
      | VOLATILE:loc {: RESULT = new Located(loc, c4.ast.Volatile$.MODULE$); :}
      ;

initializer // Located<Initializer>
    ::= assignment_expression:e
        {: RESULT = Located.of(e.loc(), new InitializerExpr(e)); :}
      | LBRACE:l1 initializer_list:il       RBRACE:l2
        {: RESULT = Located.of(l1, l2, new InitializerStruct(il)); :}
      | LBRACE:l1 initializer_list:il COMMA RBRACE:l2
        {: RESULT = Located.of(l1, l2, new InitializerStruct(il)); :}
      ;

initializer_list // Seq<Located<Initializer>>
    ::=                           initializer:x
        {: RESULT = JavaUtils.seq(x); :}
      | initializer_list:xs COMMA initializer:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

type_name // Located<TypeName>
    ::= specifier_qualifier_list:sqs abstract_declarator:ad
        {: RESULT = Located.of(head(sqs).loc(), ad.loc(),
            new TypeName(sqs, some(ad))); :}
      | specifier_qualifier_list:sqs
        {: RESULT = Located.of(head(sqs).loc(),
            new TypeName(sqs, none())); :}
      ;

abstract_declarator // Located<AbstractDeclarator>
    ::= pointer:ptr
        {: RESULT = Located.of(ptr.loc(),
            new AbstractDeclarator(some(ptr), none())); :}
      | pointer:ptr direct_abstract_declarator:dad
        {: RESULT = Located.of(ptr.loc(), dad.loc(),
            new AbstractDeclarator(some(ptr), some(dad))); :}
      |             direct_abstract_declarator:dad
        {: RESULT = Located.of(dad.loc(),
            new AbstractDeclarator(none(), some(dad))); :}
      ;

direct_abstract_declarator // Located<DirectAbstractDeclarator>
    ::= LPAREN:b abstract_declarator:ad RPAREN:e
        {: RESULT = Located.of(b, e, new DirectAbstractDeclaratorSimple(ad)); :}
      | direct_abstract_declarator:dad LSBRKT   constant_expression:e RSBRKT:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorArray(some(dad), some(e))); :}
      | direct_abstract_declarator:dad LSBRKT                         RSBRKT:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorArray(some(dad), none())); :}
      |                                LSBRKT:b constant_expression:e RSBRKT:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorArray(none(), some(e))); :}
      |                                LSBRKT:b                       RSBRKT:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorArray(none(), none())); :}
      | direct_abstract_declarator:dad LPAREN   parameter_type_list:p RPAREN:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorFunc(some(dad), some(p))); :}
      | direct_abstract_declarator:dad LPAREN                         RPAREN:end
        {: RESULT = Located.of(dad.loc(), end,
            new DirectAbstractDeclaratorFunc(some(dad), none())); :}
      |                                LPAREN:b parameter_type_list:p RPAREN:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorFunc(none(), some(p))); :}
      |                                LPAREN:b                       RPAREN:end
        {: RESULT = Located.of(b, end,
            new DirectAbstractDeclaratorFunc(none(), none())); :}
      ;

statement // Located<Stmt>
    ::= labeled_statement:x {: RESULT = x; :}
      | {: getC4Scanner().enterScope(); :}
        compound_statement:x
        {: getC4Scanner().exitScope();
           RESULT = Located.of(x.loc(), x.value()); :}
      | expression_statement:x
        {: RESULT = Located.of(x.loc(), x.value()); :}
      | selection_statement:x {: RESULT = x; :}
      | iteration_statement:x {: RESULT = x; :}
      | jump_statement:x {: RESULT = x; :}
      ;

labeled_statement // Located<Stmt>
    ::= ID:id COLON statement:s
        {: RESULT = Located.of(id.loc(), s.loc(), new LabeledStmtId(id, s)); :}
      | CASE:b constant_expression:e COLON statement:s
        {: RESULT = Located.of(b, s.loc(), new LabeledStmtCase(e, s)); :}
      | DEFAULT:b COLON statement:s
        {: RESULT = Located.of(b, s.loc(), new LabeledStmtDefault(s)); :}
      ;

expression_statement // Located<Stmt>
    ::= expression:e SEMICOLON:end
        {: RESULT = Located.of(e.loc(), end, new ExprStmt(some(e))); :}
      |              SEMICOLON:end
        {: RESULT = Located.of(end, new ExprStmt(none())); :}
      ;

selection_statement // Located<Stmt>
    ::= IF:b LPAREN expression:e RPAREN statement:s1
        {: RESULT = Located.of(b, s1.loc(), new IfStmt(e, s1, none())); :}
      | IF:b LPAREN expression:e RPAREN statement:s1 ELSE statement:s2
        {: RESULT = Located.of(b, s2.loc(), new IfStmt(e, s1, some(s2))); :}
      | SWITCH:b LPAREN expression:e RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(), new SwitchStmt(e, s)); :}
      ;

iteration_statement // Located<Stmt>
    ::= WHILE:b LPAREN expression:e RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(), new WhileStmt(e, s)); :}
      | DO:b statement:s WHILE LPAREN expression:expr RPAREN SEMICOLON:end
        {: RESULT = Located.of(b, end, new DoWhileStmt(s, expr)); :}
      | FOR:b LPAREN expression_statement:e1
                     expression_statement:e2
                     expression:e3 RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(),
            new ForStmt(e1.value().e(), e2.value().e(), some(e3), s)); :}
      | FOR:b LPAREN expression_statement:e1
                     expression_statement:e2 RPAREN statement:s
        {: RESULT = Located.of(b, s.loc(),
            new ForStmt(e1.value().e(), e2.value().e(), none(), s)); :}
      ;

jump_statement // Located<Stmt>
    ::= GOTO:b ID:id SEMICOLON:e
        {: RESULT = Located.of(b, e, new GotoStmt(id)); :}
      | CONTINUE:b SEMICOLON:e
        {: RESULT = Located.of(b, e, c4.ast.Continue$.MODULE$); :}
      | BREAK:b SEMICOLON:e
        {: RESULT = Located.of(b, e, c4.ast.Break$.MODULE$); :}
      | RETURN:b expression:expr SEMICOLON:e
        {: RESULT = Located.of(b, e, new Return(some(expr))); :}
      | RETURN:b SEMICOLON:e
        {: RESULT = Located.of(b, e, new Return(none())); :}
      ;

expression // Located<Expr>
    ::=                  assignment_expression
      | expression COMMA assignment_expression
      ;

constant_expression // Located<Expr>
    ::= conditional_expression
      ;

assignment_expression // Located<Expr>
    ::= conditional_expression
      | unary_expression assignment_operator assignment_expression
      ;

conditional_expression // Located<Expr>
    ::= logical_or_expression
      | logical_or_expression QMARK expression COLON conditional_expression
      ;

logical_or_expression // Located<Expr>
    ::=                            logical_and_expression
      | logical_or_expression L_OR logical_and_expression
      ;

logical_and_expression // Located<Expr>
    ::=                              inclusive_or_expression
      | logical_and_expression L_AND inclusive_or_expression
      ;

inclusive_or_expression // Located<Expr>
    ::=                              exclusive_or_expression
      | inclusive_or_expression B_OR exclusive_or_expression
      ;

exclusive_or_expression // Located<Expr>
    ::=                             and_expression
      | exclusive_or_expression XOR and_expression
      ;

and_expression // Located<Expr>
    ::=                      equality_expression
      | and_expression B_AND equality_expression
      ;

equality_expression // Located<Expr>
    ::=                         relational_expression
      | equality_expression EQ  relational_expression
      | equality_expression NEQ relational_expression
      ;

relational_expression // Located<Expr>
    ::=                           shift_expression
      | relational_expression LE  shift_expression
      | relational_expression GT  shift_expression
      | relational_expression LEQ shift_expression
      | relational_expression GEQ shift_expression
      ;

shift_expression // Located<Expr>
    ::=                         additive_expression
      | shift_expression LSHIFT additive_expression
      | shift_expression RSHIFT additive_expression
      ;

additive_expression // Located<Expr>
    ::=                         multiplicative_expression
      | additive_expression ADD multiplicative_expression
      | additive_expression SUB multiplicative_expression
      ;

multiplicative_expression // Located<Expr>
    ::=                                cast_expression
      | multiplicative_expression STAR cast_expression
      | multiplicative_expression DIV  cast_expression
      | multiplicative_expression MOD  cast_expression
      ;

assignment_operator
    ::= ASSIGN
      | MUL_ASSIGN
      | DIV_ASSIGN
      | MOD_ASSIGN
      | ADD_ASSIGN
      | SUB_ASSIGN
      | LSHIFT_ASSIGN
      | RSHIFT_ASSIGN
      | B_AND_ASSIGN
      | XOR_ASSIGN
      | B_OR_ASSIGN
      ;

unary_expression // Located<Expr>
    ::= postfix_expression
      | INC unary_expression
      | DEC unary_expression
      | B_AND cast_expression
      | STAR  cast_expression
      | ADD   cast_expression
      | SUB   cast_expression
      | TILDE cast_expression
      | L_NOT cast_expression
      | SIZEOF unary_expression
      | SIZEOF LPAREN type_name RPAREN
      ;

postfix_expression // Located<Expr>
    ::= primary_expression
      | postfix_expression LSBRKT expression RSBRKT
      | postfix_expression LPAREN argument_expression_list RPAREN
      | postfix_expression LPAREN                          RPAREN
      | postfix_expression DOT ID
      | postfix_expression PTR ID
      | postfix_expression INC
      | postfix_expression DEC
      ;

argument_expression_list
    ::=                                assignment_expression
      | argument_expression_list COMMA assignment_expression
      ;

cast_expression // Located<Expr>
    ::= unary_expression:e {: RESULT = e; :}
      | LPAREN type_name RPAREN cast_expression
      ;

primary_expression // Located<Expr>
    ::= ID:id
        {: RESULT = new Located(id.loc(), new Id(id.value().id())); :}
      | INTEGER_LIT:x
        {: RESULT = new Located(x.loc(), new IntegerLit(x.value())); :}
      | FLOAT_LIT:x
        {: RESULT = new Located(x.loc(), new FloatLit(x.value())); :}
      | DOUBLE_LIT:x
        {: RESULT = new Located(x.loc(), new DoubleLit(x.value())); :}
      | LONG_DOUBLE_LIT:x
        {: RESULT = new Located(x.loc(), new LongDoubleLit(x.value())); :}
      | CHAR_LIT:x
        {: RESULT = new Located(x.loc(), new CharLit(x.value())); :}
      | WIDE_CHAR_LIT:x
        {: RESULT = new Located(x.loc(), new WideCharLit(x.value())); :}
      | STR_LIT:x
        {: RESULT = new Located(x.loc(), new StrLit(x.value())); :}
      | WIDE_STR_LIT:x
        {: RESULT = new Located(x.loc(), new WideStrLit(x.value())); :}
      | LPAREN expression:e RPAREN {: RESULT = e; :}
      ;
