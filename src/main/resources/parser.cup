/*
  To generator parser, use:

  java -jar src/main/resources/java-cup-11b.jar \
       -parser CupParser -symbols CupSymbols -destdir src/main/java/c4/ast/ \
       src/main/resources/parser.cup
*/
package c4.ast;

import java.math.BigInteger;

import scala.collection.Seq;
import scala.Tuple2;
import scala.util.Either;
import scala.Option;

import java_cup.runtime.*;

import c4.io.*;
import c4.util.*;

parser code {:
  public C4Scanner getC4Scanner() {
    return (C4Scanner) getScanner();
  }

  @Override public void syntax_error(Symbol cur_token) {
    String tokenRepr = "<unknown>";
    if (0 <= cur_token.sym) {
      tokenRepr = CupSymbols.terminalNames[cur_token.sym];
    }
    tokenRepr += ", " + cur_token.value;

    System.err.println("Syntax error at " + tokenRepr);
    report_expected_token_ids();
  }

  private static <T> Option<T> some(T t) {
    return JavaUtils.some(t);
  }

  private static <T> Option<T> none() {
    return JavaUtils.none();
  }

  private static <T, P> Tuple2<T, P> pair(T t, P p) {
    return JavaUtils.pair(t, p);
  }

  private static <A, B> Either<A, B> left(A a) {
    return JavaUtils.left(a);
  }

  private static <A, B> Either<A, B> right(B b) {
    return JavaUtils.right(b);
  }
:}

init with {: /* no need to initialize */ :};
scan with {: return getScanner().next_token(); :};

// literals
terminal Located<TokId>         ID              ;
terminal Located<TokInteger>    INTEGER_LIT     ;
terminal Located<TokFloat>      FLOAT_LIT       ;
terminal Located<TokDouble>     DOUBLE_LIT      ;
terminal Located<TokLongDouble> LONG_DOUBLE_LIT ;
terminal Located<TokChar>       CHAR_LIT        ;
terminal Located<TokWideChar>   WIDE_CHAR_LIT   ;
terminal Located<TokStr>        STR_LIT         ;
terminal Located<TokWideStr>    WIDE_STR_LIT    ;

// context-sensitive typedef name
terminal Located<TokId>         TYPEDEF_NAME    ;

// keywords
terminal Loc    AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE,
                ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER,
                RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF,
                UNION, UNSIGNED, VOID, VOLATILE, WHILE;

// op/sym       [       ]       (       )       {       }
terminal Loc    LSBRKT, RSBRKT, LPAREN, RPAREN, LBRACE, RBRACE,
//              .    ,      ;          ...       ->   ++   --   &      *
                DOT, COMMA, SEMICOLON, ELLIPSIS, PTR, INC, DEC, B_AND, STAR,
//              +    -    ~      !      /    %    <<      >>      <   >
                ADD, SUB, TILDE, L_NOT, DIV, MOD, LSHIFT, RSHIFT, LE, GT,
//              <=   >=   ==  !=   ^    |     &&     ||    ?      :
                LEQ, GEQ, EQ, NEQ, XOR, B_OR, L_AND, L_OR, QMARK, COLON,
//              =       *=          /=          %=          +=
                ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN,
//              -=          <<=            >>=            &=
                SUB_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN, B_AND_ASSIGN,
//              ^=          |=
                XOR_ASSIGN, B_OR_ASSIGN;

// non terminal expr;
// non terminal            expr_list;
// non terminal BigInteger expr;
non terminal translation_unit, external_declaration, function_definition, declaration, declaration_specifiers, init_declarator_list, init_declarator, direct_declarator, pointer, type_qualifier_list, parameter_type_list, parameter_list, parameter_declaration, identifier_list, compound_statement, declaration_list, statement_list, storage_class_specifier, initializer, initializer_list, type_name, abstract_declarator, direct_abstract_declarator, statement, labeled_statement, expression_statement, selection_statement, iteration_statement, jump_statement;

non terminal Located<Declarator> declarator;

non terminal Seq<Tuple2<Located<TokId>, Option<Located<Expr>>>> enumerator_list;
non terminal     Tuple2<Located<TokId>, Option<Located<Expr>>>  enumerator;

non terminal Seq<Located<StructDeclaration>> struct_declaration_list;
non terminal     Located<StructDeclaration>  struct_declaration;

non terminal Seq<Tuple2<Option<Located<Declarator>>, Option<Located<Expr>>>>
    struct_declarator_list;
non terminal     Tuple2<Option<Located<Declarator>>, Option<Located<Expr>>>
    struct_declarator;

non terminal Seq<Located<Either<TypeSpecifier, TypeQualifier>>>
    specifier_qualifier_list;
non terminal Located<TypeSpecifier> type_specifier,
    enum_specifier, struct_or_union_specifier;
non terminal Located<TypeQualifier> type_qualifier;

non terminal Located<Expr> expression,
    constant_expression, assignment_expression, conditional_expression,
    logical_or_expression, logical_and_expression, inclusive_or_expression,
    exclusive_or_expression, and_expression, equality_expression,
    relational_expression, shift_expression, additive_expression,
    multiplicative_expression, assignment_operator, unary_expression,
    postfix_expression, argument_expression_list, cast_expression,
    primary_expression;

precedence nonassoc ELSE;

// expr_list ::= expr_list expr:e SEMICOLON {: System.out.println(e); :}
//             | expr:e SEMICOLON           {: System.out.println(e); :}
//             ;
//
// expr      ::= expr:e1 PLUS expr:e2      {: RESULT = e1.add(e2); :}
//             | NUMBER:n                  {: RESULT = n; :}
//             ;
// expr ::= ID;

start with translation_unit;

translation_unit
    ::= translation_unit external_declaration
      |                  external_declaration
      ;

external_declaration
    ::= function_definition
      | declaration
      ;

function_definition
    ::= declaration_specifiers declarator declaration_list
        {: getC4Scanner().enterScope(); :}
        compound_statement
        {: getC4Scanner().exitScope(); :}
      | declaration_specifiers declarator
        {: getC4Scanner().enterScope(); :}
        compound_statement
        {: getC4Scanner().exitScope(); :}
      |                        declarator declaration_list
        {: getC4Scanner().enterScope(); :}
        compound_statement
        {: getC4Scanner().exitScope(); :}
      |                        declarator
        {: getC4Scanner().enterScope(); :}
        compound_statement
        {: getC4Scanner().exitScope(); :}
      ;

// TODO: when declaration_specifiers contains "typedef", add all IDs
//       appeared in init_declarator_list to the typedef names set.
declaration
    ::= declaration_specifiers init_declarator_list SEMICOLON
      | declaration_specifiers                      SEMICOLON
      ;

declaration_specifiers
    ::= storage_class_specifier declaration_specifiers
      | storage_class_specifier
      | type_specifier declaration_specifiers
      | type_specifier
      | type_qualifier declaration_specifiers
      | type_qualifier
      ;

init_declarator_list
    ::= init_declarator
      | init_declarator_list COMMA init_declarator
      ;

init_declarator
    ::= declarator
      | declarator ASSIGN initializer
      ;

declarator // Located<Declarator>
    ::= pointer direct_declarator
      |         direct_declarator
      ;

direct_declarator
    ::= ID
      | LPAREN declarator RPAREN
      | direct_declarator LSBRKT constant_expression RSBRKT
      | direct_declarator LSBRKT                     RSBRKT
      | direct_declarator LPAREN parameter_type_list RPAREN
      | direct_declarator LPAREN identifier_list RPAREN
      | direct_declarator LPAREN                 RPAREN
      ;

pointer
    ::= STAR type_qualifier_list pointer
      | STAR type_qualifier_list
      | STAR                     pointer
      | STAR
      ;

type_qualifier_list
    ::= type_qualifier_list type_qualifier
      |                     type_qualifier
      ;

parameter_type_list
    ::= parameter_list
      | parameter_list COMMA ELLIPSIS
      ;

parameter_list
    ::=                      parameter_declaration
      | parameter_list COMMA parameter_declaration
      ;

parameter_declaration
    ::= declaration_specifiers declarator
      | declaration_specifiers abstract_declarator
      | declaration_specifiers
      ;

identifier_list
    ::= identifier_list COMMA ID
      |                       ID
      ;

compound_statement
    ::= LBRACE declaration_list statement_list RBRACE
      | LBRACE declaration_list                RBRACE
      | LBRACE                  statement_list RBRACE
      | LBRACE                                 RBRACE
      ;

declaration_list
    ::=                  declaration
      | declaration_list declaration
      ;

statement_list
    ::=                statement
      | statement_list statement
      ;

storage_class_specifier
    ::= TYPEDEF
      | EXTERN
      | STATIC
      | AUTO
      | REGISTER
      ;

type_specifier // Located<TypeSpecifier>
    ::= VOID:loc     {: RESULT = new Located(loc,     c4.ast.Void$.MODULE$); :}
      | CHAR:loc     {: RESULT = new Located(loc,     c4.ast.Char$.MODULE$); :}
      | SHORT:loc    {: RESULT = new Located(loc,    c4.ast.Short$.MODULE$); :}
      | INT:loc      {: RESULT = new Located(loc,      c4.ast.Int$.MODULE$); :}
      | LONG:loc     {: RESULT = new Located(loc,     c4.ast.Long$.MODULE$); :}
      | FLOAT:loc    {: RESULT = new Located(loc,    c4.ast.Float$.MODULE$); :}
      | DOUBLE:loc   {: RESULT = new Located(loc,   c4.ast.Double$.MODULE$); :}
      | SIGNED:loc   {: RESULT = new Located(loc,   c4.ast.Signed$.MODULE$); :}
      | UNSIGNED:loc {: RESULT = new Located(loc, c4.ast.Unsigned$.MODULE$); :}
      | struct_or_union_specifier:x     {: RESULT = x; :}
      | enum_specifier:x                {: RESULT = x; :}
      | TYPEDEF_NAME:x
        {: RESULT = new Located(x.loc(), new TypedefName(x.value())); :}
      ;

struct_or_union_specifier // Located<TypeSpecifier>
    ::= STRUCT:loc1 ID:id LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new StructSpecifier(some(id), some(body))); :}
      | STRUCT:loc1       LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new StructSpecifier(  none(), some(body))); :}
      | STRUCT:loc1 ID:id
        {: RESULT = Located$.MODULE$.of(loc1, id.loc(),
            new StructSpecifier(some(id),     none())); :}
      | UNION:loc1  ID:id LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new UnionSpecifier(some(id), some(body))); :}
      | UNION:loc1        LBRACE struct_declaration_list:body RBRACE:loc2
        {: RESULT = Located$.MODULE$.of(loc1, loc2,
            new UnionSpecifier(  none(), some(body))); :}
      | UNION:loc1  ID:id
        {: RESULT = Located$.MODULE$.of(loc1, id.loc(),
            new UnionSpecifier(some(id),     none())); :}
      ;

struct_declaration_list // Seq[L[StructDeclaration]]
    ::=                            struct_declaration:x
        {: RESULT = JavaUtils.seq(x); :}
      | struct_declaration_list:xs struct_declaration:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

struct_declaration // L[StructDeclaration]
    ::= specifier_qualifier_list:a struct_declarator_list:b SEMICOLON:c
        {: RESULT = StructDeclaration$.MODULE$.ofLoc(a, b, c); :}
      ;

specifier_qualifier_list // Seq<Located<Either<TypeSpecifier, TypeQualifier>>>
    ::= type_specifier:x specifier_qualifier_list:xs
        {:
          RESULT = JavaUtils.prepend(
            new Located(x.loc(), left(x.value())),
            xs);
        :}
      | type_specifier:x
        {: RESULT = JavaUtils.seq(new Located(x.loc(), left(x.value()))); :}
      | type_qualifier:x specifier_qualifier_list:xs
        {:
          RESULT = JavaUtils.prepend(
            new Located(x.loc(), right(x.value())),
            xs);
        :}
      | type_qualifier:x
        {: RESULT = JavaUtils.seq(new Located(x.loc(), right(x.value()))); :}
      ;

struct_declarator_list // Seq[(Option[L[Declarator]], Option[L[Expr]])]
    ::= struct_declarator_list:xs COMMA struct_declarator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      |                                 struct_declarator:x
        {: RESULT = JavaUtils.seq(x); :}
      ;

struct_declarator // (Option[Located[Declarator]], Option[Located[Expr]])
    ::= declarator:x
        {: RESULT = pair(some(x), none()); :}
      | declarator:x COLON constant_expression:e
        {: RESULT = pair(some(x), some(e)); :}
      |              COLON constant_expression:e
        {: RESULT = pair(none(), some(e)); :}
      ;

enum_specifier // Located[TypeSpecifier]
    ::= ENUM:loc1 ID:id LBRACE enumerator_list:body RBRACE:loc2
        {:
          RESULT = new Located(
            LocRange.of(loc1, loc2),
            new EnumSpecifier(some(id), some(body)));
        :}
      | ENUM:loc1       LBRACE enumerator_list:body RBRACE:loc2
        {:
          RESULT = new Located(
            LocRange.of(loc1, loc2),
            new EnumSpecifier(none(), some(body)));
        :}
      | ENUM:loc  ID:id
        {:
          RESULT = new Located(
            LocRange.of(loc, id.loc()),
            new EnumSpecifier(some(id), none()));
        :}
      ;

enumerator_list // Seq[(Located[TokId], Option[Located[Expr]])]
    ::=                          enumerator:x
        {: RESULT = JavaUtils.seq(x); :}
      | enumerator_list:xs COMMA enumerator:x
        {: RESULT = JavaUtils.append(xs, x); :}
      ;

enumerator // (Located[TokId], Option[Located[Expr]])
    ::= ID:id
        {: RESULT = pair(id, none()); :}
      | ID:id ASSIGN constant_expression:e
        {: RESULT = pair(id, some(e)); :}
      ;

type_qualifier // Located<TypeQualifier>
    ::= CONST:loc    {: RESULT = new Located(loc,    c4.ast.Const$.MODULE$); :}
      | VOLATILE:loc {: RESULT = new Located(loc, c4.ast.Volatile$.MODULE$); :}
      ;

initializer
    ::= assignment_expression
      | LBRACE initializer_list       RBRACE
      | LBRACE initializer_list COMMA RBRACE
      ;

initializer_list
    ::=                        initializer
      | initializer_list COMMA initializer
      ;

type_name
    ::= specifier_qualifier_list abstract_declarator
      | specifier_qualifier_list
      ;

abstract_declarator
    ::= pointer
      | pointer direct_abstract_declarator
      |         direct_abstract_declarator
      ;

direct_abstract_declarator
    ::= LPAREN abstract_declarator RPAREN
      | direct_abstract_declarator LSBRKT constant_expression RSBRKT
      | direct_abstract_declarator LSBRKT                     RSBRKT
      |                            LSBRKT constant_expression RSBRKT
      |                            LSBRKT                     RSBRKT
      | direct_abstract_declarator LPAREN parameter_type_list RPAREN
      | direct_abstract_declarator LPAREN                     RPAREN
      |                            LPAREN parameter_type_list RPAREN
      |                            LPAREN                     RPAREN
      ;

statement
    ::= labeled_statement
      | {: getC4Scanner().enterScope(); :}
        compound_statement
        {: getC4Scanner().exitScope(); :}
      | expression_statement
      | selection_statement
      | iteration_statement
      | jump_statement
      ;

labeled_statement
    ::= ID COLON statement
      | CASE constant_expression COLON statement
      | DEFAULT COLON statement
      ;

expression_statement
    ::= expression SEMICOLON
      |            SEMICOLON
      ;

selection_statement
    ::= IF LPAREN expression RPAREN statement
      | IF LPAREN expression RPAREN statement ELSE statement
      | SWITCH LPAREN expression RPAREN statement
      ;

iteration_statement
    ::= WHILE LPAREN expression RPAREN statement
      | DO statement WHILE LPAREN expression RPAREN SEMICOLON
      | FOR LPAREN expression_statement
                   expression_statement
                   expression RPAREN statement
      | FOR LPAREN expression_statement
                   expression_statement RPAREN statement
      ;

jump_statement
    ::= GOTO ID SEMICOLON
      | CONTINUE SEMICOLON
      | BREAK SEMICOLON
      | RETURN expression SEMICOLON
      | RETURN SEMICOLON
      ;

expression // Located<Expr>
    ::=                  assignment_expression
      | expression COMMA assignment_expression
      ;

constant_expression // Located<Expr>
    ::= conditional_expression
      ;

assignment_expression // Located<Expr>
    ::= conditional_expression
      | unary_expression assignment_operator assignment_expression
      ;

conditional_expression // Located<Expr>
    ::= logical_or_expression
      | logical_or_expression QMARK expression COLON conditional_expression
      ;

logical_or_expression // Located<Expr>
    ::=                            logical_and_expression
      | logical_or_expression L_OR logical_and_expression
      ;

logical_and_expression // Located<Expr>
    ::=                              inclusive_or_expression
      | logical_and_expression L_AND inclusive_or_expression
      ;

inclusive_or_expression // Located<Expr>
    ::=                              exclusive_or_expression
      | inclusive_or_expression B_OR exclusive_or_expression
      ;

exclusive_or_expression // Located<Expr>
    ::=                             and_expression
      | exclusive_or_expression XOR and_expression
      ;

and_expression // Located<Expr>
    ::=                      equality_expression
      | and_expression B_AND equality_expression
      ;

equality_expression // Located<Expr>
    ::=                         relational_expression
      | equality_expression EQ  relational_expression
      | equality_expression NEQ relational_expression
      ;

relational_expression // Located<Expr>
    ::=                           shift_expression
      | relational_expression LE  shift_expression
      | relational_expression GT  shift_expression
      | relational_expression LEQ shift_expression
      | relational_expression GEQ shift_expression
      ;

shift_expression // Located<Expr>
    ::=                         additive_expression
      | shift_expression LSHIFT additive_expression
      | shift_expression RSHIFT additive_expression
      ;

additive_expression // Located<Expr>
    ::=                         multiplicative_expression
      | additive_expression ADD multiplicative_expression
      | additive_expression SUB multiplicative_expression
      ;

multiplicative_expression // Located<Expr>
    ::=                                cast_expression
      | multiplicative_expression STAR cast_expression
      | multiplicative_expression DIV  cast_expression
      | multiplicative_expression MOD  cast_expression
      ;

assignment_operator
    ::= ASSIGN
      | MUL_ASSIGN
      | DIV_ASSIGN
      | MOD_ASSIGN
      | ADD_ASSIGN
      | SUB_ASSIGN
      | LSHIFT_ASSIGN
      | RSHIFT_ASSIGN
      | B_AND_ASSIGN
      | XOR_ASSIGN
      | B_OR_ASSIGN
      ;

unary_expression // Located<Expr>
    ::= postfix_expression
      | INC unary_expression
      | DEC unary_expression
      | B_AND cast_expression
      | STAR  cast_expression
      | ADD   cast_expression
      | SUB   cast_expression
      | TILDE cast_expression
      | L_NOT cast_expression
      | SIZEOF unary_expression
      | SIZEOF LPAREN type_name RPAREN
      ;

postfix_expression // Located<Expr>
    ::= primary_expression
      | postfix_expression LSBRKT expression RSBRKT
      | postfix_expression LPAREN argument_expression_list RPAREN
      | postfix_expression LPAREN                          RPAREN
      | postfix_expression DOT ID
      | postfix_expression PTR ID
      | postfix_expression INC
      | postfix_expression DEC
      ;

argument_expression_list
    ::=                                assignment_expression
      | argument_expression_list COMMA assignment_expression
      ;

cast_expression // Located<Expr>
    ::= unary_expression:e {: RESULT = e; :}
      | LPAREN type_name RPAREN cast_expression
      ;

primary_expression // Located<Expr>
    ::= ID:id
        {: RESULT = new Located(id.loc(), new Id(id.value().id())); :}
      | INTEGER_LIT:x
        {: RESULT = new Located(x.loc(), new IntegerLit(x.value())); :}
      | FLOAT_LIT:x
        {: RESULT = new Located(x.loc(), new FloatLit(x.value())); :}
      | DOUBLE_LIT:x
        {: RESULT = new Located(x.loc(), new DoubleLit(x.value())); :}
      | LONG_DOUBLE_LIT:x
        {: RESULT = new Located(x.loc(), new LongDoubleLit(x.value())); :}
      | CHAR_LIT:x
        {: RESULT = new Located(x.loc(), new CharLit(x.value())); :}
      | WIDE_CHAR_LIT:x
        {: RESULT = new Located(x.loc(), new WideCharLit(x.value())); :}
      | STR_LIT:x
        {: RESULT = new Located(x.loc(), new StrLit(x.value())); :}
      | WIDE_STR_LIT:x
        {: RESULT = new Located(x.loc(), new WideStrLit(x.value())); :}
      | LPAREN expression:e RPAREN {: RESULT = e; :}
      ;
